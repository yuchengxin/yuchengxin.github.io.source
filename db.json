{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/uploads/cat.ico","path":"uploads/cat.ico","modified":1,"renderable":0},{"_id":"source/uploads/timg.jpg","path":"uploads/timg.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"source/uploads/image.jpg","path":"uploads/image.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"e3f65fd86dd8161b249a5cc7e2a50fe60a52d178","modified":1495384182712},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1495344960845},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1495344960847},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1495344960849},{"_id":"themes/next/.gitignore","hash":"b935cc0e5b099ebd343ca1766e02f65138c13dd0","modified":1495344960856},{"_id":"themes/next/.javascript_ignore","hash":"74b54cf920cbbf4038a68e54b7138af8b8f45588","modified":1495344960860},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1495344960858},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1495344960865},{"_id":"themes/next/.travis.yml","hash":"360f38044910e74bf628b0799e19db90718b2cbe","modified":1495344960866},{"_id":"themes/next/README.en.md","hash":"953873fe2ee79bfc567b16dcdf8f91c1410444f8","modified":1495344960872},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1495344960862},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1495344960869},{"_id":"themes/next/_config.yml","hash":"844d85b2b0baab1530c39f989224d630b808aba9","modified":1497675576493},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1495344960874},{"_id":"themes/next/bower.json","hash":"936b9aed1934471bb74cdaacc3fb8031eb01fe23","modified":1495344960880},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1495344960883},{"_id":"themes/next/package.json","hash":"a5c189d4c4e946e936d3b5e29e2d81ddaf03ff96","modified":1495344961230},{"_id":"source/about/index.md","hash":"1bb65fea7cc689eedf427b083bea3c5ebffb122d","modified":1495504805900},{"_id":"source/categories/index.md","hash":"261d2b5caa8df96435da5a74577ab68ba28eb050","modified":1495504822060},{"_id":"source/_posts/Effective Java 用静态工厂代替构造器.md","hash":"328dbe20151219fa47cf3978afc5569edca5b694","modified":1499823762915},{"_id":"source/_posts/Effective Java 使用构建器Builder.md","hash":"2517208ba51be254e5cdc175a4cbec35af629f6f","modified":1499996086332},{"_id":"source/_posts/Java工具类——FreeMarker.md","hash":"8dda869dd8bb5acac089db75d2e06cb022e1f033","modified":1499824240658},{"_id":"source/_posts/Effective Java 用私有构造器或者枚举类型强化Singlton属性（单例类型）.md","hash":"dc10f290a761631aca82a296e7f9443b8daa2631","modified":1500256157803},{"_id":"source/_posts/Java线程池.md","hash":"9bc9d8ca6621bd90912c9ccb9ffd8f8e47297d9f","modified":1499824194615},{"_id":"source/_posts/RESTFul API.md","hash":"fea2a4c04a669dff7371714fad4974f9d9c3d810","modified":1499824170338},{"_id":"source/_posts/Java读书笔记——Spring实战（一）.md","hash":"ace69b6a868056de9d6546624c99e585757fde0c","modified":1499824273579},{"_id":"source/_posts/Spring实战（三） 自动装配Bean.md","hash":"f533e2f0f02533b6bad0584915cc5070ff30ce15","modified":1499824064849},{"_id":"source/_posts/Spring实战（三） 通过Java代码装配Bean.md","hash":"dd2bacaa51d2956136eec391de5f89034c449851","modified":1499824097357},{"_id":"source/_posts/Spring实战（二）上下文和Bean的生命周期.md","hash":"3638a268b3af337ddebff812f2986cdd6dbc8079","modified":1499824127033},{"_id":"source/_posts/java设计模式-策略模式.md","hash":"f7c28f5310c5619ddb1245a7563cdcc7b658e570","modified":1499824218202},{"_id":"source/_posts/编写属于自己的Service（服务）.md","hash":"e1df8c26b66de1155a1562d61004e97e3c21471c","modified":1499824035419},{"_id":"source/_posts/阻塞队列 PriorityBlockingQueue.md","hash":"a0e35e04d0351272babb3e7eb5b2a0676906cf1f","modified":1499823990394},{"_id":"source/_posts/阻塞队列DealayQueue.md","hash":"be49966662fcdeffc2474f0d35f985ff2392288f","modified":1499823950180},{"_id":"source/tags/index.md","hash":"41a4df49355dc639b66b48f34fb69fbfa9183ff6","modified":1495504834473},{"_id":"source/uploads/cat.ico","hash":"d1345c4e70db9faca7709b5ea4a6f8418d3cb143","modified":1495381385280},{"_id":"source/uploads/timg.jpg","hash":"9eb45adcab97f1fd81617b8c05ab78531fd2d379","modified":1495369288404},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1495344960827},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1495344930127},{"_id":"themes/next/.git/config","hash":"8e94cc015a498d35202e9fd57e44b3c51e1e5634","modified":1495344960836},{"_id":"themes/next/.git/index","hash":"c1f38504acea8e1c68f28e59f560e6ad72224f46","modified":1495344962295},{"_id":"themes/next/.git/packed-refs","hash":"5b997b1e07005896f9418ebc524143b6a66718fb","modified":1495344960821},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1495344960852},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"4de856de657a27f340f245eb491a1f52ceba1735","modified":1495344960854},{"_id":"themes/next/languages/de.yml","hash":"4be3e7d296d5592e0d111dfa6cbbff02602c972d","modified":1495344960885},{"_id":"themes/next/languages/default.yml","hash":"d912814caac150da1611c96843371a87714e52f9","modified":1495344960887},{"_id":"themes/next/languages/fr-FR.yml","hash":"0d5bd8bbbeafb72506124ed35e7509debc753612","modified":1495344960892},{"_id":"themes/next/languages/en.yml","hash":"b3ee45143bc014578db6b8ac0573f7c7b143a743","modified":1495344960890},{"_id":"themes/next/languages/id.yml","hash":"c0848e93bf33a1333ff232905b6b392b1e056dd1","modified":1495344960894},{"_id":"themes/next/languages/ja.yml","hash":"1a608dc799c0f9c36b626bac6fe3404acb45b86d","modified":1495344960898},{"_id":"themes/next/languages/ko.yml","hash":"5c811514aef401317a9ec38b95679d6d2ef0ad42","modified":1495344960900},{"_id":"themes/next/languages/pt-BR.yml","hash":"cc8b5a67ec87b0d5aec6e253bab67ec3cfe3069c","modified":1495344960903},{"_id":"themes/next/languages/pt.yml","hash":"943475a7d681f37ede579cd62da9c50568ca0f8d","modified":1495344960905},{"_id":"themes/next/languages/ru.yml","hash":"84d41a111e497236b2c1fa16e9b91668a1f37037","modified":1495344960907},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3111ce4cc5f30868b3628f9f805d2aef3b75d1c1","modified":1495344960909},{"_id":"themes/next/languages/zh-hk.yml","hash":"b58c0d85daa4d62b0c9753a59de0739aa0120735","modified":1495344960912},{"_id":"themes/next/languages/zh-tw.yml","hash":"8ce0a32411de111ae39d08e4bc936767dacdeb08","modified":1495344960914},{"_id":"themes/next/layout/_layout.swig","hash":"a26069dd106dab1d29b4466cf46544d735524bfe","modified":1495366916587},{"_id":"themes/next/layout/archive.swig","hash":"a1d1e91013baaaeb7deaf35c6d3975971ce38e02","modified":1495344961214},{"_id":"themes/next/layout/category.swig","hash":"f315f12651de8065fdad73b003da4335ef177173","modified":1495344961216},{"_id":"themes/next/layout/index.swig","hash":"4bf29f44ca9519a005671f2f2a79a48a148b435b","modified":1495344961218},{"_id":"themes/next/layout/page.swig","hash":"79297b9b9abd684ba025ba2d1551e9e0591b5a63","modified":1495344961220},{"_id":"themes/next/layout/post.swig","hash":"182a99b1f6db0350106c6bb480fede0bbdb7e40f","modified":1495344961222},{"_id":"themes/next/layout/schedule.swig","hash":"8086f1163b10460258ecbbbe48b057b22bb2f02e","modified":1495344961224},{"_id":"themes/next/layout/tag.swig","hash":"cc9878932580c890f8f3e569225e29bb37e25b49","modified":1495344961227},{"_id":"themes/next/scripts/merge-configs.js","hash":"3ce1be32bb77ee19da25e8dae7dc04e2afc46ca1","modified":1495344961235},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1495344961245},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1495344962274},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1495344962283},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1495344962292},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1495344961524},{"_id":"source/_posts/Spring实战（五）通过XML装配bean/a.png","hash":"5c5bd70b51f4c4823f05debc3567bade9e23227b","modified":1498440414916},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1495344930129},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1495344930132},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1495344930135},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1495344930137},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1495344930140},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1495344930143},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1495344930147},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1495344930151},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1495344930149},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1495344930156},{"_id":"themes/next/.git/logs/HEAD","hash":"c89c43cda8e572dc163ea704645b676eeefed026","modified":1495344960831},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1495344930158},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1495344960914},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1495344960914},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"506feb56e9b1091187d2014742f63a17758df933","modified":1495344960933},{"_id":"themes/next/layout/_macro/post.swig","hash":"3c6ef2ec749f2102ea5006016261263d34b6d162","modified":1495344960939},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1495344960931},{"_id":"themes/next/layout/_macro/reward.swig","hash":"b6cb171f0ed227b82b8f7601814af2df93f3a09a","modified":1495344960942},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"c5cc0070ca7c9a8dbd4b09e0398db536c3cdbe8a","modified":1495344960948},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"e7f58154ac734088372888742e0029ce7c690511","modified":1495344960946},{"_id":"themes/next/layout/_partials/footer.swig","hash":"683616f4a80796051e2346d80acf838a589450b0","modified":1495344960954},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5258c03149aa18e9abfeb8de10e435a406d9c924","modified":1495344960951},{"_id":"themes/next/layout/_partials/head.swig","hash":"881556e5387d760d7b67c49f4f3c3ccc2240436b","modified":1495344960959},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1495344960967},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1495344960970},{"_id":"themes/next/layout/_partials/header.swig","hash":"d6bf1d1554d91eaf1bfc40ba8905ae81673e5f45","modified":1495344960965},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1495344960972},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1495344961011},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1495344961013},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"53c894e6f3573c662dc4e4f7b5a6f1a32f1a8c94","modified":1495344961024},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1495344961152},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1495344961162},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1495344961154},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1495344961172},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1495344961175},{"_id":"themes/next/scripts/tags/button.js","hash":"aaf71be6b483fca7a65cd6296c2cf1c2271c26a6","modified":1495344961249},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1495344961254},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1495344961278},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1495344961262},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1495344961268},{"_id":"themes/next/scripts/tags/note.js","hash":"7dc14db08f2c74f8f1952534b424f220f5c000c6","modified":1495344961282},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1495344961527},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1495344961524},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1495344961531},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1495344961527},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1495344961534},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1495344961537},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1495344961541},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1495344961544},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1495344961546},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1495344961548},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1495344961549},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1495344961550},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1495344961552},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1495344961554},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1495344961555},{"_id":"source/_posts/Java线程池/c.jpg","hash":"6e0e31a2189113ae1c03581908d6df2d6a29cfa1","modified":1497674488204},{"_id":"source/_posts/Java线程池/b.jpg","hash":"0b7d3484f5520730dc4af2f797bafd0367cde9fc","modified":1497579014358},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1495344961016},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1495344961016},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1495344961444},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1495344961444},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1495344961451},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1495344961509},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1495344961519},{"_id":"source/_posts/Java线程池/a.jpg","hash":"8fd2968bbedec2a3a10f4f67ec0a4f9f6f1bafe4","modified":1497574247180},{"_id":"themes/next/.git/refs/heads/master","hash":"f6fbd6961a37e7fcf4a1afacee916a1080c7cadc","modified":1495344960830},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1495344960961},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1495344960963},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1495344960974},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1495344960979},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1495344960982},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1495344960985},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1495344961000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1495344961003},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1495344961016},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1495344961008},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1495344961019},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1495344961114},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1495344961122},{"_id":"themes/next/layout/_third-party/comments/gentie.swig","hash":"0f38f053841ef77cdce56a84cfbb4dd4c3329486","modified":1495344961133},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1495344961129},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1495344961140},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"0399bbdc524ba50930cb6f8e2d5628ff682fc612","modified":1495344961142},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"c75024151fc63220e7d01035d8a1aff9affdecc7","modified":1495344961147},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"de95ec8920d1660680078451008f8bd69f14d082","modified":1495344961150},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1495344961032},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1495344961045},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1495344961042},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1495344961060},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1495344961047},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"441f1a1b4e2f652d3b975995bd9d44ff4866f057","modified":1495344961062},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a79e7e0d809fcf407593dd7ed9e023db21c3cbd6","modified":1495344961053},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e495aed8fb36bf8015ddbd64366270a7debad2b0","modified":1495344961077},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1495344961087},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1495344961093},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1495344961100},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"a0c042a74ea1afcb19daac7e2604a2bc5495037b","modified":1495344961194},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1495344961182},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1495344961208},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1495344961201},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1495344961443},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"a0f23e75a137d8c996c70e2059e0074f1e97a127","modified":1495344961446},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"531934ea21ef4dc9f0978512050f54834f0a6cff","modified":1495344961450},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1495344961509},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"09534b68bd1a708729b3cfffe17737e3af457757","modified":1495344961513},{"_id":"themes/next/source/css/_variables/base.styl","hash":"dacede1cc110c762e7a5468dc0e34ae1a962d5aa","modified":1495344961519},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1495344961574},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0ec035e20d1f26bf553a79877180ba312bea885c","modified":1495344961579},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1495344961566},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1495344961587},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1495344961593},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1495344961602},{"_id":"themes/next/source/js/src/post-details.js","hash":"bfaf52b69aad96566aa21b785973441a2555b4ba","modified":1495380151480},{"_id":"themes/next/source/js/src/motion.js","hash":"2f95f4672243b5cbc0e6902f55813180481ffb53","modified":1495379790003},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1495344961644},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1495344961631},{"_id":"themes/next/source/js/src/utils.js","hash":"092a32149b67a7af271c6c2c45f4c737f64b7e54","modified":1495344961653},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1495344961713},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1495344961876},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"68db2c0bf1064176627199394f25f6dc37ea23ad","modified":1495344961882},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1495344961884},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1495344961887},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1495344961947},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1495344961949},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1495344961953},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1495344961955},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1495344961987},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1495344961990},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1495344961994},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1495344961992},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1495344961997},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1495344962040},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1495344962071},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1495344962076},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1495344962080},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1495344962082},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1495344962090},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1495344962100},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1495344962112},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1495344962124},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1495344962136},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1495344962222},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1495344962225},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1495344962255},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1495344962263},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1495344962272},{"_id":"source/_posts/Spring实战（二）上下文和Bean的生命周期/spring1.png","hash":"4909f843af6e4c5592dc0adf5e67b3b66c4a8a1b","modified":1496749595691},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1495344962068},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"c89c43cda8e572dc163ea704645b676eeefed026","modified":1495344960831},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1495344960826},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1495344961178},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1495344961180},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"1dc2ed435e41ca041f43bd9633d5d95139afbb42","modified":1495344961287},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1495344961290},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4ba6f2a615693b9b5afc266d9c833697016085fd","modified":1495344961285},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1495344961292},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1495344961294},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1495344961329},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1495344961384},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"4998bedff9c84a09a294b8ef36ede2e3644d3528","modified":1495344961428},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1495344961432},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1495344961435},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1495344961438},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1495344961440},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1495344961426},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1495344961454},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1495344961458},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1495344961463},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1495344961460},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"ce272226a1570f5f7c70243b751a5b0fe1671a88","modified":1495344961468},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1495344961471},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1495344961475},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1495344961483},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1495344961486},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"f23ac53ab901c48859dd29eee6e386b60ff956ba","modified":1495344961489},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1495344961489},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1495344961492},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1495355435325},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1495355463061},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1495344961498},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1495344961500},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"c48d4a561d047b3705924949b3ab7b57bee94ecd","modified":1495344961504},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1495344961506},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"c4358416f0a116d7f4037542fa3b385947e80908","modified":1495344961626},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"95518d298d3c5c271faec2e4977df9e5dedd5d84","modified":1495344961694},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1495344961710},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1495344961887},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1495344961887},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1495344961889},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1495344961890},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1495344961890},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1495344961891},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1495344961920},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1495344961931},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1495344961944},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1495344961964},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1495344961983},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1495344962002},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1495344962004},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1495344961999},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1495344962210},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1495344962219},{"_id":"themes/next/.git/objects/pack/pack-75ea3c12516825fd602e43e51ccb8c17ac4cd194.idx","hash":"7c47f686e9170afc3b30d288122732c8595b61a5","modified":1495344960790},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1495344961690},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"524cfca7b6ab135d81ea723d8de06fdf0dbe7e56","modified":1495344961668},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1495344962033},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1495344962037},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1495344962241},{"_id":"source/_posts/Spring实战（二）上下文和Bean的生命周期/spring2.png","hash":"e5907d73f3dcfece20704c4ba20be7a73663f73e","modified":1496750330810},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"c89c43cda8e572dc163ea704645b676eeefed026","modified":1495344960825},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1495344961297},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1495344961301},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1495344961299},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1495344961307},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1495344961305},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1495344961309},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1495344961311},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"b3b783511bbd94af7e941abf8ff411885db7395b","modified":1495344961313},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1495344961315},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"104b5c79cd891506e0beaf938b083685f1da8637","modified":1495344961317},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1495344961320},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1495344961323},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1495344961325},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1495344961327},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1495344961364},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1495344961366},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"ac060861b27b764bc4012fc362a25a332df4045a","modified":1495344961368},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1495344961370},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1495344961373},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"394888efec32749b353292a59ec7f1b609d6325e","modified":1495344961375},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43321b24b03b4c7f92255db9a35b96a2920f3695","modified":1495374296849},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"c9f76d4f6806ef70fa2160c97afa0a0e0ae5373e","modified":1495380460765},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1495344961382},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e1a7a0828e3c93cc044250084c1ae0c9a22a6d4c","modified":1495344961335},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"4783f85872bc7e218c1522a5c1c68cd27a5922db","modified":1495344961332},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1495344961337},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1495344961340},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"58f9e6aba94733244a87d2ba5966c5a009486509","modified":1495344961343},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1495344961345},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"3d3e0200716ceb276ac755cc400def9c1b437489","modified":1495344961347},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"8355b0e9375b3245508efda0e18acd069c2aa767","modified":1495344961352},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1495344961349},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1495344961354},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"350469437b20ecfd6f3ca45e400478f8e3f71cfb","modified":1495344961356},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1495344961359},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a497ea244df7dd97d1b961412b56f94cc4031e23","modified":1495344961361},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1495344961387},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"3159b55f35c40bd08e55b00148c523760a708c51","modified":1495344961395},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1495344961391},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1495344961397},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"8420b4be386469337243336aee694297875bd439","modified":1495344961400},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"e3ad37f2da35e330616a044621ffa50565a20c88","modified":1495344961402},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1495344961405},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1495344961409},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1495344961407},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"cd526e814f9323a79fe835085d64867d34b3715d","modified":1495344961413},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1495344961418},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1495344961411},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1495344961416},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1495344961420},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"eb45ee16051624c6e36a274c0a9538e961f10c4d","modified":1495344961422},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1495344961477},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1495344961479},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1495344961656},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1495344961492},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1495344961658},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1495344961661},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1495344961665},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1495344961892},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1495344961894},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1495344961907},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1495344961901},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1495344961910},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1495344961918},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1495344962008},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1495344962012},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1495344962029},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1495344961869},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1495344962200},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1495344962024},{"_id":"source/uploads/image.jpg","hash":"5c1699e2d6f3137f6683a19c9e37cffbc42b6de6","modified":1495346083976},{"_id":"themes/next/.git/objects/pack/pack-75ea3c12516825fd602e43e51ccb8c17ac4cd194.pack","hash":"2b52aadf80fe537e00dac968c3151b41d5156260","modified":1495344960795},{"_id":"public/atom.xml","hash":"4df47b6c35f33023b58d7ae274fe85f54d17a758","modified":1500256186987},{"_id":"public/sitemap.xml","hash":"29b31d49f8f5129668ef619b4f49ec57d92bf0f9","modified":1500256187019},{"_id":"public/about/index.html","hash":"3c6c64b223d8264da7a86d7e90c630c1b2a54225","modified":1500256187032},{"_id":"public/categories/index.html","hash":"5ed62e98033a81dced4d281d9a69420fa60015de","modified":1500256187032},{"_id":"public/tags/index.html","hash":"5721176c680c925e3ce9df6800b8af905f6f284a","modified":1500256187032},{"_id":"public/archives/page/2/index.html","hash":"5bbcd0c411faa47254e118e3641ba38dfa5862a7","modified":1500256187032},{"_id":"public/archives/2017/page/2/index.html","hash":"7fd67c0275e0193bbb31667492dacc6f74d1430a","modified":1500256187032},{"_id":"public/archives/2017/05/index.html","hash":"9d5367e063eb46cc66e14b4550d49688f39ee1e3","modified":1500256187032},{"_id":"public/archives/2017/07/index.html","hash":"7e98975c984a18e0620b8570124f4032dbaeb2ae","modified":1500256187032},{"_id":"public/categories/java工具/index.html","hash":"6e75442f43bb69266c5a92b8cb5b1e342cfc80b4","modified":1500256187032},{"_id":"public/categories/java多线程/index.html","hash":"4814c51f0195f5e708f4c882113cc7dde33b5ba7","modified":1500256187033},{"_id":"public/categories/其它/index.html","hash":"43a114167241c1ff2c2ea092162721ce18f21383","modified":1500256187033},{"_id":"public/categories/Linux/index.html","hash":"a7be2f3d00198e0ee88030cf529298628394bc50","modified":1500256187033},{"_id":"public/tags/Java/index.html","hash":"2b048c6927b47ea52c7fe39c3c4c93645155a9e4","modified":1500256187033},{"_id":"public/tags/经验之谈/index.html","hash":"a052de29f15ea05d6d7a79962d0d7d92c47dce12","modified":1500256187033},{"_id":"public/tags/高效开发/index.html","hash":"f8f4b79f43440c87660cf7c78412c0eb3d944d2f","modified":1500256187033},{"_id":"public/tags/Builder/index.html","hash":"7763b4e70bb4f104a9a3a6ac4d58e20ce76e8278","modified":1500256187033},{"_id":"public/tags/FreeMaker/index.html","hash":"a01c0d580bf9ebbb9a44de8c772551fb4692cf65","modified":1500256187033},{"_id":"public/tags/模板引擎/index.html","hash":"66ea0b3b30c68e8b1910e868208d1320500587b7","modified":1500256187033},{"_id":"public/tags/Singleton/index.html","hash":"1ac3c395093fbed39df86e9cd6312a82830fab3e","modified":1500256187033},{"_id":"public/tags/单例模式/index.html","hash":"db8496a5557a8a36a9ae3f86d72915e6e98fbcd9","modified":1500256187033},{"_id":"public/tags/多线程/index.html","hash":"5c722989174461a2ff480fcce45c8999c7c7ad64","modified":1500256187033},{"_id":"public/tags/Executor/index.html","hash":"b46bfadbbf5e643df7a4b11b046d9bdfed1e0b4a","modified":1500256187033},{"_id":"public/tags/TreadPoolExecutor/index.html","hash":"48949f0731920ad8cf5746b1917a4c92908f6660","modified":1500256187034},{"_id":"public/tags/ExecutorService/index.html","hash":"6b5d7d277d6dc39dc8a46082870a73234a729836","modified":1500256187034},{"_id":"public/tags/Rest/index.html","hash":"2340be0cc264c9098dace9bbcce2ec87026afc50","modified":1500256187034},{"_id":"public/tags/微服务/index.html","hash":"d82f119e0e21e7250337036d9521095364e12c6a","modified":1500256187034},{"_id":"public/tags/Spring/index.html","hash":"73628e4e77d82a1f28870cb1267f98d2f86bbfa2","modified":1500256187034},{"_id":"public/tags/依赖注入/index.html","hash":"0fa32a8f9db466450873deebd8129ace7e5e80d7","modified":1500256187034},{"_id":"public/tags/面向切面编程/index.html","hash":"d7309c5f2a7c938fb082b48a76206817a407f0ba","modified":1500256187034},{"_id":"public/tags/IoC/index.html","hash":"60f404b32ae764086ac302ede20ec6734df91bcc","modified":1500256187034},{"_id":"public/tags/AOP/index.html","hash":"71f4db0729b61b8484398e863fc9f9e819624081","modified":1500256187034},{"_id":"public/tags/Bean/index.html","hash":"465b2c2b33d3dc96026b34eb6aa0e07b1eee9025","modified":1500256187034},{"_id":"public/tags/Java装配/index.html","hash":"3c0a52d47c74318f9bb91cc84002cbc973952c03","modified":1500256187034},{"_id":"public/tags/Context/index.html","hash":"d1f73b5d07b0c1fc5d6bf635442854b4928ed37c","modified":1500256187034},{"_id":"public/tags/Spring模块/index.html","hash":"5750019dda80de843c56b075314dd4c327a08f1c","modified":1500256187034},{"_id":"public/tags/SpringBoot/index.html","hash":"d728e577266d9c84131180e495402069c11b9efd","modified":1500256187034},{"_id":"public/tags/自动装配/index.html","hash":"b27f001cee4a32cf393b7f621ce8a8113dab47b6","modified":1500256187034},{"_id":"public/tags/设计模式/index.html","hash":"ba099c786c148739cfb797892e499462c1f7f6e9","modified":1500256187034},{"_id":"public/tags/策略模式/index.html","hash":"e24f30ac6904f72b1e7a1c7c86fbed01c14e4382","modified":1500256187035},{"_id":"public/tags/Linux/index.html","hash":"f36465ce8e9d4809d557a5e2a3f7cd60dc3d7ebe","modified":1500256187035},{"_id":"public/tags/Service/index.html","hash":"6c1a5787f1b2f0215b5ad4c5e9feb8d2af54610c","modified":1500256187035},{"_id":"public/tags/后台服务/index.html","hash":"76e46738cfc2042328857b775e1c8d45f945be8d","modified":1500256187035},{"_id":"public/tags/阻塞队列/index.html","hash":"3aec2178694115e545c62c7b0f4c5be1859c5c9b","modified":1500256187035},{"_id":"public/tags/Chkconfig/index.html","hash":"764c95927649e5c9b9172088c8b85bb2391e4cbf","modified":1500256187035},{"_id":"public/tags/DelayQUeue/index.html","hash":"63c06cd398579d8373f64111a11b6e4c5778b9c9","modified":1500256187035},{"_id":"public/tags/PriorityBlockingQueue/index.html","hash":"67680dc4b17e4deb6c80d7f991332332446c5d22","modified":1500256187035},{"_id":"public/2017/07/17/Effective Java 用私有构造器或者枚举类型强化Singlton属性（单例类型）/index.html","hash":"18404c7eca7c4cabab99845430fe9954aa2e95e9","modified":1500256187035},{"_id":"public/2017/07/14/Effective Java 使用构建器Builder/index.html","hash":"454d086fa7a03d3449b96587085c46cf1f76af77","modified":1500256187035},{"_id":"public/2017/07/12/Effective Java 用静态工厂代替构造器/index.html","hash":"7312d39e73bfc849bb33f4179dcdd8a46e684468","modified":1500256187035},{"_id":"public/2017/06/23/RESTFul API/index.html","hash":"261c0a2c0843de7ea44d80f41e0e904e6061af4b","modified":1500256187035},{"_id":"public/2017/06/16/Java线程池/index.html","hash":"8d4e6d0d9f330f41492528a7a6a8655f025d2f09","modified":1500256187035},{"_id":"public/2017/06/14/阻塞队列 PriorityBlockingQueue/index.html","hash":"eb6adf2616104e7261483325df97a5959cd0dc62","modified":1500256187035},{"_id":"public/2017/06/13/阻塞队列DealayQueue/index.html","hash":"e7edb07c98bdb196c7e43edc252e5f0bf8323d93","modified":1500256187035},{"_id":"public/2017/06/09/Spring实战（三） 通过Java代码装配Bean/index.html","hash":"1dd6c4d15c4d03b157daec22ee1b15e87fa1f677","modified":1500256187036},{"_id":"public/2017/06/09/Spring实战（三） 自动装配Bean/index.html","hash":"76f41c1a9714b58830a88f056541773043784d31","modified":1500256187036},{"_id":"public/2017/06/06/Spring实战（二）上下文和Bean的生命周期/index.html","hash":"2a06e773cfebb8e96a0231d74b68d83d617ea6a4","modified":1500256187036},{"_id":"public/2017/06/02/Java读书笔记——Spring实战（一）/index.html","hash":"5ba04cc5145e875f40828df64e62c3a46135294a","modified":1500256187036},{"_id":"public/2017/05/31/编写属于自己的Service（服务）/index.html","hash":"069f7ddc24e827d06abe04236d7349ab270f65f7","modified":1500256187036},{"_id":"public/2017/05/26/Java工具类——FreeMarker/index.html","hash":"68d741c9033662b24943a12a4b4e20c0847e4ec0","modified":1500256187037},{"_id":"public/2017/05/23/java设计模式-策略模式/index.html","hash":"e12911736dccfeb49b77972bd62c110972a99b70","modified":1500256187037},{"_id":"public/archives/index.html","hash":"8714a826e579fd6c6aea9eda20410fd51d65ab61","modified":1500256187037},{"_id":"public/archives/2017/index.html","hash":"1a1716f573f9e51ccbb142cd39ddacb9e5b44731","modified":1500256187037},{"_id":"public/archives/2017/06/index.html","hash":"acbcc515e874b1541032d566501a5abf11af5b75","modified":1500256187037},{"_id":"public/categories/java读书笔记/index.html","hash":"f91b083e49d662dabb33d53b7bc3c6f7bb486efd","modified":1500256187037},{"_id":"public/index.html","hash":"81241689c51b0949fb3d274bf1a42d26738e321b","modified":1500256187037},{"_id":"public/page/2/index.html","hash":"6d75dacb42b9af5bd416715e5066602d2e946bfd","modified":1500256187037},{"_id":"public/tags/java/index.html","hash":"2e3ae7d1a3e9136572200a50423af55d63f07294","modified":1500256187037},{"_id":"public/CNAME","hash":"e3f65fd86dd8161b249a5cc7e2a50fe60a52d178","modified":1500256187066},{"_id":"public/uploads/cat.ico","hash":"d1345c4e70db9faca7709b5ea4a6f8418d3cb143","modified":1500256187066},{"_id":"public/images/algolia_logo.svg","hash":"16505f61f19ba65f629dfd033f14ee9abcf18756","modified":1500256187066},{"_id":"public/uploads/timg.jpg","hash":"9eb45adcab97f1fd81617b8c05ab78531fd2d379","modified":1500256187066},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1500256187066},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1500256187066},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1500256187066},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1500256187066},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1500256187067},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1500256187067},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1500256187067},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1500256187067},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1500256187067},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1500256187067},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1500256187067},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1500256187067},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1500256187067},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1500256187067},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1500256187067},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1500256187067},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1500256187067},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1500256187067},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1500256187067},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1500256187067},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1500256187067},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1500256187067},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1500256187067},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1500256187067},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1500256187067},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1500256187067},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1500256187068},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1500256187635},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1500256187641},{"_id":"public/2017/06/16/Java线程池/c.jpg","hash":"6e0e31a2189113ae1c03581908d6df2d6a29cfa1","modified":1500256187645},{"_id":"public/2017/06/16/Java线程池/b.jpg","hash":"0b7d3484f5520730dc4af2f797bafd0367cde9fc","modified":1500256187645},{"_id":"public/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1500256187662},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1500256187662},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1500256187662},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1500256187662},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1500256187662},{"_id":"public/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1500256187662},{"_id":"public/js/src/motion.js","hash":"b6daaede491ef1932648f805e28e9a9df179cb49","modified":1500256187662},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1500256187662},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1500256187662},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1500256187662},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1500256187662},{"_id":"public/js/src/utils.js","hash":"803f684fa7d0e729115a48851023a31f6fb6d0a7","modified":1500256187663},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1500256187663},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1500256187663},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1500256187663},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"3587602ad777b031628bb5944864d1a4fcfea4ac","modified":1500256187663},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1500256187663},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1500256187663},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1500256187663},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1500256187663},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1500256187663},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1500256187663},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1500256187664},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1500256187664},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1500256187664},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1500256187664},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1500256187664},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1500256187664},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1500256187664},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1500256187664},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1500256187665},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1500256187665},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1500256187665},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1500256187666},{"_id":"public/css/main.css","hash":"666cd4ef2487c3b1bfbe7a42bb0a24a1728a32ee","modified":1500256187666},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1500256187666},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1500256187666},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1500256187666},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1500256187666},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1500256187666},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1500256187666},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1500256187666},{"_id":"public/lib/Han/dist/han.min.css","hash":"d9c0b3dc9158e717fde36f554709e6c3a22b5f85","modified":1500256187666},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1500256187666},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1500256187666},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1500256187666},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1500256187666},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1500256187666},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1500256187666},{"_id":"public/lib/Han/dist/han.css","hash":"38e48f275ad00daa9dcdcb8d9b44e576acda4707","modified":1500256187667},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1500256187667},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1500256187667},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1500256187667},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1500256187667},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1500256187667},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1500256187667},{"_id":"public/2017/06/16/Java线程池/a.jpg","hash":"8fd2968bbedec2a3a10f4f67ec0a4f9f6f1bafe4","modified":1500256187667},{"_id":"public/2017/06/06/Spring实战（二）上下文和Bean的生命周期/spring1.png","hash":"4909f843af6e4c5592dc0adf5e67b3b66c4a8a1b","modified":1500256187674},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1500256187762},{"_id":"public/2017/06/06/Spring实战（二）上下文和Bean的生命周期/spring2.png","hash":"e5907d73f3dcfece20704c4ba20be7a73663f73e","modified":1500256187762},{"_id":"public/uploads/image.jpg","hash":"5c1699e2d6f3137f6683a19c9e37cffbc42b6de6","modified":1500256188443}],"Category":[{"name":"java读书笔记","_id":"cj57hsnzp0004asvl1knsm9q5"},{"name":"java工具","_id":"cj57hso06000fasvl6cft5ai3"},{"name":"java多线程","_id":"cj57hso0d000lasvla4vji5zi"},{"name":"其它","_id":"cj57hso0h000tasvl7gua4qqb"},{"name":"Linux","_id":"cj57hso0j0011asvl2xngqm1t"}],"Data":[],"Page":[{"title":"about","date":"2017-05-21T12:48:23.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-05-21 20:48:23\n---\n","updated":"2017-05-23T02:00:05.900Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj57hsnze0000asvlc38kz7sx","content":"","site":{"data":{}},"excerpt":"","more":""},{"date":"2017-05-21T10:57:22.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ndate: 2017-05-21 18:57:22\ntype: \"categories\"\n---\n","updated":"2017-05-23T02:00:22.060Z","path":"categories/index.html","title":"","comments":1,"layout":"page","_id":"cj57hsnzl0002asvlcou95jry","content":"","site":{"data":{}},"excerpt":"","more":""},{"date":"2017-05-21T10:57:00.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ndate: 2017-05-21 18:57:00\ntype: \"tags\"\n---\n","updated":"2017-05-23T02:00:34.473Z","path":"tags/index.html","title":"","comments":1,"layout":"page","_id":"cj57hsnzs0006asvlqr47mql9","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">Effective Java 用静态工厂代替构造器</font>","date":"2017-07-12T00:43:37.000Z","_content":"\n对于一个类，要获得它的一个实例，一般而言是提供一个共有的构造器。但是可以考虑用一个静态工厂来代替构造器。要注意的是，这里的静态工厂与设计模式中的工厂方法不同。\n\n来看一看服务提供者框架：\n服务提供者框架是指这样一个系统：多个服务提供者实现了某个服务，系统为用户提供多个实现，并把它们从多个实现中解耦出来。\n\n服务提供者框架中有三个重要的组件：服务接口(Service Interface), 这是由提供者定义和实现的。提供者注册API(Provider Registration API)，这是系统用来注册提供者的，因为具体的服务由提供者实现，所以实际上只有注册提供者之后才会有具体的服务。服务访问API(Service Access API)，是用户用来获取服务实例的。还有一个可选的组件：服务提供者接口(Service Provider Interface)\n这些提供者负责创建其服务实现的实例。如果没有服务提供者接口，实现就按照类名称注册，并通过反射方式进行实例化。\n\n举一个实例：\n服务接口(Service Interface)：\n\n```java\n/**\n* Service Interface\n*/\npublic interface Service {\n\t// Service-specific methods go here\n}\n```\n服务提供者接口(Service Provider Interface):\n\n```java\n/**\n* Service Provider Interface\n*/\npublic interface Provider {\n\tService newService();\n}\n```\n\n```java\n/**\n* Noninstantiable class for service registration and access\n*/\npublic class Services {\n\tprivate Services() {\n\t} // Prevents instantiation (Item 4)\n\n\t// Maps service names to services\n\tprivate static final Map<String, Provider> providers = new ConcurrentHashMap<String, Provider>();\n\tpublic static final String DEFAULT_PROVIDER_NAME = \"<def>\";\n\n\t// Provider registration API\n\tpublic static void registerDefaultProvider(Provider p) {\n\t\tregisterProvider(DEFAULT_PROVIDER_NAME, p);\n\t}\n\n\tpublic static void registerProvider(String name, Provider p) {\n\t\tproviders.put(name, p);\n\t}\n\n\t// Service access API\n\tpublic static Service newInstance() {\n\t\treturn newInstance(DEFAULT_PROVIDER_NAME);\n\t}\n\n\tpublic static Service newInstance(String name) {\n\t\tProvider p = providers.get(name);\n\t\tif (p == null)\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"No provider registered with name: \" + name);\n\t\treturn p.newService();\n\t}\n}\n\n```\n这个类中包含提供者注册API和服务访问API。\n\n最后是一个测试用例：\n\n```java\npublic class Test {\n    //定义提供者，每一个提供者实现了一钟服务\n\tprivate static Provider DEFAULT_PROVIDER = new Provider() {\n\t\tpublic Service newService() {\n\t\t\treturn new Service() {\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Default service\";\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\n\tprivate static Provider COMP_PROVIDER = new Provider() {\n\t\tpublic Service newService() {\n\t\t\treturn new Service() {\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Complementary service\";\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\n\tprivate static Provider ARMED_PROVIDER = new Provider() {\n\t\tpublic Service newService() {\n\t\t\treturn new Service() {\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Armed service\";\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\t\n\tpublic static void main(String[] args) {\n\t\t// Providers would execute these lines\n\t\t//调用提供者注册API来注册提供者，注册完成之后，对应的提供者就会创建对应的服务\n\t\tServices.registerDefaultProvider(DEFAULT_PROVIDER);\n\t\tServices.registerProvider(\"comp\", COMP_PROVIDER);\n\t\tServices.registerProvider(\"armed\", ARMED_PROVIDER);\n\n\t\t// Clients would execute these lines\n\t\t//调用服务访问API来获得服务的实例\n\t\tService s1 = Services.newInstance();\n\t\tService s2 = Services.newInstance(\"comp\");\n\t\tService s3 = Services.newInstance(\"armed\");\n\t\tSystem.out.printf(\"%s, %s, %s%n\", s1, s2, s3);\n\t}\n}\n```\n\n理解：在测试用例中先定义一些提供者，之前说过服务是由提供者自己实现的，所以在定义这些提供者的时候要实现具体的服务。\n在main函数中去真正使用服务的时候，首先要调用提供者注册API去对定义的提供者进行注册。注册完成之后才会有具体的服务。这个时候就可以通过服务访问API拿到某个提供者提供的具体服务了。\n\n上面示例的运行结果：\n\n```java\nDefault service, Complementary service, Armed service\n\nProcess finished with exit code 0\n```\n\n\n\n\n\n","source":"_posts/Effective Java 用静态工厂代替构造器.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">Effective Java 用静态工厂代替构造器</font>\ndate: 2017-07-12 08:43:37\ncategories: java读书笔记\ntags: [Java,经验之谈,高效开发]\n---\n\n对于一个类，要获得它的一个实例，一般而言是提供一个共有的构造器。但是可以考虑用一个静态工厂来代替构造器。要注意的是，这里的静态工厂与设计模式中的工厂方法不同。\n\n来看一看服务提供者框架：\n服务提供者框架是指这样一个系统：多个服务提供者实现了某个服务，系统为用户提供多个实现，并把它们从多个实现中解耦出来。\n\n服务提供者框架中有三个重要的组件：服务接口(Service Interface), 这是由提供者定义和实现的。提供者注册API(Provider Registration API)，这是系统用来注册提供者的，因为具体的服务由提供者实现，所以实际上只有注册提供者之后才会有具体的服务。服务访问API(Service Access API)，是用户用来获取服务实例的。还有一个可选的组件：服务提供者接口(Service Provider Interface)\n这些提供者负责创建其服务实现的实例。如果没有服务提供者接口，实现就按照类名称注册，并通过反射方式进行实例化。\n\n举一个实例：\n服务接口(Service Interface)：\n\n```java\n/**\n* Service Interface\n*/\npublic interface Service {\n\t// Service-specific methods go here\n}\n```\n服务提供者接口(Service Provider Interface):\n\n```java\n/**\n* Service Provider Interface\n*/\npublic interface Provider {\n\tService newService();\n}\n```\n\n```java\n/**\n* Noninstantiable class for service registration and access\n*/\npublic class Services {\n\tprivate Services() {\n\t} // Prevents instantiation (Item 4)\n\n\t// Maps service names to services\n\tprivate static final Map<String, Provider> providers = new ConcurrentHashMap<String, Provider>();\n\tpublic static final String DEFAULT_PROVIDER_NAME = \"<def>\";\n\n\t// Provider registration API\n\tpublic static void registerDefaultProvider(Provider p) {\n\t\tregisterProvider(DEFAULT_PROVIDER_NAME, p);\n\t}\n\n\tpublic static void registerProvider(String name, Provider p) {\n\t\tproviders.put(name, p);\n\t}\n\n\t// Service access API\n\tpublic static Service newInstance() {\n\t\treturn newInstance(DEFAULT_PROVIDER_NAME);\n\t}\n\n\tpublic static Service newInstance(String name) {\n\t\tProvider p = providers.get(name);\n\t\tif (p == null)\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"No provider registered with name: \" + name);\n\t\treturn p.newService();\n\t}\n}\n\n```\n这个类中包含提供者注册API和服务访问API。\n\n最后是一个测试用例：\n\n```java\npublic class Test {\n    //定义提供者，每一个提供者实现了一钟服务\n\tprivate static Provider DEFAULT_PROVIDER = new Provider() {\n\t\tpublic Service newService() {\n\t\t\treturn new Service() {\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Default service\";\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\n\tprivate static Provider COMP_PROVIDER = new Provider() {\n\t\tpublic Service newService() {\n\t\t\treturn new Service() {\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Complementary service\";\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\n\tprivate static Provider ARMED_PROVIDER = new Provider() {\n\t\tpublic Service newService() {\n\t\t\treturn new Service() {\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Armed service\";\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\t\n\tpublic static void main(String[] args) {\n\t\t// Providers would execute these lines\n\t\t//调用提供者注册API来注册提供者，注册完成之后，对应的提供者就会创建对应的服务\n\t\tServices.registerDefaultProvider(DEFAULT_PROVIDER);\n\t\tServices.registerProvider(\"comp\", COMP_PROVIDER);\n\t\tServices.registerProvider(\"armed\", ARMED_PROVIDER);\n\n\t\t// Clients would execute these lines\n\t\t//调用服务访问API来获得服务的实例\n\t\tService s1 = Services.newInstance();\n\t\tService s2 = Services.newInstance(\"comp\");\n\t\tService s3 = Services.newInstance(\"armed\");\n\t\tSystem.out.printf(\"%s, %s, %s%n\", s1, s2, s3);\n\t}\n}\n```\n\n理解：在测试用例中先定义一些提供者，之前说过服务是由提供者自己实现的，所以在定义这些提供者的时候要实现具体的服务。\n在main函数中去真正使用服务的时候，首先要调用提供者注册API去对定义的提供者进行注册。注册完成之后才会有具体的服务。这个时候就可以通过服务访问API拿到某个提供者提供的具体服务了。\n\n上面示例的运行结果：\n\n```java\nDefault service, Complementary service, Armed service\n\nProcess finished with exit code 0\n```\n\n\n\n\n\n","slug":"Effective Java 用静态工厂代替构造器","published":1,"updated":"2017-07-12T01:42:42.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hsnzh0001asvlgfgf62zp","content":"<p>对于一个类，要获得它的一个实例，一般而言是提供一个共有的构造器。但是可以考虑用一个静态工厂来代替构造器。要注意的是，这里的静态工厂与设计模式中的工厂方法不同。</p>\n<p>来看一看服务提供者框架：<br>服务提供者框架是指这样一个系统：多个服务提供者实现了某个服务，系统为用户提供多个实现，并把它们从多个实现中解耦出来。</p>\n<p>服务提供者框架中有三个重要的组件：服务接口(Service Interface), 这是由提供者定义和实现的。提供者注册API(Provider Registration API)，这是系统用来注册提供者的，因为具体的服务由提供者实现，所以实际上只有注册提供者之后才会有具体的服务。服务访问API(Service Access API)，是用户用来获取服务实例的。还有一个可选的组件：服务提供者接口(Service Provider Interface)<br>这些提供者负责创建其服务实现的实例。如果没有服务提供者接口，实现就按照类名称注册，并通过反射方式进行实例化。</p>\n<p>举一个实例：<br>服务接口(Service Interface)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* Service Interface</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Service</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// Service-specific methods go here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>服务提供者接口(Service Provider Interface):</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* Service Provider Interface</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Provider</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\">Service <span class=\"title\">newService</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* Noninstantiable class for service registration and access</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Services</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Services</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t&#125; <span class=\"comment\">// Prevents instantiation (Item 4)</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// Maps service names to services</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, Provider&gt; providers = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, Provider&gt;();</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_PROVIDER_NAME = <span class=\"string\">\"&lt;def&gt;\"</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// Provider registration API</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">registerDefaultProvider</span><span class=\"params\">(Provider p)</span> </span>&#123;</div><div class=\"line\">\t\tregisterProvider(DEFAULT_PROVIDER_NAME, p);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">registerProvider</span><span class=\"params\">(String name, Provider p)</span> </span>&#123;</div><div class=\"line\">\t\tproviders.put(name, p);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// Service access API</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Service <span class=\"title\">newInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> newInstance(DEFAULT_PROVIDER_NAME);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Service <span class=\"title\">newInstance</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">\t\tProvider p = providers.get(name);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>)</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">\"No provider registered with name: \"</span> + name);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> p.newService();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个类中包含提供者注册API和服务访问API。</p>\n<p>最后是一个测试用例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//定义提供者，每一个提供者实现了一钟服务</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Provider DEFAULT_PROVIDER = <span class=\"keyword\">new</span> Provider() &#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Service <span class=\"title\">newService</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Service() &#123;</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Default service\"</span>;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Provider COMP_PROVIDER = <span class=\"keyword\">new</span> Provider() &#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Service <span class=\"title\">newService</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Service() &#123;</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Complementary service\"</span>;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Provider ARMED_PROVIDER = <span class=\"keyword\">new</span> Provider() &#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Service <span class=\"title\">newService</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Service() &#123;</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Armed service\"</span>;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// Providers would execute these lines</span></div><div class=\"line\">\t\t<span class=\"comment\">//调用提供者注册API来注册提供者，注册完成之后，对应的提供者就会创建对应的服务</span></div><div class=\"line\">\t\tServices.registerDefaultProvider(DEFAULT_PROVIDER);</div><div class=\"line\">\t\tServices.registerProvider(<span class=\"string\">\"comp\"</span>, COMP_PROVIDER);</div><div class=\"line\">\t\tServices.registerProvider(<span class=\"string\">\"armed\"</span>, ARMED_PROVIDER);</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// Clients would execute these lines</span></div><div class=\"line\">\t\t<span class=\"comment\">//调用服务访问API来获得服务的实例</span></div><div class=\"line\">\t\tService s1 = Services.newInstance();</div><div class=\"line\">\t\tService s2 = Services.newInstance(<span class=\"string\">\"comp\"</span>);</div><div class=\"line\">\t\tService s3 = Services.newInstance(<span class=\"string\">\"armed\"</span>);</div><div class=\"line\">\t\tSystem.out.printf(<span class=\"string\">\"%s, %s, %s%n\"</span>, s1, s2, s3);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>理解：在测试用例中先定义一些提供者，之前说过服务是由提供者自己实现的，所以在定义这些提供者的时候要实现具体的服务。<br>在main函数中去真正使用服务的时候，首先要调用提供者注册API去对定义的提供者进行注册。注册完成之后才会有具体的服务。这个时候就可以通过服务访问API拿到某个提供者提供的具体服务了。</p>\n<p>上面示例的运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Default service, Complementary service, Armed service</div><div class=\"line\"></div><div class=\"line\">Process finished with exit code <span class=\"number\">0</span></div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>对于一个类，要获得它的一个实例，一般而言是提供一个共有的构造器。但是可以考虑用一个静态工厂来代替构造器。要注意的是，这里的静态工厂与设计模式中的工厂方法不同。</p>\n<p>来看一看服务提供者框架：<br>服务提供者框架是指这样一个系统：多个服务提供者实现了某个服务，系统为用户提供多个实现，并把它们从多个实现中解耦出来。</p>\n<p>服务提供者框架中有三个重要的组件：服务接口(Service Interface), 这是由提供者定义和实现的。提供者注册API(Provider Registration API)，这是系统用来注册提供者的，因为具体的服务由提供者实现，所以实际上只有注册提供者之后才会有具体的服务。服务访问API(Service Access API)，是用户用来获取服务实例的。还有一个可选的组件：服务提供者接口(Service Provider Interface)<br>这些提供者负责创建其服务实现的实例。如果没有服务提供者接口，实现就按照类名称注册，并通过反射方式进行实例化。</p>\n<p>举一个实例：<br>服务接口(Service Interface)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* Service Interface</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Service</span> </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// Service-specific methods go here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>服务提供者接口(Service Provider Interface):</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* Service Provider Interface</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Provider</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\">Service <span class=\"title\">newService</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* Noninstantiable class for service registration and access</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Services</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Services</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t&#125; <span class=\"comment\">// Prevents instantiation (Item 4)</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// Maps service names to services</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;String, Provider&gt; providers = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, Provider&gt;();</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_PROVIDER_NAME = <span class=\"string\">\"&lt;def&gt;\"</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// Provider registration API</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">registerDefaultProvider</span><span class=\"params\">(Provider p)</span> </span>&#123;</div><div class=\"line\">\t\tregisterProvider(DEFAULT_PROVIDER_NAME, p);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">registerProvider</span><span class=\"params\">(String name, Provider p)</span> </span>&#123;</div><div class=\"line\">\t\tproviders.put(name, p);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// Service access API</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Service <span class=\"title\">newInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> newInstance(DEFAULT_PROVIDER_NAME);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Service <span class=\"title\">newInstance</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">\t\tProvider p = providers.get(name);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>)</div><div class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(</div><div class=\"line\">\t\t\t\t\t<span class=\"string\">\"No provider registered with name: \"</span> + name);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> p.newService();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个类中包含提供者注册API和服务访问API。</p>\n<p>最后是一个测试用例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//定义提供者，每一个提供者实现了一钟服务</span></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Provider DEFAULT_PROVIDER = <span class=\"keyword\">new</span> Provider() &#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Service <span class=\"title\">newService</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Service() &#123;</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Default service\"</span>;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Provider COMP_PROVIDER = <span class=\"keyword\">new</span> Provider() &#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Service <span class=\"title\">newService</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Service() &#123;</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Complementary service\"</span>;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Provider ARMED_PROVIDER = <span class=\"keyword\">new</span> Provider() &#123;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Service <span class=\"title\">newService</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Service() &#123;</div><div class=\"line\">\t\t\t\t<span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Armed service\"</span>;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// Providers would execute these lines</span></div><div class=\"line\">\t\t<span class=\"comment\">//调用提供者注册API来注册提供者，注册完成之后，对应的提供者就会创建对应的服务</span></div><div class=\"line\">\t\tServices.registerDefaultProvider(DEFAULT_PROVIDER);</div><div class=\"line\">\t\tServices.registerProvider(<span class=\"string\">\"comp\"</span>, COMP_PROVIDER);</div><div class=\"line\">\t\tServices.registerProvider(<span class=\"string\">\"armed\"</span>, ARMED_PROVIDER);</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// Clients would execute these lines</span></div><div class=\"line\">\t\t<span class=\"comment\">//调用服务访问API来获得服务的实例</span></div><div class=\"line\">\t\tService s1 = Services.newInstance();</div><div class=\"line\">\t\tService s2 = Services.newInstance(<span class=\"string\">\"comp\"</span>);</div><div class=\"line\">\t\tService s3 = Services.newInstance(<span class=\"string\">\"armed\"</span>);</div><div class=\"line\">\t\tSystem.out.printf(<span class=\"string\">\"%s, %s, %s%n\"</span>, s1, s2, s3);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>理解：在测试用例中先定义一些提供者，之前说过服务是由提供者自己实现的，所以在定义这些提供者的时候要实现具体的服务。<br>在main函数中去真正使用服务的时候，首先要调用提供者注册API去对定义的提供者进行注册。注册完成之后才会有具体的服务。这个时候就可以通过服务访问API拿到某个提供者提供的具体服务了。</p>\n<p>上面示例的运行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Default service, Complementary service, Armed service</div><div class=\"line\"></div><div class=\"line\">Process finished with exit code <span class=\"number\">0</span></div></pre></td></tr></table></figure>\n"},{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">Effective Java 使用构建器Builder</font>","date":"2017-07-14T00:43:37.000Z","_content":"\n如果一个类有大量**可选的参数**，如果这个时候使用构造器就需要写大量有不同参数个数的构造器。举个例子，用一个类来表示包装食品外面显示的营养成分标签。这些标签中有一些是必须的，比如每份的含量，每罐的含量以及每份的卡路里。还有超过20多个可选的参数，比如总脂肪量、饱和脂肪量、转化脂肪、胆固醇、钠等等。大多数的产品在某几个可选参数中都会有非零的值。\n\n对于这样的类，传统方法是采用重叠构造器模式，在这种模式下，第一个构造器由所有必要参数来构造，第二个构造器多加一个可选参数，第三个多加两个可选参数，直到最后一个构造器包含所有可选参数。如下所示，为了简便，只显示四个可选域：\n\n```java\n/**\n* Telescoping constructor pattern - does not scale well\n*/\n\npublic class NutritionFacts {\n    private final int servingSize;         //(ml)                required\n    private final int servings;            //(per container)     required\n    private final int calories;            //                    optional\n    private final int fat;                 //(g)                 optional\n    private final int sodium;              //(mg)                optional\n    private final int carbohydrate;        //(g)                 optional\n    \n    public NutritionFacts(int servingSize, int servings) {\n        this(servingSize, servings, 0);\n    }\n    \n    public NutritionFacts(int servingSize, int servings, int calories) {\n        this(servingSize, servings, calories, 0);\n    }\n    \n    public NutritionFacts(int servingSize, int servings, int calories, int fat) {\n        this(servingSize, servings, calories, fat, 0);\n    }\n    \n    public NutritionFacts(int servingSize, int servings, int calories,\n            int fat, int sodium) {\n        this(servingSize, servings, calories, fat, sodium, 0);\n    }\n    \n    public NutritionFacts(int servingSize, int servings int calories,\n            int fat, int sodium, int carbohydrate) {\n        this.servingSize = servingSize;\n        this.servings = servings;\n        this.calories = calories;\n        this.fat = fat;\n        this.sodium = sodium;\n        this.carbohydrate = carbohydrate;\n    }\n}\n```\n如果参数非常多，就要写大量的构造器。在使用的时候一不小心颠倒了了其中两个参数的顺序，并不能被及时的发现，但是程序运行的时候则不是正确的结果。这个时候就可以使用Builder模式了。不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器，得到一个builder对象。然后客户端在builder对象上调用类似于setter的方法，来设置每个相关的可选参数。最后，客户端调用无参的build方法来生成不可变的对象。这个builder是它构建的类的静态成员类。如下：\n\n```java\npublic class NutritionFacts {\n\tprivate final int servingSize;\n\tprivate final int servings;\n\tprivate final int calories;\n\tprivate final int fat;\n\tprivate final int sodium;\n\tprivate final int carbohydrate;\n\n\tpublic static class Builder {\n\t\t// Required parameters\n\t\tprivate final int servingSize;\n\t\tprivate final int servings;\n\n\t\t// Optional parameters - initialized to default values\n\t\tprivate int calories = 0;\n\t\tprivate int fat = 0;\n\t\tprivate int carbohydrate = 0;\n\t\tprivate int sodium = 0;\n\n\t\tpublic Builder(int servingSize, int servings) {\n\t\t\tthis.servingSize = servingSize;\n\t\t\tthis.servings = servings;\n\t\t}\n\n\t\tpublic Builder calories(int val) {\n\t\t\tcalories = val;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder fat(int val) {\n\t\t\tfat = val;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder carbohydrate(int val) {\n\t\t\tcarbohydrate = val;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder sodium(int val) {\n\t\t\tsodium = val;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic NutritionFacts build() {\n\t\t\treturn new NutritionFacts(this);\n\t\t}\n\t\t\n\t\tprivate NutritionFacts(Builder builder) {\n    \t\tservingSize = builder.servingSize;\n    \t\tservings = builder.servings;\n    \t\tcalories = builder.calories;\n    \t\tfat = builder.fat;\n    \t\tsodium = builder.sodium;\n    \t\tcarbohydrate = builder.carbohydrate;\n\t    }\n\t}\n```\n注意NutritionFacts是不可变的，所有的默认参数都单独放在一个地方。builder的setter方法返回builder本身，以便可以把调用链接起来,如果fat和sodium不需要，那么可以这样创建：\n\n```java\npublic static void main(String[] args) {\n\t\tNutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)\n\t\t\t\t.calories(100)\n\t\t\t\t.carbohydrate(27)\n\t\t\t\t.build();\n\t\t...\n\t}\n```\n设置了参数的builder生成了一个很好的抽象工厂，换句话说，客户端可以将这样一个builder传给方法，使该方法能够为客户端创建一个或者多个对象。\n\n```java\npublic interface Builder<T> {\n    public T build();\n}\n```\n带有Builder实例的方法通常利用有限制的通配符类型来约束构建器的类型参数。下面就是构建每个节点的方法，它利用一个客户端提供的Builder实例来构建树:\n\n```java\nTree BuilderTree(Builder<？ extends Node> nodeBuilder) {...}\n```\n","source":"_posts/Effective Java 使用构建器Builder.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">Effective Java 使用构建器Builder</font>\ndate: 2017-07-14 08:43:37\ncategories: java读书笔记\ntags: [Java,经验之谈,高效开发, Builder]\n---\n\n如果一个类有大量**可选的参数**，如果这个时候使用构造器就需要写大量有不同参数个数的构造器。举个例子，用一个类来表示包装食品外面显示的营养成分标签。这些标签中有一些是必须的，比如每份的含量，每罐的含量以及每份的卡路里。还有超过20多个可选的参数，比如总脂肪量、饱和脂肪量、转化脂肪、胆固醇、钠等等。大多数的产品在某几个可选参数中都会有非零的值。\n\n对于这样的类，传统方法是采用重叠构造器模式，在这种模式下，第一个构造器由所有必要参数来构造，第二个构造器多加一个可选参数，第三个多加两个可选参数，直到最后一个构造器包含所有可选参数。如下所示，为了简便，只显示四个可选域：\n\n```java\n/**\n* Telescoping constructor pattern - does not scale well\n*/\n\npublic class NutritionFacts {\n    private final int servingSize;         //(ml)                required\n    private final int servings;            //(per container)     required\n    private final int calories;            //                    optional\n    private final int fat;                 //(g)                 optional\n    private final int sodium;              //(mg)                optional\n    private final int carbohydrate;        //(g)                 optional\n    \n    public NutritionFacts(int servingSize, int servings) {\n        this(servingSize, servings, 0);\n    }\n    \n    public NutritionFacts(int servingSize, int servings, int calories) {\n        this(servingSize, servings, calories, 0);\n    }\n    \n    public NutritionFacts(int servingSize, int servings, int calories, int fat) {\n        this(servingSize, servings, calories, fat, 0);\n    }\n    \n    public NutritionFacts(int servingSize, int servings, int calories,\n            int fat, int sodium) {\n        this(servingSize, servings, calories, fat, sodium, 0);\n    }\n    \n    public NutritionFacts(int servingSize, int servings int calories,\n            int fat, int sodium, int carbohydrate) {\n        this.servingSize = servingSize;\n        this.servings = servings;\n        this.calories = calories;\n        this.fat = fat;\n        this.sodium = sodium;\n        this.carbohydrate = carbohydrate;\n    }\n}\n```\n如果参数非常多，就要写大量的构造器。在使用的时候一不小心颠倒了了其中两个参数的顺序，并不能被及时的发现，但是程序运行的时候则不是正确的结果。这个时候就可以使用Builder模式了。不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器，得到一个builder对象。然后客户端在builder对象上调用类似于setter的方法，来设置每个相关的可选参数。最后，客户端调用无参的build方法来生成不可变的对象。这个builder是它构建的类的静态成员类。如下：\n\n```java\npublic class NutritionFacts {\n\tprivate final int servingSize;\n\tprivate final int servings;\n\tprivate final int calories;\n\tprivate final int fat;\n\tprivate final int sodium;\n\tprivate final int carbohydrate;\n\n\tpublic static class Builder {\n\t\t// Required parameters\n\t\tprivate final int servingSize;\n\t\tprivate final int servings;\n\n\t\t// Optional parameters - initialized to default values\n\t\tprivate int calories = 0;\n\t\tprivate int fat = 0;\n\t\tprivate int carbohydrate = 0;\n\t\tprivate int sodium = 0;\n\n\t\tpublic Builder(int servingSize, int servings) {\n\t\t\tthis.servingSize = servingSize;\n\t\t\tthis.servings = servings;\n\t\t}\n\n\t\tpublic Builder calories(int val) {\n\t\t\tcalories = val;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder fat(int val) {\n\t\t\tfat = val;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder carbohydrate(int val) {\n\t\t\tcarbohydrate = val;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder sodium(int val) {\n\t\t\tsodium = val;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic NutritionFacts build() {\n\t\t\treturn new NutritionFacts(this);\n\t\t}\n\t\t\n\t\tprivate NutritionFacts(Builder builder) {\n    \t\tservingSize = builder.servingSize;\n    \t\tservings = builder.servings;\n    \t\tcalories = builder.calories;\n    \t\tfat = builder.fat;\n    \t\tsodium = builder.sodium;\n    \t\tcarbohydrate = builder.carbohydrate;\n\t    }\n\t}\n```\n注意NutritionFacts是不可变的，所有的默认参数都单独放在一个地方。builder的setter方法返回builder本身，以便可以把调用链接起来,如果fat和sodium不需要，那么可以这样创建：\n\n```java\npublic static void main(String[] args) {\n\t\tNutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)\n\t\t\t\t.calories(100)\n\t\t\t\t.carbohydrate(27)\n\t\t\t\t.build();\n\t\t...\n\t}\n```\n设置了参数的builder生成了一个很好的抽象工厂，换句话说，客户端可以将这样一个builder传给方法，使该方法能够为客户端创建一个或者多个对象。\n\n```java\npublic interface Builder<T> {\n    public T build();\n}\n```\n带有Builder实例的方法通常利用有限制的通配符类型来约束构建器的类型参数。下面就是构建每个节点的方法，它利用一个客户端提供的Builder实例来构建树:\n\n```java\nTree BuilderTree(Builder<？ extends Node> nodeBuilder) {...}\n```\n","slug":"Effective Java 使用构建器Builder","published":1,"updated":"2017-07-14T01:34:46.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hsnzm0003asvlzeorap7l","content":"<p>如果一个类有大量<strong>可选的参数</strong>，如果这个时候使用构造器就需要写大量有不同参数个数的构造器。举个例子，用一个类来表示包装食品外面显示的营养成分标签。这些标签中有一些是必须的，比如每份的含量，每罐的含量以及每份的卡路里。还有超过20多个可选的参数，比如总脂肪量、饱和脂肪量、转化脂肪、胆固醇、钠等等。大多数的产品在某几个可选参数中都会有非零的值。</p>\n<p>对于这样的类，传统方法是采用重叠构造器模式，在这种模式下，第一个构造器由所有必要参数来构造，第二个构造器多加一个可选参数，第三个多加两个可选参数，直到最后一个构造器包含所有可选参数。如下所示，为了简便，只显示四个可选域：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* Telescoping constructor pattern - does not scale well</div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NutritionFacts</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;         <span class=\"comment\">//(ml)                required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;            <span class=\"comment\">//(per container)     required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories;            <span class=\"comment\">//                    optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat;                 <span class=\"comment\">//(g)                 optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium;              <span class=\"comment\">//(mg)                optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate;        <span class=\"comment\">//(g)                 optional</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(servingSize, servings, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(servingSize, servings, calories, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories, <span class=\"keyword\">int</span> fat)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(servingSize, servings, calories, fat, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories,</span></span></div><div class=\"line\">            <span class=\"keyword\">int</span> fat, <span class=\"keyword\">int</span> sodium) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(servingSize, servings, calories, fat, sodium, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings <span class=\"keyword\">int</span> calories,</span></span></div><div class=\"line\">            <span class=\"keyword\">int</span> fat, <span class=\"keyword\">int</span> sodium, <span class=\"keyword\">int</span> carbohydrate) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.servingSize = servingSize;</div><div class=\"line\">        <span class=\"keyword\">this</span>.servings = servings;</div><div class=\"line\">        <span class=\"keyword\">this</span>.calories = calories;</div><div class=\"line\">        <span class=\"keyword\">this</span>.fat = fat;</div><div class=\"line\">        <span class=\"keyword\">this</span>.sodium = sodium;</div><div class=\"line\">        <span class=\"keyword\">this</span>.carbohydrate = carbohydrate;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果参数非常多，就要写大量的构造器。在使用的时候一不小心颠倒了了其中两个参数的顺序，并不能被及时的发现，但是程序运行的时候则不是正确的结果。这个时候就可以使用Builder模式了。不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器，得到一个builder对象。然后客户端在builder对象上调用类似于setter的方法，来设置每个相关的可选参数。最后，客户端调用无参的build方法来生成不可变的对象。这个builder是它构建的类的静态成员类。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NutritionFacts</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// Required parameters</span></div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// Optional parameters - initialized to default values</span></div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> calories = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> fat = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> carbohydrate = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> sodium = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.servingSize = servingSize;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.servings = servings;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">calories</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</div><div class=\"line\">\t\t\tcalories = val;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">fat</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</div><div class=\"line\">\t\t\tfat = val;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">carbohydrate</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</div><div class=\"line\">\t\t\tcarbohydrate = val;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">sodium</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</div><div class=\"line\">\t\t\tsodium = val;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> NutritionFacts <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NutritionFacts(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(Builder builder)</span> </span>&#123;</div><div class=\"line\">    \t\tservingSize = builder.servingSize;</div><div class=\"line\">    \t\tservings = builder.servings;</div><div class=\"line\">    \t\tcalories = builder.calories;</div><div class=\"line\">    \t\tfat = builder.fat;</div><div class=\"line\">    \t\tsodium = builder.sodium;</div><div class=\"line\">    \t\tcarbohydrate = builder.carbohydrate;</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>注意NutritionFacts是不可变的，所有的默认参数都单独放在一个地方。builder的setter方法返回builder本身，以便可以把调用链接起来,如果fat和sodium不需要，那么可以这样创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tNutritionFacts cocaCola = <span class=\"keyword\">new</span> NutritionFacts.Builder(<span class=\"number\">240</span>, <span class=\"number\">8</span>)</div><div class=\"line\">\t\t\t\t.calories(<span class=\"number\">100</span>)</div><div class=\"line\">\t\t\t\t.carbohydrate(<span class=\"number\">27</span>)</div><div class=\"line\">\t\t\t\t.build();</div><div class=\"line\">\t\t...</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>设置了参数的builder生成了一个很好的抽象工厂，换句话说，客户端可以将这样一个builder传给方法，使该方法能够为客户端创建一个或者多个对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Builder</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">build</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>带有Builder实例的方法通常利用有限制的通配符类型来约束构建器的类型参数。下面就是构建每个节点的方法，它利用一个客户端提供的Builder实例来构建树:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Tree <span class=\"title\">BuilderTree</span><span class=\"params\">(Builder&lt;？ extends Node&gt; nodeBuilder)</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>如果一个类有大量<strong>可选的参数</strong>，如果这个时候使用构造器就需要写大量有不同参数个数的构造器。举个例子，用一个类来表示包装食品外面显示的营养成分标签。这些标签中有一些是必须的，比如每份的含量，每罐的含量以及每份的卡路里。还有超过20多个可选的参数，比如总脂肪量、饱和脂肪量、转化脂肪、胆固醇、钠等等。大多数的产品在某几个可选参数中都会有非零的值。</p>\n<p>对于这样的类，传统方法是采用重叠构造器模式，在这种模式下，第一个构造器由所有必要参数来构造，第二个构造器多加一个可选参数，第三个多加两个可选参数，直到最后一个构造器包含所有可选参数。如下所示，为了简便，只显示四个可选域：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* Telescoping constructor pattern - does not scale well</div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NutritionFacts</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;         <span class=\"comment\">//(ml)                required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;            <span class=\"comment\">//(per container)     required</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories;            <span class=\"comment\">//                    optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat;                 <span class=\"comment\">//(g)                 optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium;              <span class=\"comment\">//(mg)                optional</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate;        <span class=\"comment\">//(g)                 optional</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(servingSize, servings, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(servingSize, servings, calories, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories, <span class=\"keyword\">int</span> fat)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(servingSize, servings, calories, fat, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings, <span class=\"keyword\">int</span> calories,</span></span></div><div class=\"line\">            <span class=\"keyword\">int</span> fat, <span class=\"keyword\">int</span> sodium) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>(servingSize, servings, calories, fat, sodium, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings <span class=\"keyword\">int</span> calories,</span></span></div><div class=\"line\">            <span class=\"keyword\">int</span> fat, <span class=\"keyword\">int</span> sodium, <span class=\"keyword\">int</span> carbohydrate) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.servingSize = servingSize;</div><div class=\"line\">        <span class=\"keyword\">this</span>.servings = servings;</div><div class=\"line\">        <span class=\"keyword\">this</span>.calories = calories;</div><div class=\"line\">        <span class=\"keyword\">this</span>.fat = fat;</div><div class=\"line\">        <span class=\"keyword\">this</span>.sodium = sodium;</div><div class=\"line\">        <span class=\"keyword\">this</span>.carbohydrate = carbohydrate;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果参数非常多，就要写大量的构造器。在使用的时候一不小心颠倒了了其中两个参数的顺序，并不能被及时的发现，但是程序运行的时候则不是正确的结果。这个时候就可以使用Builder模式了。不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器，得到一个builder对象。然后客户端在builder对象上调用类似于setter的方法，来设置每个相关的可选参数。最后，客户端调用无参的build方法来生成不可变的对象。这个builder是它构建的类的静态成员类。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NutritionFacts</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> calories;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fat;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sodium;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> carbohydrate;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// Required parameters</span></div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servingSize;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> servings;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// Optional parameters - initialized to default values</span></div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> calories = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> fat = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> carbohydrate = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> sodium = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Builder</span><span class=\"params\">(<span class=\"keyword\">int</span> servingSize, <span class=\"keyword\">int</span> servings)</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.servingSize = servingSize;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.servings = servings;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">calories</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</div><div class=\"line\">\t\t\tcalories = val;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">fat</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</div><div class=\"line\">\t\t\tfat = val;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">carbohydrate</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</div><div class=\"line\">\t\t\tcarbohydrate = val;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> Builder <span class=\"title\">sodium</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</div><div class=\"line\">\t\t\tsodium = val;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> NutritionFacts <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NutritionFacts(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">NutritionFacts</span><span class=\"params\">(Builder builder)</span> </span>&#123;</div><div class=\"line\">    \t\tservingSize = builder.servingSize;</div><div class=\"line\">    \t\tservings = builder.servings;</div><div class=\"line\">    \t\tcalories = builder.calories;</div><div class=\"line\">    \t\tfat = builder.fat;</div><div class=\"line\">    \t\tsodium = builder.sodium;</div><div class=\"line\">    \t\tcarbohydrate = builder.carbohydrate;</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>注意NutritionFacts是不可变的，所有的默认参数都单独放在一个地方。builder的setter方法返回builder本身，以便可以把调用链接起来,如果fat和sodium不需要，那么可以这样创建：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tNutritionFacts cocaCola = <span class=\"keyword\">new</span> NutritionFacts.Builder(<span class=\"number\">240</span>, <span class=\"number\">8</span>)</div><div class=\"line\">\t\t\t\t.calories(<span class=\"number\">100</span>)</div><div class=\"line\">\t\t\t\t.carbohydrate(<span class=\"number\">27</span>)</div><div class=\"line\">\t\t\t\t.build();</div><div class=\"line\">\t\t...</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>设置了参数的builder生成了一个很好的抽象工厂，换句话说，客户端可以将这样一个builder传给方法，使该方法能够为客户端创建一个或者多个对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Builder</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">build</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>带有Builder实例的方法通常利用有限制的通配符类型来约束构建器的类型参数。下面就是构建每个节点的方法，它利用一个客户端提供的Builder实例来构建树:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Tree <span class=\"title\">BuilderTree</span><span class=\"params\">(Builder&lt;？ extends Node&gt; nodeBuilder)</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>\n"},{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">Java工具——FreeMaker模板引擎</font>","date":"2017-05-26T00:47:26.000Z","_content":"FreeMaker是一个模板引擎，它基于模板和数据来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)。也就是说它可以生成文件，而这些文件的格式是我们指定好的格式。文件中的内容是通过插值来填充的。也就是所谓的模板+数据=输出。\n\n首先来看看FreeMarker模板文件，它是以.ftl为后缀的文件，主要由如下4个部分组成:\n1.文本:直接输出的部分\n2.注释:<#-- ... -->格式部分,不会输出\n3.插值:即${...}或#{...}格式的部分,将使用数据模型中的部分替代输出\n4.FTL指令:FreeMarker指定,和HTML标记类似,名字前加#予以区分,不会输出\n \n具体编程的话，在Java中，为了使用FreeMarker将数据模型中的值合并到从模板文件生成的模板中,可按如下步骤进行:\n1.**创建配置实例**：首先，创建一个Configuration的实例，然后调整它的设置。Configuration实例是存储FreeMarker应用级设置的核心部分。同时，它也处理那些创建和缓存预解析模板的工作。\n```java\nConfiguration cfg = new Configuration(Configuration.VERSION_2_3_22); \n// 指定模板文件从何处加载的数据源，这里设置成一个文件目录。 \ncfg.setDirectoryForTemplateLoading(new File(\"/where/you/store/templates\")); \n// 指定模板如何检索数据模型，后面会讲到，先可以这么来用： \ncfg.setObjectWrapper(new DefaultObjectWrapper()); \n//指定异常处理句柄\ncfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n//指定默认的编码格式\ncfg.setDefaultEncoding(\"UTF-8\");\n```\n这些工作只在应用(可能是servlet)生命周期的开始执行一次。\n2.**创建数据模型**：\n比如这样一个数据模型:\n(root) \n  | \n  +- user = \"Big Joe\" \n  | \n  +- latest Product \n  　　| \n  　　+- url = \"products/greenmouse.html\" \n  　　| \n  　　+- name = \"green mouse\"\n用java来构建：\n```java\n// 创建根哈希表 \nMap root = new HashMap(); \n// 在根中放入字符串\"user\" \nroot.put(\"user\", \"Big Joe\"); \n// 为\"latestProduct\"创建哈希表 \nMap latest = new HashMap(); \n// 将它添加到根哈希表中 \nroot.put(\"latestProduct\", latest); \n// 在 latest 中放置\"url\"和\"name\"  \nlatest.put(\"url\", \"products/greenmouse.html\"); \nlatest.put(\"name\", \"green mouse\");\n```\n现在root就是要填充到模板template中的数据了。\n3.**获得模板**\n现在有一个模板文件：test.ftl，存放在之前设置的目录中。test.ftl文件中的内容(即模板)如下：\n```html\n<html> \n<head> \n  <title>Welcome!</title> \n</head> \n<body> \n  <h1>Welcome ${user}!</h1> \n  <p>Our latestproduct:</p> \n  <a href=\"${latestProduct.url}\">${latestProduct.name}</a>! \n</body> \n</html> \n```\n在程序中我们可以用freemarker.template.Template来临时存储模板的格式，当我们需要一个模板实例的时候，就可以使用Configuration的getTemplate方法来获取。在之前设置的目录中，我们用test.ftl存储了示例模板，那么就可以这样来做：\n```java\nTemplate temp = cfg.getTemplate(\"test.ftl\");\n```\n当调用这个方法的时候，将会创建一个Template实例,它是test.ftl文件经过读取和解析（编译）之后创建的模板实例。Template实例以解析后的形式存储模板，而不是以源文件的文本形式。 \n4.**合并模板和数据模型**\n我们都已经知道：数据模型+模板=输出，现在我们已经有了一个数据模型root和一个模板temp了，所以为了得到输出就需要合并它们。这是由模板的process方法完成的。它用数据模型root和Writer对象作为参数，然后向\nWriter对象写入产生的内容。为简单起见，这里我们只做标准的输出：\n```java\nWriter out = new OutputStreamWriter(System.out); \ntemp.process(root, out); \nout.flush();\n```\n上面的代码会向你的终端以数据模板的格式输出数据模型的数据。\n完整的代码：\n```java\nimport freemarker.template.*; \nimport java.util.*; \nimport java.io.*; \npublic classTest { \n    public static void main(String[] args) throws Exception { \n        /* 在整个应用的生命周期中，这个工作你应该只做一次。 */  \n        /* 创建和调整配置。 */ \n        Configuration cfg = new Configuration(); \n        cfg.setDirectoryForTemplateLoading(new File(\"/where/you/store/templates\")); \n        cfg.setObjectWrapper(new DefaultObjectWrapper()); \n       \n        /* 在整个应用的生命周期中，这个工作你可以执行多次 */  \n        /* 获取或创建模板*/ \n        Template temp = cfg.getTemplate(\"test.ftl\"); \n        \n        /* 创建数据模型 */ \n        Map root = new HashMap(); \n        root.put(\"user\", \"Big Joe\"); \n        Map latest = new HashMap(); \n        root.put(\"latestProduct\", latest); \n        latest.put(\"url\", \"products/greenmouse.html\"); \n        latest.put(\"name\", \"green mouse\"); \n       \n        /* 将模板和数据模型合并 */ \n        Writer out = new OutputStreamWriter(System.out);\n        temp.process(root, out); \n        out.flush(); \n    } \n} \n```\n\n上面已经讲了基本用法，现在进行更深入的理解：\n**Configuration**\n-------------\n\nConfiguration存储了常用(全局，应用程序级)的设置，定义了想要在所有模板中可用的变量(称为共享变量)。 而且，它会处理 Template 实例的新建和缓存。通常使用一个共享的单实例Configuration对象。\n\n**设置共享变量**，是为所有模板所定义的变量。\n```java\ncfg.setSharedVariable(String name,Object obj);  \n```\n比如：\n```java\nConfiguration cfg = new Configuration();\n...\ncfg.setSahredVariable(\"wrap\", new WrapDirective());\n// 使用 ObjectWrapper.DEFAULT_WRAPPER \ncfg.setSharedVariable(\"company\", \"Foo Inc.\");\n```\n上面这段代码表示：\n在所有使用这个配置的模板中，名为wrap的用户自定义指令。\n一个名为company的字符串将会在数据模型的根上可见，这样就不用在根哈希表上一次又一次的添加它们。在传递给Template.process根对象里的变量将会隐藏同名的共享变量。\n警告：如果配置对象在多线程环境中使用，不要使用TemplateModel实现类来作为共享变量，因为它是线程不安全的。这也是基于Servlet的Web站点的典型情况。\n\n**配置设置**\n配置设置有很多， 例如：locale，number_format，default_encoding， template_exception_handler。\n比如说设置编码格式:\n```java\ncfg.setDefaultEncoding(\"UTF-8\");  \n```\n那么使用该配置的所有模板的编码格式都是UTF-8。\n配置信息可以被想象成3层(Configuration， Template，Environment)，最高层包含特定的值，它为设置信息提供最有效的值。 比如(设置信息A到F仅仅是为这个示例而构想的)：\n\n|| Setting A |Setting B|Setting C|Setting D|Setting E|Setting F|\n|:---------:|:-----------:|:-----------:|:-----------:|:-----------:|:-----------:|\n|Layer 3: Environment| 1 |-|-|1|-|-|\n|Layer 2: Template| 2 |2|-|-|2|-|\n|Layer 1: Configuration| 3 |3|3|3|-|-|\n配置信息的有效值为：A=1，B=2，C=3，D=1，E=2。 而F的设置则是null，或者在你获取它的时候将抛出异常。\n\n - Configuration 层： 原则上设置配置信息时使用 Configuration 对象的setter方法，例如：\n\t```java\n\tConfiguration myCfg = new Configuration(Configuration.VERSION_2_3_23);\n\tmyCfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n\tmyCfg.setDefaultEncoding(\"UTF-8\");\n\t```\n\t在真正使用 Configuration 对象 (通常在初始化应用程序时)之前来配置它，后面必须将其视为只读的对象。\n\n - Template层：对于被请求的本地化信息，也就是模板的locale 设置，它由Configuration.getTemplate(...) 来设置。但是如果我们想控制Template对象来代替freemarker.cache.TemplateCache的话，就应该在Template对象第一次被使用前就设置配置信息，然后就将Template对象视为是只读的。\n - Environment 层：这里有两种配置方法： \n\t一是使用Java API：使用 Environment对象的setter方法。当然这需要在模板执行之前来做。但是我们如果直接调用myTemplate.process(...) 就会遇到问题，因为在内部创建Environment对象后立即就执行模板了，导致没有机会来进行设置。这个问题的解决可以用下面两个步骤进行：\n\t```java\n\tEnvironment env = myTemplate.createProcessingEnvironment(root, out);\n\tenv.setLocale(java.util.Locale.ITALY); \n\tenv.setNumberFormat(\"0.####\");\n\tenv.process();  // process the template\n\t```\n\t二是在模板中直接使用setting指令，但是这种方法并不推荐，例如：\n\t```java\n\t<#setting locale=\"it_IT\">\n\t<#setting number_format=\"0.####\">\n\t```\n\t在Environment层中，什么时候改变配置信息是没有限制的。\n\n**模板加载**\n模板加载器加载基于抽象模板路径下的比如 \"index.ftl\" 或 \"products/catalog.ftl\"的原生文本数据对象。加载完毕之后，它会解析文本来生成模板。\n\n - 内建模板加载器：\n\t在 Configuration 中可以使用下面的方法来建立三种不同的模板加载器。 (每种方法都会在其内部新建一个模板加载器对象，然后创建 Configuration 实例来使用它。)\n\t```java\n\tvoid setDirectoryForTemplateLoading(File dir);\n\t```\n\t```java\n\tvoid setClassForTemplateLoading(Class cl, String prefix);\n\t```\n\t```java\n\tvoid setServletContextForTemplateLoading(Object servletContext, String path);\n\t```\n\t上述的第一种方法在磁盘的文件系统上设置了一个明确的目录， 它确定了从哪里加载模板。\n\t第二种调用方法的参数是一个类和一个路径前缀，参数prefix是给模板的名称来加前缀的，其实就是文件相对于给定类的路径。这个方法顾名思义就是通过获得给定类的相对位置以及之后的prefix参数来获得template文件。这样方便我们将template文件一起打成jar包使用。经验之谈，这里prefix必须以“/”开头。\n\t第三种调用方式需要Web应用的上下文和一个基路径作为参数，这个基路径是Web应用根路径(WEB-INF目录的上级目录)的相对路径。加载器会从Web应用目录开始加载模板。而且加载方法对没有打包的.war文件也起作用，因为它使用了ServletContext.getResource()方法来访问模板。比如： setServletContextForTemplateLoading(context, \"/ftl\") 就是 /WebRoot/ftl目录。\n\n - 从多个位置加载模板:\n\t如果需要从多个位置加载模板，那就不得不为每个位置都实例化模板加载器对象，将他们封装成一个MultiTemplateLoader的特殊模板加载器，最终传给Configuration对象的setTemplateLoader(TemplateLoader loader)方法。如从/user/data/templates和/temp/templates两个地方加载模板可以这么做：\n\t```java\n\tFileTemplateLoader ftl1 = new FileTemplateLoader(new File(\"/temp/templates\"));  \n\tFileTemplateLoader ftl2 = new FileTemplateLoader(new File(\"/user/data/templates\"));  \n\tClassTemplateLoader ctl1 = new ClassTemplateLoader(TemplateLoaderTest.class, \"/\");  \n\tTemplateLoader[] loaders = new TemplateLoader[]{ftl1, ftl2, ctl1};  \n\tMultiTemplateLoader mtl = new MultiTemplateLoader(loaders);  \n\tcfg.setTemplateLoader(mtl);  \n\t```\n\t现在，FreeMarker将会尝试从 /tmp/templates目录加载模板，如果在这个目录下没有发现请求的模板，它就会继续尝试从/usr/data/templates 目录下加载，如果还是没有发现请求的模板， 那么它就会使用类加载器来加载模板。\n\n - 从其他资源加载模板\n 如果内建的类加载器都不适合使用，那么就需要来编写自己的类加载器了，这个类需要实现freemarker.cache.TemplateLoader接口，然后将它传递给Configuration对象的setTemplateLoader(TemplateLoader loader)方法。可以阅读API JavaDoc文档获取更多信息。如果模板需要通过URL访问其他模板，那么就不需要实现TemplateLoader接口了，可以选择子接口freemarker.cache.URLTemplateLoader来替代，只需实现URLgetURL(String templateName)方法即可。\n\n完整的FreeMaker学习资料：[FreeMarker_2.3.23_Manual_zh_CN][1]\n\n\n  [1]: https://github.com/yuchengxin/FreeMarker_2.3.23_Manual_zh_CN.git","source":"_posts/Java工具类——FreeMarker.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">Java工具——FreeMaker模板引擎</font>\ndate: 2017-05-26 08:47:26\ncategories: java工具\ntags: [java,FreeMaker,模板引擎]\n---\nFreeMaker是一个模板引擎，它基于模板和数据来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)。也就是说它可以生成文件，而这些文件的格式是我们指定好的格式。文件中的内容是通过插值来填充的。也就是所谓的模板+数据=输出。\n\n首先来看看FreeMarker模板文件，它是以.ftl为后缀的文件，主要由如下4个部分组成:\n1.文本:直接输出的部分\n2.注释:<#-- ... -->格式部分,不会输出\n3.插值:即${...}或#{...}格式的部分,将使用数据模型中的部分替代输出\n4.FTL指令:FreeMarker指定,和HTML标记类似,名字前加#予以区分,不会输出\n \n具体编程的话，在Java中，为了使用FreeMarker将数据模型中的值合并到从模板文件生成的模板中,可按如下步骤进行:\n1.**创建配置实例**：首先，创建一个Configuration的实例，然后调整它的设置。Configuration实例是存储FreeMarker应用级设置的核心部分。同时，它也处理那些创建和缓存预解析模板的工作。\n```java\nConfiguration cfg = new Configuration(Configuration.VERSION_2_3_22); \n// 指定模板文件从何处加载的数据源，这里设置成一个文件目录。 \ncfg.setDirectoryForTemplateLoading(new File(\"/where/you/store/templates\")); \n// 指定模板如何检索数据模型，后面会讲到，先可以这么来用： \ncfg.setObjectWrapper(new DefaultObjectWrapper()); \n//指定异常处理句柄\ncfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n//指定默认的编码格式\ncfg.setDefaultEncoding(\"UTF-8\");\n```\n这些工作只在应用(可能是servlet)生命周期的开始执行一次。\n2.**创建数据模型**：\n比如这样一个数据模型:\n(root) \n  | \n  +- user = \"Big Joe\" \n  | \n  +- latest Product \n  　　| \n  　　+- url = \"products/greenmouse.html\" \n  　　| \n  　　+- name = \"green mouse\"\n用java来构建：\n```java\n// 创建根哈希表 \nMap root = new HashMap(); \n// 在根中放入字符串\"user\" \nroot.put(\"user\", \"Big Joe\"); \n// 为\"latestProduct\"创建哈希表 \nMap latest = new HashMap(); \n// 将它添加到根哈希表中 \nroot.put(\"latestProduct\", latest); \n// 在 latest 中放置\"url\"和\"name\"  \nlatest.put(\"url\", \"products/greenmouse.html\"); \nlatest.put(\"name\", \"green mouse\");\n```\n现在root就是要填充到模板template中的数据了。\n3.**获得模板**\n现在有一个模板文件：test.ftl，存放在之前设置的目录中。test.ftl文件中的内容(即模板)如下：\n```html\n<html> \n<head> \n  <title>Welcome!</title> \n</head> \n<body> \n  <h1>Welcome ${user}!</h1> \n  <p>Our latestproduct:</p> \n  <a href=\"${latestProduct.url}\">${latestProduct.name}</a>! \n</body> \n</html> \n```\n在程序中我们可以用freemarker.template.Template来临时存储模板的格式，当我们需要一个模板实例的时候，就可以使用Configuration的getTemplate方法来获取。在之前设置的目录中，我们用test.ftl存储了示例模板，那么就可以这样来做：\n```java\nTemplate temp = cfg.getTemplate(\"test.ftl\");\n```\n当调用这个方法的时候，将会创建一个Template实例,它是test.ftl文件经过读取和解析（编译）之后创建的模板实例。Template实例以解析后的形式存储模板，而不是以源文件的文本形式。 \n4.**合并模板和数据模型**\n我们都已经知道：数据模型+模板=输出，现在我们已经有了一个数据模型root和一个模板temp了，所以为了得到输出就需要合并它们。这是由模板的process方法完成的。它用数据模型root和Writer对象作为参数，然后向\nWriter对象写入产生的内容。为简单起见，这里我们只做标准的输出：\n```java\nWriter out = new OutputStreamWriter(System.out); \ntemp.process(root, out); \nout.flush();\n```\n上面的代码会向你的终端以数据模板的格式输出数据模型的数据。\n完整的代码：\n```java\nimport freemarker.template.*; \nimport java.util.*; \nimport java.io.*; \npublic classTest { \n    public static void main(String[] args) throws Exception { \n        /* 在整个应用的生命周期中，这个工作你应该只做一次。 */  \n        /* 创建和调整配置。 */ \n        Configuration cfg = new Configuration(); \n        cfg.setDirectoryForTemplateLoading(new File(\"/where/you/store/templates\")); \n        cfg.setObjectWrapper(new DefaultObjectWrapper()); \n       \n        /* 在整个应用的生命周期中，这个工作你可以执行多次 */  \n        /* 获取或创建模板*/ \n        Template temp = cfg.getTemplate(\"test.ftl\"); \n        \n        /* 创建数据模型 */ \n        Map root = new HashMap(); \n        root.put(\"user\", \"Big Joe\"); \n        Map latest = new HashMap(); \n        root.put(\"latestProduct\", latest); \n        latest.put(\"url\", \"products/greenmouse.html\"); \n        latest.put(\"name\", \"green mouse\"); \n       \n        /* 将模板和数据模型合并 */ \n        Writer out = new OutputStreamWriter(System.out);\n        temp.process(root, out); \n        out.flush(); \n    } \n} \n```\n\n上面已经讲了基本用法，现在进行更深入的理解：\n**Configuration**\n-------------\n\nConfiguration存储了常用(全局，应用程序级)的设置，定义了想要在所有模板中可用的变量(称为共享变量)。 而且，它会处理 Template 实例的新建和缓存。通常使用一个共享的单实例Configuration对象。\n\n**设置共享变量**，是为所有模板所定义的变量。\n```java\ncfg.setSharedVariable(String name,Object obj);  \n```\n比如：\n```java\nConfiguration cfg = new Configuration();\n...\ncfg.setSahredVariable(\"wrap\", new WrapDirective());\n// 使用 ObjectWrapper.DEFAULT_WRAPPER \ncfg.setSharedVariable(\"company\", \"Foo Inc.\");\n```\n上面这段代码表示：\n在所有使用这个配置的模板中，名为wrap的用户自定义指令。\n一个名为company的字符串将会在数据模型的根上可见，这样就不用在根哈希表上一次又一次的添加它们。在传递给Template.process根对象里的变量将会隐藏同名的共享变量。\n警告：如果配置对象在多线程环境中使用，不要使用TemplateModel实现类来作为共享变量，因为它是线程不安全的。这也是基于Servlet的Web站点的典型情况。\n\n**配置设置**\n配置设置有很多， 例如：locale，number_format，default_encoding， template_exception_handler。\n比如说设置编码格式:\n```java\ncfg.setDefaultEncoding(\"UTF-8\");  \n```\n那么使用该配置的所有模板的编码格式都是UTF-8。\n配置信息可以被想象成3层(Configuration， Template，Environment)，最高层包含特定的值，它为设置信息提供最有效的值。 比如(设置信息A到F仅仅是为这个示例而构想的)：\n\n|| Setting A |Setting B|Setting C|Setting D|Setting E|Setting F|\n|:---------:|:-----------:|:-----------:|:-----------:|:-----------:|:-----------:|\n|Layer 3: Environment| 1 |-|-|1|-|-|\n|Layer 2: Template| 2 |2|-|-|2|-|\n|Layer 1: Configuration| 3 |3|3|3|-|-|\n配置信息的有效值为：A=1，B=2，C=3，D=1，E=2。 而F的设置则是null，或者在你获取它的时候将抛出异常。\n\n - Configuration 层： 原则上设置配置信息时使用 Configuration 对象的setter方法，例如：\n\t```java\n\tConfiguration myCfg = new Configuration(Configuration.VERSION_2_3_23);\n\tmyCfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n\tmyCfg.setDefaultEncoding(\"UTF-8\");\n\t```\n\t在真正使用 Configuration 对象 (通常在初始化应用程序时)之前来配置它，后面必须将其视为只读的对象。\n\n - Template层：对于被请求的本地化信息，也就是模板的locale 设置，它由Configuration.getTemplate(...) 来设置。但是如果我们想控制Template对象来代替freemarker.cache.TemplateCache的话，就应该在Template对象第一次被使用前就设置配置信息，然后就将Template对象视为是只读的。\n - Environment 层：这里有两种配置方法： \n\t一是使用Java API：使用 Environment对象的setter方法。当然这需要在模板执行之前来做。但是我们如果直接调用myTemplate.process(...) 就会遇到问题，因为在内部创建Environment对象后立即就执行模板了，导致没有机会来进行设置。这个问题的解决可以用下面两个步骤进行：\n\t```java\n\tEnvironment env = myTemplate.createProcessingEnvironment(root, out);\n\tenv.setLocale(java.util.Locale.ITALY); \n\tenv.setNumberFormat(\"0.####\");\n\tenv.process();  // process the template\n\t```\n\t二是在模板中直接使用setting指令，但是这种方法并不推荐，例如：\n\t```java\n\t<#setting locale=\"it_IT\">\n\t<#setting number_format=\"0.####\">\n\t```\n\t在Environment层中，什么时候改变配置信息是没有限制的。\n\n**模板加载**\n模板加载器加载基于抽象模板路径下的比如 \"index.ftl\" 或 \"products/catalog.ftl\"的原生文本数据对象。加载完毕之后，它会解析文本来生成模板。\n\n - 内建模板加载器：\n\t在 Configuration 中可以使用下面的方法来建立三种不同的模板加载器。 (每种方法都会在其内部新建一个模板加载器对象，然后创建 Configuration 实例来使用它。)\n\t```java\n\tvoid setDirectoryForTemplateLoading(File dir);\n\t```\n\t```java\n\tvoid setClassForTemplateLoading(Class cl, String prefix);\n\t```\n\t```java\n\tvoid setServletContextForTemplateLoading(Object servletContext, String path);\n\t```\n\t上述的第一种方法在磁盘的文件系统上设置了一个明确的目录， 它确定了从哪里加载模板。\n\t第二种调用方法的参数是一个类和一个路径前缀，参数prefix是给模板的名称来加前缀的，其实就是文件相对于给定类的路径。这个方法顾名思义就是通过获得给定类的相对位置以及之后的prefix参数来获得template文件。这样方便我们将template文件一起打成jar包使用。经验之谈，这里prefix必须以“/”开头。\n\t第三种调用方式需要Web应用的上下文和一个基路径作为参数，这个基路径是Web应用根路径(WEB-INF目录的上级目录)的相对路径。加载器会从Web应用目录开始加载模板。而且加载方法对没有打包的.war文件也起作用，因为它使用了ServletContext.getResource()方法来访问模板。比如： setServletContextForTemplateLoading(context, \"/ftl\") 就是 /WebRoot/ftl目录。\n\n - 从多个位置加载模板:\n\t如果需要从多个位置加载模板，那就不得不为每个位置都实例化模板加载器对象，将他们封装成一个MultiTemplateLoader的特殊模板加载器，最终传给Configuration对象的setTemplateLoader(TemplateLoader loader)方法。如从/user/data/templates和/temp/templates两个地方加载模板可以这么做：\n\t```java\n\tFileTemplateLoader ftl1 = new FileTemplateLoader(new File(\"/temp/templates\"));  \n\tFileTemplateLoader ftl2 = new FileTemplateLoader(new File(\"/user/data/templates\"));  \n\tClassTemplateLoader ctl1 = new ClassTemplateLoader(TemplateLoaderTest.class, \"/\");  \n\tTemplateLoader[] loaders = new TemplateLoader[]{ftl1, ftl2, ctl1};  \n\tMultiTemplateLoader mtl = new MultiTemplateLoader(loaders);  \n\tcfg.setTemplateLoader(mtl);  \n\t```\n\t现在，FreeMarker将会尝试从 /tmp/templates目录加载模板，如果在这个目录下没有发现请求的模板，它就会继续尝试从/usr/data/templates 目录下加载，如果还是没有发现请求的模板， 那么它就会使用类加载器来加载模板。\n\n - 从其他资源加载模板\n 如果内建的类加载器都不适合使用，那么就需要来编写自己的类加载器了，这个类需要实现freemarker.cache.TemplateLoader接口，然后将它传递给Configuration对象的setTemplateLoader(TemplateLoader loader)方法。可以阅读API JavaDoc文档获取更多信息。如果模板需要通过URL访问其他模板，那么就不需要实现TemplateLoader接口了，可以选择子接口freemarker.cache.URLTemplateLoader来替代，只需实现URLgetURL(String templateName)方法即可。\n\n完整的FreeMaker学习资料：[FreeMarker_2.3.23_Manual_zh_CN][1]\n\n\n  [1]: https://github.com/yuchengxin/FreeMarker_2.3.23_Manual_zh_CN.git","slug":"Java工具类——FreeMarker","published":1,"updated":"2017-07-12T01:50:40.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hsnzt0007asvl0k3onrvu","content":"<p>FreeMaker是一个模板引擎，它基于模板和数据来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)。也就是说它可以生成文件，而这些文件的格式是我们指定好的格式。文件中的内容是通过插值来填充的。也就是所谓的模板+数据=输出。</p>\n<p>首先来看看FreeMarker模板文件，它是以.ftl为后缀的文件，主要由如下4个部分组成:<br>1.文本:直接输出的部分<br>2.注释:&lt;#– … –&gt;格式部分,不会输出<br>3.插值:即${…}或#{…}格式的部分,将使用数据模型中的部分替代输出<br>4.FTL指令:FreeMarker指定,和HTML标记类似,名字前加#予以区分,不会输出</p>\n<p>具体编程的话，在Java中，为了使用FreeMarker将数据模型中的值合并到从模板文件生成的模板中,可按如下步骤进行:<br>1.<strong>创建配置实例</strong>：首先，创建一个Configuration的实例，然后调整它的设置。Configuration实例是存储FreeMarker应用级设置的核心部分。同时，它也处理那些创建和缓存预解析模板的工作。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Configuration cfg = <span class=\"keyword\">new</span> Configuration(Configuration.VERSION_2_3_22); </div><div class=\"line\"><span class=\"comment\">// 指定模板文件从何处加载的数据源，这里设置成一个文件目录。 </span></div><div class=\"line\">cfg.setDirectoryForTemplateLoading(<span class=\"keyword\">new</span> File(<span class=\"string\">\"/where/you/store/templates\"</span>)); </div><div class=\"line\"><span class=\"comment\">// 指定模板如何检索数据模型，后面会讲到，先可以这么来用： </span></div><div class=\"line\">cfg.setObjectWrapper(<span class=\"keyword\">new</span> DefaultObjectWrapper()); </div><div class=\"line\"><span class=\"comment\">//指定异常处理句柄</span></div><div class=\"line\">cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);</div><div class=\"line\"><span class=\"comment\">//指定默认的编码格式</span></div><div class=\"line\">cfg.setDefaultEncoding(<span class=\"string\">\"UTF-8\"</span>);</div></pre></td></tr></table></figure></p>\n<p>这些工作只在应用(可能是servlet)生命周期的开始执行一次。<br>2.<strong>创建数据模型</strong>：<br>比如这样一个数据模型:<br>(root)<br>  |<br>  +- user = “Big Joe”<br>  |<br>  +- latest Product<br>  　　|<br>  　　+- url = “products/greenmouse.html”<br>  　　|<br>  　　+- name = “green mouse”<br>用java来构建：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建根哈希表 </span></div><div class=\"line\">Map root = <span class=\"keyword\">new</span> HashMap(); </div><div class=\"line\"><span class=\"comment\">// 在根中放入字符串\"user\" </span></div><div class=\"line\">root.put(<span class=\"string\">\"user\"</span>, <span class=\"string\">\"Big Joe\"</span>); </div><div class=\"line\"><span class=\"comment\">// 为\"latestProduct\"创建哈希表 </span></div><div class=\"line\">Map latest = <span class=\"keyword\">new</span> HashMap(); </div><div class=\"line\"><span class=\"comment\">// 将它添加到根哈希表中 </span></div><div class=\"line\">root.put(<span class=\"string\">\"latestProduct\"</span>, latest); </div><div class=\"line\"><span class=\"comment\">// 在 latest 中放置\"url\"和\"name\"  </span></div><div class=\"line\">latest.put(<span class=\"string\">\"url\"</span>, <span class=\"string\">\"products/greenmouse.html\"</span>); </div><div class=\"line\">latest.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"green mouse\"</span>);</div></pre></td></tr></table></figure></p>\n<p>现在root就是要填充到模板template中的数据了。<br>3.<strong>获得模板</strong><br>现在有一个模板文件：test.ftl，存放在之前设置的目录中。test.ftl文件中的内容(即模板)如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span> </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Welcome!<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span> </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome $&#123;user&#125;!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span> </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Our latestproduct:<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"$&#123;latestProduct.url&#125;\"</span>&gt;</span>$&#123;latestProduct.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span>! </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>在程序中我们可以用freemarker.template.Template来临时存储模板的格式，当我们需要一个模板实例的时候，就可以使用Configuration的getTemplate方法来获取。在之前设置的目录中，我们用test.ftl存储了示例模板，那么就可以这样来做：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Template temp = cfg.getTemplate(<span class=\"string\">\"test.ftl\"</span>);</div></pre></td></tr></table></figure></p>\n<p>当调用这个方法的时候，将会创建一个Template实例,它是test.ftl文件经过读取和解析（编译）之后创建的模板实例。Template实例以解析后的形式存储模板，而不是以源文件的文本形式。<br>4.<strong>合并模板和数据模型</strong><br>我们都已经知道：数据模型+模板=输出，现在我们已经有了一个数据模型root和一个模板temp了，所以为了得到输出就需要合并它们。这是由模板的process方法完成的。它用数据模型root和Writer对象作为参数，然后向<br>Writer对象写入产生的内容。为简单起见，这里我们只做标准的输出：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Writer out = <span class=\"keyword\">new</span> OutputStreamWriter(System.out); </div><div class=\"line\">temp.process(root, out); </div><div class=\"line\">out.flush();</div></pre></td></tr></table></figure></p>\n<p>上面的代码会向你的终端以数据模板的格式输出数据模型的数据。<br>完整的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> freemarker.template.*; </div><div class=\"line\"><span class=\"keyword\">import</span> java.util.*; </div><div class=\"line\"><span class=\"keyword\">import</span> java.io.*; </div><div class=\"line\"><span class=\"keyword\">public</span> classTest &#123; </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123; </div><div class=\"line\">        <span class=\"comment\">/* 在整个应用的生命周期中，这个工作你应该只做一次。 */</span>  </div><div class=\"line\">        <span class=\"comment\">/* 创建和调整配置。 */</span> </div><div class=\"line\">        Configuration cfg = <span class=\"keyword\">new</span> Configuration(); </div><div class=\"line\">        cfg.setDirectoryForTemplateLoading(<span class=\"keyword\">new</span> File(<span class=\"string\">\"/where/you/store/templates\"</span>)); </div><div class=\"line\">        cfg.setObjectWrapper(<span class=\"keyword\">new</span> DefaultObjectWrapper()); </div><div class=\"line\">       </div><div class=\"line\">        <span class=\"comment\">/* 在整个应用的生命周期中，这个工作你可以执行多次 */</span>  </div><div class=\"line\">        <span class=\"comment\">/* 获取或创建模板*/</span> </div><div class=\"line\">        Template temp = cfg.getTemplate(<span class=\"string\">\"test.ftl\"</span>); </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">/* 创建数据模型 */</span> </div><div class=\"line\">        Map root = <span class=\"keyword\">new</span> HashMap(); </div><div class=\"line\">        root.put(<span class=\"string\">\"user\"</span>, <span class=\"string\">\"Big Joe\"</span>); </div><div class=\"line\">        Map latest = <span class=\"keyword\">new</span> HashMap(); </div><div class=\"line\">        root.put(<span class=\"string\">\"latestProduct\"</span>, latest); </div><div class=\"line\">        latest.put(<span class=\"string\">\"url\"</span>, <span class=\"string\">\"products/greenmouse.html\"</span>); </div><div class=\"line\">        latest.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"green mouse\"</span>); </div><div class=\"line\">       </div><div class=\"line\">        <span class=\"comment\">/* 将模板和数据模型合并 */</span> </div><div class=\"line\">        Writer out = <span class=\"keyword\">new</span> OutputStreamWriter(System.out);</div><div class=\"line\">        temp.process(root, out); </div><div class=\"line\">        out.flush(); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面已经讲了基本用法，现在进行更深入的理解：</p>\n<h2 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"Configuration\"></a><strong>Configuration</strong></h2><p>Configuration存储了常用(全局，应用程序级)的设置，定义了想要在所有模板中可用的变量(称为共享变量)。 而且，它会处理 Template 实例的新建和缓存。通常使用一个共享的单实例Configuration对象。</p>\n<p><strong>设置共享变量</strong>，是为所有模板所定义的变量。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cfg.setSharedVariable(String name,Object obj);</div></pre></td></tr></table></figure></p>\n<p>比如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Configuration cfg = <span class=\"keyword\">new</span> Configuration();</div><div class=\"line\">...</div><div class=\"line\">cfg.setSahredVariable(<span class=\"string\">\"wrap\"</span>, <span class=\"keyword\">new</span> WrapDirective());</div><div class=\"line\"><span class=\"comment\">// 使用 ObjectWrapper.DEFAULT_WRAPPER </span></div><div class=\"line\">cfg.setSharedVariable(<span class=\"string\">\"company\"</span>, <span class=\"string\">\"Foo Inc.\"</span>);</div></pre></td></tr></table></figure></p>\n<p>上面这段代码表示：<br>在所有使用这个配置的模板中，名为wrap的用户自定义指令。<br>一个名为company的字符串将会在数据模型的根上可见，这样就不用在根哈希表上一次又一次的添加它们。在传递给Template.process根对象里的变量将会隐藏同名的共享变量。<br>警告：如果配置对象在多线程环境中使用，不要使用TemplateModel实现类来作为共享变量，因为它是线程不安全的。这也是基于Servlet的Web站点的典型情况。</p>\n<p><strong>配置设置</strong><br>配置设置有很多， 例如：locale，number_format，default_encoding， template_exception_handler。<br>比如说设置编码格式:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cfg.setDefaultEncoding(<span class=\"string\">\"UTF-8\"</span>);</div></pre></td></tr></table></figure></p>\n<p>那么使用该配置的所有模板的编码格式都是UTF-8。<br>配置信息可以被想象成3层(Configuration， Template，Environment)，最高层包含特定的值，它为设置信息提供最有效的值。 比如(设置信息A到F仅仅是为这个示例而构想的)：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">Setting A</th>\n<th style=\"text-align:center\">Setting B</th>\n<th style=\"text-align:center\">Setting C</th>\n<th style=\"text-align:center\">Setting D</th>\n<th style=\"text-align:center\">Setting E</th>\n<th>Setting F</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Layer 3: Environment</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">-</td>\n<td>-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Layer 2: Template</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">2</td>\n<td>-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Layer 1: Configuration</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">-</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<p>配置信息的有效值为：A=1，B=2，C=3，D=1，E=2。 而F的设置则是null，或者在你获取它的时候将抛出异常。</p>\n<ul>\n<li><p>Configuration 层： 原则上设置配置信息时使用 Configuration 对象的setter方法，例如：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Configuration myCfg = <span class=\"keyword\">new</span> Configuration(Configuration.VERSION_2_3_23);</div><div class=\"line\">myCfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);</div><div class=\"line\">myCfg.setDefaultEncoding(<span class=\"string\">\"UTF-8\"</span>);</div></pre></td></tr></table></figure>\n<p> 在真正使用 Configuration 对象 (通常在初始化应用程序时)之前来配置它，后面必须将其视为只读的对象。</p>\n</li>\n<li><p>Template层：对于被请求的本地化信息，也就是模板的locale 设置，它由Configuration.getTemplate(…) 来设置。但是如果我们想控制Template对象来代替freemarker.cache.TemplateCache的话，就应该在Template对象第一次被使用前就设置配置信息，然后就将Template对象视为是只读的。</p>\n</li>\n<li><p>Environment 层：这里有两种配置方法：<br> 一是使用Java API：使用 Environment对象的setter方法。当然这需要在模板执行之前来做。但是我们如果直接调用myTemplate.process(…) 就会遇到问题，因为在内部创建Environment对象后立即就执行模板了，导致没有机会来进行设置。这个问题的解决可以用下面两个步骤进行：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Environment env = myTemplate.createProcessingEnvironment(root, out);</div><div class=\"line\">env.setLocale(java.util.Locale.ITALY); </div><div class=\"line\">env.setNumberFormat(<span class=\"string\">\"0.####\"</span>);</div><div class=\"line\">env.process();  <span class=\"comment\">// process the template</span></div></pre></td></tr></table></figure>\n<p> 二是在模板中直接使用setting指令，但是这种方法并不推荐，例如：</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;#setting locale=\"it_IT\"&gt;</div><div class=\"line\">&lt;#setting number_format=\"0.####\"&gt;</div></pre></td></tr></table></figure>\n<p> 在Environment层中，什么时候改变配置信息是没有限制的。</p>\n</li>\n</ul>\n<p><strong>模板加载</strong><br>模板加载器加载基于抽象模板路径下的比如 “index.ftl” 或 “products/catalog.ftl”的原生文本数据对象。加载完毕之后，它会解析文本来生成模板。</p>\n<ul>\n<li><p>内建模板加载器：<br> 在 Configuration 中可以使用下面的方法来建立三种不同的模板加载器。 (每种方法都会在其内部新建一个模板加载器对象，然后创建 Configuration 实例来使用它。)</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setDirectoryForTemplateLoading</span><span class=\"params\">(File dir)</span></span>;</div></pre></td></tr></table></figure>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setClassForTemplateLoading</span><span class=\"params\">(Class cl, String prefix)</span></span>;</div></pre></td></tr></table></figure>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setServletContextForTemplateLoading</span><span class=\"params\">(Object servletContext, String path)</span></span>;</div></pre></td></tr></table></figure>\n<p> 上述的第一种方法在磁盘的文件系统上设置了一个明确的目录， 它确定了从哪里加载模板。<br> 第二种调用方法的参数是一个类和一个路径前缀，参数prefix是给模板的名称来加前缀的，其实就是文件相对于给定类的路径。这个方法顾名思义就是通过获得给定类的相对位置以及之后的prefix参数来获得template文件。这样方便我们将template文件一起打成jar包使用。经验之谈，这里prefix必须以“/”开头。<br> 第三种调用方式需要Web应用的上下文和一个基路径作为参数，这个基路径是Web应用根路径(WEB-INF目录的上级目录)的相对路径。加载器会从Web应用目录开始加载模板。而且加载方法对没有打包的.war文件也起作用，因为它使用了ServletContext.getResource()方法来访问模板。比如： setServletContextForTemplateLoading(context, “/ftl”) 就是 /WebRoot/ftl目录。</p>\n</li>\n<li><p>从多个位置加载模板:<br> 如果需要从多个位置加载模板，那就不得不为每个位置都实例化模板加载器对象，将他们封装成一个MultiTemplateLoader的特殊模板加载器，最终传给Configuration对象的setTemplateLoader(TemplateLoader loader)方法。如从/user/data/templates和/temp/templates两个地方加载模板可以这么做：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">FileTemplateLoader ftl1 = <span class=\"keyword\">new</span> FileTemplateLoader(<span class=\"keyword\">new</span> File(<span class=\"string\">\"/temp/templates\"</span>));  </div><div class=\"line\">FileTemplateLoader ftl2 = <span class=\"keyword\">new</span> FileTemplateLoader(<span class=\"keyword\">new</span> File(<span class=\"string\">\"/user/data/templates\"</span>));  </div><div class=\"line\">ClassTemplateLoader ctl1 = <span class=\"keyword\">new</span> ClassTemplateLoader(TemplateLoaderTest.class, <span class=\"string\">\"/\"</span>);  </div><div class=\"line\">TemplateLoader[] loaders = <span class=\"keyword\">new</span> TemplateLoader[]&#123;ftl1, ftl2, ctl1&#125;;  </div><div class=\"line\">MultiTemplateLoader mtl = <span class=\"keyword\">new</span> MultiTemplateLoader(loaders);  </div><div class=\"line\">cfg.setTemplateLoader(mtl);</div></pre></td></tr></table></figure>\n<p> 现在，FreeMarker将会尝试从 /tmp/templates目录加载模板，如果在这个目录下没有发现请求的模板，它就会继续尝试从/usr/data/templates 目录下加载，如果还是没有发现请求的模板， 那么它就会使用类加载器来加载模板。</p>\n</li>\n<li><p>从其他资源加载模板<br>如果内建的类加载器都不适合使用，那么就需要来编写自己的类加载器了，这个类需要实现freemarker.cache.TemplateLoader接口，然后将它传递给Configuration对象的setTemplateLoader(TemplateLoader loader)方法。可以阅读API JavaDoc文档获取更多信息。如果模板需要通过URL访问其他模板，那么就不需要实现TemplateLoader接口了，可以选择子接口freemarker.cache.URLTemplateLoader来替代，只需实现URLgetURL(String templateName)方法即可。</p>\n</li>\n</ul>\n<p>完整的FreeMaker学习资料：<a href=\"https://github.com/yuchengxin/FreeMarker_2.3.23_Manual_zh_CN.git\">FreeMarker_2.3.23_Manual_zh_CN</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>FreeMaker是一个模板引擎，它基于模板和数据来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)。也就是说它可以生成文件，而这些文件的格式是我们指定好的格式。文件中的内容是通过插值来填充的。也就是所谓的模板+数据=输出。</p>\n<p>首先来看看FreeMarker模板文件，它是以.ftl为后缀的文件，主要由如下4个部分组成:<br>1.文本:直接输出的部分<br>2.注释:&lt;#– … –&gt;格式部分,不会输出<br>3.插值:即${…}或#{…}格式的部分,将使用数据模型中的部分替代输出<br>4.FTL指令:FreeMarker指定,和HTML标记类似,名字前加#予以区分,不会输出</p>\n<p>具体编程的话，在Java中，为了使用FreeMarker将数据模型中的值合并到从模板文件生成的模板中,可按如下步骤进行:<br>1.<strong>创建配置实例</strong>：首先，创建一个Configuration的实例，然后调整它的设置。Configuration实例是存储FreeMarker应用级设置的核心部分。同时，它也处理那些创建和缓存预解析模板的工作。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Configuration cfg = <span class=\"keyword\">new</span> Configuration(Configuration.VERSION_2_3_22); </div><div class=\"line\"><span class=\"comment\">// 指定模板文件从何处加载的数据源，这里设置成一个文件目录。 </span></div><div class=\"line\">cfg.setDirectoryForTemplateLoading(<span class=\"keyword\">new</span> File(<span class=\"string\">\"/where/you/store/templates\"</span>)); </div><div class=\"line\"><span class=\"comment\">// 指定模板如何检索数据模型，后面会讲到，先可以这么来用： </span></div><div class=\"line\">cfg.setObjectWrapper(<span class=\"keyword\">new</span> DefaultObjectWrapper()); </div><div class=\"line\"><span class=\"comment\">//指定异常处理句柄</span></div><div class=\"line\">cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);</div><div class=\"line\"><span class=\"comment\">//指定默认的编码格式</span></div><div class=\"line\">cfg.setDefaultEncoding(<span class=\"string\">\"UTF-8\"</span>);</div></pre></td></tr></table></figure></p>\n<p>这些工作只在应用(可能是servlet)生命周期的开始执行一次。<br>2.<strong>创建数据模型</strong>：<br>比如这样一个数据模型:<br>(root)<br>  |<br>  +- user = “Big Joe”<br>  |<br>  +- latest Product<br>  　　|<br>  　　+- url = “products/greenmouse.html”<br>  　　|<br>  　　+- name = “green mouse”<br>用java来构建：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建根哈希表 </span></div><div class=\"line\">Map root = <span class=\"keyword\">new</span> HashMap(); </div><div class=\"line\"><span class=\"comment\">// 在根中放入字符串\"user\" </span></div><div class=\"line\">root.put(<span class=\"string\">\"user\"</span>, <span class=\"string\">\"Big Joe\"</span>); </div><div class=\"line\"><span class=\"comment\">// 为\"latestProduct\"创建哈希表 </span></div><div class=\"line\">Map latest = <span class=\"keyword\">new</span> HashMap(); </div><div class=\"line\"><span class=\"comment\">// 将它添加到根哈希表中 </span></div><div class=\"line\">root.put(<span class=\"string\">\"latestProduct\"</span>, latest); </div><div class=\"line\"><span class=\"comment\">// 在 latest 中放置\"url\"和\"name\"  </span></div><div class=\"line\">latest.put(<span class=\"string\">\"url\"</span>, <span class=\"string\">\"products/greenmouse.html\"</span>); </div><div class=\"line\">latest.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"green mouse\"</span>);</div></pre></td></tr></table></figure></p>\n<p>现在root就是要填充到模板template中的数据了。<br>3.<strong>获得模板</strong><br>现在有一个模板文件：test.ftl，存放在之前设置的目录中。test.ftl文件中的内容(即模板)如下：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span> </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Welcome!<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span> </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Welcome $&#123;user&#125;!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span> </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Our latestproduct:<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"$&#123;latestProduct.url&#125;\"</span>&gt;</span>$&#123;latestProduct.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span>! </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>在程序中我们可以用freemarker.template.Template来临时存储模板的格式，当我们需要一个模板实例的时候，就可以使用Configuration的getTemplate方法来获取。在之前设置的目录中，我们用test.ftl存储了示例模板，那么就可以这样来做：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Template temp = cfg.getTemplate(<span class=\"string\">\"test.ftl\"</span>);</div></pre></td></tr></table></figure></p>\n<p>当调用这个方法的时候，将会创建一个Template实例,它是test.ftl文件经过读取和解析（编译）之后创建的模板实例。Template实例以解析后的形式存储模板，而不是以源文件的文本形式。<br>4.<strong>合并模板和数据模型</strong><br>我们都已经知道：数据模型+模板=输出，现在我们已经有了一个数据模型root和一个模板temp了，所以为了得到输出就需要合并它们。这是由模板的process方法完成的。它用数据模型root和Writer对象作为参数，然后向<br>Writer对象写入产生的内容。为简单起见，这里我们只做标准的输出：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Writer out = <span class=\"keyword\">new</span> OutputStreamWriter(System.out); </div><div class=\"line\">temp.process(root, out); </div><div class=\"line\">out.flush();</div></pre></td></tr></table></figure></p>\n<p>上面的代码会向你的终端以数据模板的格式输出数据模型的数据。<br>完整的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> freemarker.template.*; </div><div class=\"line\"><span class=\"keyword\">import</span> java.util.*; </div><div class=\"line\"><span class=\"keyword\">import</span> java.io.*; </div><div class=\"line\"><span class=\"keyword\">public</span> classTest &#123; </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123; </div><div class=\"line\">        <span class=\"comment\">/* 在整个应用的生命周期中，这个工作你应该只做一次。 */</span>  </div><div class=\"line\">        <span class=\"comment\">/* 创建和调整配置。 */</span> </div><div class=\"line\">        Configuration cfg = <span class=\"keyword\">new</span> Configuration(); </div><div class=\"line\">        cfg.setDirectoryForTemplateLoading(<span class=\"keyword\">new</span> File(<span class=\"string\">\"/where/you/store/templates\"</span>)); </div><div class=\"line\">        cfg.setObjectWrapper(<span class=\"keyword\">new</span> DefaultObjectWrapper()); </div><div class=\"line\">       </div><div class=\"line\">        <span class=\"comment\">/* 在整个应用的生命周期中，这个工作你可以执行多次 */</span>  </div><div class=\"line\">        <span class=\"comment\">/* 获取或创建模板*/</span> </div><div class=\"line\">        Template temp = cfg.getTemplate(<span class=\"string\">\"test.ftl\"</span>); </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">/* 创建数据模型 */</span> </div><div class=\"line\">        Map root = <span class=\"keyword\">new</span> HashMap(); </div><div class=\"line\">        root.put(<span class=\"string\">\"user\"</span>, <span class=\"string\">\"Big Joe\"</span>); </div><div class=\"line\">        Map latest = <span class=\"keyword\">new</span> HashMap(); </div><div class=\"line\">        root.put(<span class=\"string\">\"latestProduct\"</span>, latest); </div><div class=\"line\">        latest.put(<span class=\"string\">\"url\"</span>, <span class=\"string\">\"products/greenmouse.html\"</span>); </div><div class=\"line\">        latest.put(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"green mouse\"</span>); </div><div class=\"line\">       </div><div class=\"line\">        <span class=\"comment\">/* 将模板和数据模型合并 */</span> </div><div class=\"line\">        Writer out = <span class=\"keyword\">new</span> OutputStreamWriter(System.out);</div><div class=\"line\">        temp.process(root, out); </div><div class=\"line\">        out.flush(); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面已经讲了基本用法，现在进行更深入的理解：</p>\n<h2 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"Configuration\"></a><strong>Configuration</strong></h2><p>Configuration存储了常用(全局，应用程序级)的设置，定义了想要在所有模板中可用的变量(称为共享变量)。 而且，它会处理 Template 实例的新建和缓存。通常使用一个共享的单实例Configuration对象。</p>\n<p><strong>设置共享变量</strong>，是为所有模板所定义的变量。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cfg.setSharedVariable(String name,Object obj);</div></pre></td></tr></table></figure></p>\n<p>比如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Configuration cfg = <span class=\"keyword\">new</span> Configuration();</div><div class=\"line\">...</div><div class=\"line\">cfg.setSahredVariable(<span class=\"string\">\"wrap\"</span>, <span class=\"keyword\">new</span> WrapDirective());</div><div class=\"line\"><span class=\"comment\">// 使用 ObjectWrapper.DEFAULT_WRAPPER </span></div><div class=\"line\">cfg.setSharedVariable(<span class=\"string\">\"company\"</span>, <span class=\"string\">\"Foo Inc.\"</span>);</div></pre></td></tr></table></figure></p>\n<p>上面这段代码表示：<br>在所有使用这个配置的模板中，名为wrap的用户自定义指令。<br>一个名为company的字符串将会在数据模型的根上可见，这样就不用在根哈希表上一次又一次的添加它们。在传递给Template.process根对象里的变量将会隐藏同名的共享变量。<br>警告：如果配置对象在多线程环境中使用，不要使用TemplateModel实现类来作为共享变量，因为它是线程不安全的。这也是基于Servlet的Web站点的典型情况。</p>\n<p><strong>配置设置</strong><br>配置设置有很多， 例如：locale，number_format，default_encoding， template_exception_handler。<br>比如说设置编码格式:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cfg.setDefaultEncoding(<span class=\"string\">\"UTF-8\"</span>);</div></pre></td></tr></table></figure></p>\n<p>那么使用该配置的所有模板的编码格式都是UTF-8。<br>配置信息可以被想象成3层(Configuration， Template，Environment)，最高层包含特定的值，它为设置信息提供最有效的值。 比如(设置信息A到F仅仅是为这个示例而构想的)：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">Setting A</th>\n<th style=\"text-align:center\">Setting B</th>\n<th style=\"text-align:center\">Setting C</th>\n<th style=\"text-align:center\">Setting D</th>\n<th style=\"text-align:center\">Setting E</th>\n<th>Setting F</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Layer 3: Environment</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">-</td>\n<td>-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Layer 2: Template</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">2</td>\n<td>-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Layer 1: Configuration</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">-</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<p>配置信息的有效值为：A=1，B=2，C=3，D=1，E=2。 而F的设置则是null，或者在你获取它的时候将抛出异常。</p>\n<ul>\n<li><p>Configuration 层： 原则上设置配置信息时使用 Configuration 对象的setter方法，例如：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Configuration myCfg = <span class=\"keyword\">new</span> Configuration(Configuration.VERSION_2_3_23);</div><div class=\"line\">myCfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);</div><div class=\"line\">myCfg.setDefaultEncoding(<span class=\"string\">\"UTF-8\"</span>);</div></pre></td></tr></table></figure>\n<p> 在真正使用 Configuration 对象 (通常在初始化应用程序时)之前来配置它，后面必须将其视为只读的对象。</p>\n</li>\n<li><p>Template层：对于被请求的本地化信息，也就是模板的locale 设置，它由Configuration.getTemplate(…) 来设置。但是如果我们想控制Template对象来代替freemarker.cache.TemplateCache的话，就应该在Template对象第一次被使用前就设置配置信息，然后就将Template对象视为是只读的。</p>\n</li>\n<li><p>Environment 层：这里有两种配置方法：<br> 一是使用Java API：使用 Environment对象的setter方法。当然这需要在模板执行之前来做。但是我们如果直接调用myTemplate.process(…) 就会遇到问题，因为在内部创建Environment对象后立即就执行模板了，导致没有机会来进行设置。这个问题的解决可以用下面两个步骤进行：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Environment env = myTemplate.createProcessingEnvironment(root, out);</div><div class=\"line\">env.setLocale(java.util.Locale.ITALY); </div><div class=\"line\">env.setNumberFormat(<span class=\"string\">\"0.####\"</span>);</div><div class=\"line\">env.process();  <span class=\"comment\">// process the template</span></div></pre></td></tr></table></figure>\n<p> 二是在模板中直接使用setting指令，但是这种方法并不推荐，例如：</p>\n <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;#setting locale=\"it_IT\"&gt;</div><div class=\"line\">&lt;#setting number_format=\"0.####\"&gt;</div></pre></td></tr></table></figure>\n<p> 在Environment层中，什么时候改变配置信息是没有限制的。</p>\n</li>\n</ul>\n<p><strong>模板加载</strong><br>模板加载器加载基于抽象模板路径下的比如 “index.ftl” 或 “products/catalog.ftl”的原生文本数据对象。加载完毕之后，它会解析文本来生成模板。</p>\n<ul>\n<li><p>内建模板加载器：<br> 在 Configuration 中可以使用下面的方法来建立三种不同的模板加载器。 (每种方法都会在其内部新建一个模板加载器对象，然后创建 Configuration 实例来使用它。)</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setDirectoryForTemplateLoading</span><span class=\"params\">(File dir)</span></span>;</div></pre></td></tr></table></figure>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setClassForTemplateLoading</span><span class=\"params\">(Class cl, String prefix)</span></span>;</div></pre></td></tr></table></figure>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setServletContextForTemplateLoading</span><span class=\"params\">(Object servletContext, String path)</span></span>;</div></pre></td></tr></table></figure>\n<p> 上述的第一种方法在磁盘的文件系统上设置了一个明确的目录， 它确定了从哪里加载模板。<br> 第二种调用方法的参数是一个类和一个路径前缀，参数prefix是给模板的名称来加前缀的，其实就是文件相对于给定类的路径。这个方法顾名思义就是通过获得给定类的相对位置以及之后的prefix参数来获得template文件。这样方便我们将template文件一起打成jar包使用。经验之谈，这里prefix必须以“/”开头。<br> 第三种调用方式需要Web应用的上下文和一个基路径作为参数，这个基路径是Web应用根路径(WEB-INF目录的上级目录)的相对路径。加载器会从Web应用目录开始加载模板。而且加载方法对没有打包的.war文件也起作用，因为它使用了ServletContext.getResource()方法来访问模板。比如： setServletContextForTemplateLoading(context, “/ftl”) 就是 /WebRoot/ftl目录。</p>\n</li>\n<li><p>从多个位置加载模板:<br> 如果需要从多个位置加载模板，那就不得不为每个位置都实例化模板加载器对象，将他们封装成一个MultiTemplateLoader的特殊模板加载器，最终传给Configuration对象的setTemplateLoader(TemplateLoader loader)方法。如从/user/data/templates和/temp/templates两个地方加载模板可以这么做：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">FileTemplateLoader ftl1 = <span class=\"keyword\">new</span> FileTemplateLoader(<span class=\"keyword\">new</span> File(<span class=\"string\">\"/temp/templates\"</span>));  </div><div class=\"line\">FileTemplateLoader ftl2 = <span class=\"keyword\">new</span> FileTemplateLoader(<span class=\"keyword\">new</span> File(<span class=\"string\">\"/user/data/templates\"</span>));  </div><div class=\"line\">ClassTemplateLoader ctl1 = <span class=\"keyword\">new</span> ClassTemplateLoader(TemplateLoaderTest.class, <span class=\"string\">\"/\"</span>);  </div><div class=\"line\">TemplateLoader[] loaders = <span class=\"keyword\">new</span> TemplateLoader[]&#123;ftl1, ftl2, ctl1&#125;;  </div><div class=\"line\">MultiTemplateLoader mtl = <span class=\"keyword\">new</span> MultiTemplateLoader(loaders);  </div><div class=\"line\">cfg.setTemplateLoader(mtl);</div></pre></td></tr></table></figure>\n<p> 现在，FreeMarker将会尝试从 /tmp/templates目录加载模板，如果在这个目录下没有发现请求的模板，它就会继续尝试从/usr/data/templates 目录下加载，如果还是没有发现请求的模板， 那么它就会使用类加载器来加载模板。</p>\n</li>\n<li><p>从其他资源加载模板<br>如果内建的类加载器都不适合使用，那么就需要来编写自己的类加载器了，这个类需要实现freemarker.cache.TemplateLoader接口，然后将它传递给Configuration对象的setTemplateLoader(TemplateLoader loader)方法。可以阅读API JavaDoc文档获取更多信息。如果模板需要通过URL访问其他模板，那么就不需要实现TemplateLoader接口了，可以选择子接口freemarker.cache.URLTemplateLoader来替代，只需实现URLgetURL(String templateName)方法即可。</p>\n</li>\n</ul>\n<p>完整的FreeMaker学习资料：<a href=\"https://github.com/yuchengxin/FreeMarker_2.3.23_Manual_zh_CN.git\">FreeMarker_2.3.23_Manual_zh_CN</a></p>\n"},{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">Effective Java 用私有构造器或者枚举类型强化Singleton属性（单例类型）</font>","date":"2017-07-17T01:43:37.000Z","_content":"\nSingleton指仅仅被实例化一次的类。Singleton通常用来代表那些本质上唯一的系统组件。实现Singleton有多种方法。但是一般的思路都是把构造器保持为私有的，并导出公有的静态成员，以便允许客户端能够访问该类的唯一实例。第一种常见思路：\n\n```java\n//Singleton with public final field\npublic class Elvis {\n\tpublic static final Elvis INSTANCE = new Elvis();\n\n\tprivate Elvis() {\n\t    ...\n\t}\n\n\tpublic void leaveTheBuilding() {\n\t\t...\n\t}\n}\n```\n在这种思路中，共有静态成员是个final域，私有构造器仅被调用一次，用来实例化公有的静态final域Elvies.INSTANCE。由于缺少共有的或者受保护的构造器，所以保证了Elvies的全局唯一性:一旦Elvis类被实例化，只会存在一个Elvis实例。客户端的任何行为都不会改变这一点，但要注意的是享有特权的客户端可以借助AccessibleObject.setAccessible方法，通过反射机制调用私有构造器。如果需要抵御这种攻击，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。使用：\n\n```java\n// This code would normally appear outside the class!\npublic static void main(String[] args) {\n\tElvis elvis = Elvis.INSTANCE;\n\telvis.leaveTheBuilding();\n}\n```\n第二种实现思路中，共有的成员是个静态工厂方法：\n\n```java\npublic class Elvis {\n\tprivate static final Elvis INSTANCE = new Elvis();\n\n\tprivate Elvis() {\n\t    ...\n\t}\n\n\tpublic static Elvis getInstance() {\n\t\treturn INSTANCE;\n\t}\n\n\tpublic void leaveTheBuilding() {\n\t\t...\n\t}\n}\n```\n对于静态方法Elvis.getInstance的所有调用，都会返回同一个对象引用，所以永远不会创建其他的Elvis实例，但是同样可以通过反射机制来调用私有构造器。\n\n共有域方法的主要好处在于组成类的成员的声明很清楚地表明了这个类是一个Singleton;公有的静态域是final的，所以该域将总是包含相同的对象引用。\n\n为了使 用上述两种方法实现的Singleton类变成是可序列化的，仅仅实现Serializable是不够的。为了维护并保证Singleton，必须声明所有实例域都是瞬时（transient）的，并提供一个readResolve方法。否则，每次反序列化一个序列化的实例时都会创建一个新的实例。为了防止这种情况，要在Elvies类中加入下面这个readResovle方法：\n\n```java\npublic class Elvis implements Serializable {\n\tpublic static final Elvis INSTANCE = new Elvis();\n\n\tprivate Elvis() {\n\t}\n\n\tpublic void leaveTheBuilding() {\n\t\tSystem.out.println(\"Whoa baby, I'm outta here!\");\n\t}\n\n\tprivate Object readResolve() {\n\t\t// Return the one true Elvis and let the garbage collector\n\t\t// take care of the Elvis impersonator.\n\t\treturn INSTANCE;\n\t}\n\n\t// This code would normally appear outside the class!\n\tpublic static void main(String[] args) {\n\t\tElvis elvis = Elvis.INSTANCE;\n\t\telvis.leaveTheBuilding();\n\t}\n}\n```\n从Java 1.5之后，实现Singeton还有第三种方法。只需编写一个包含单个元素的枚举类型：\n\n```java\npublic enum Elvis {\n\tINSTANCE;\n\n\tpublic void leaveTheBuilding() {\n\t\tSystem.out.println(\"Whoa baby, I'm outta here!\");\n\t}\n\n\t// This code would normally appear outside the class!\n\tpublic static void main(String[] args) {\n\t\tElvis elvis = Elvis.INSTANCE;\n\t\telvis.leaveTheBuilding();\n\t}\n}\n```\n这种方法在功能上与公有域方法相近，但是更加简洁，无偿地提供了序列化机制，绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。单元素的枚举类型已经成为实现Singleton的最佳方法。\n\n\n\n\n\n","source":"_posts/Effective Java 用私有构造器或者枚举类型强化Singlton属性（单例类型）.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">Effective Java 用私有构造器或者枚举类型强化Singleton属性（单例类型）</font>\ndate: 2017-07-17 09:43:37\ncategories: java读书笔记\ntags: [Java,经验之谈,高效开发,Singleton,单例模式]\n---\n\nSingleton指仅仅被实例化一次的类。Singleton通常用来代表那些本质上唯一的系统组件。实现Singleton有多种方法。但是一般的思路都是把构造器保持为私有的，并导出公有的静态成员，以便允许客户端能够访问该类的唯一实例。第一种常见思路：\n\n```java\n//Singleton with public final field\npublic class Elvis {\n\tpublic static final Elvis INSTANCE = new Elvis();\n\n\tprivate Elvis() {\n\t    ...\n\t}\n\n\tpublic void leaveTheBuilding() {\n\t\t...\n\t}\n}\n```\n在这种思路中，共有静态成员是个final域，私有构造器仅被调用一次，用来实例化公有的静态final域Elvies.INSTANCE。由于缺少共有的或者受保护的构造器，所以保证了Elvies的全局唯一性:一旦Elvis类被实例化，只会存在一个Elvis实例。客户端的任何行为都不会改变这一点，但要注意的是享有特权的客户端可以借助AccessibleObject.setAccessible方法，通过反射机制调用私有构造器。如果需要抵御这种攻击，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。使用：\n\n```java\n// This code would normally appear outside the class!\npublic static void main(String[] args) {\n\tElvis elvis = Elvis.INSTANCE;\n\telvis.leaveTheBuilding();\n}\n```\n第二种实现思路中，共有的成员是个静态工厂方法：\n\n```java\npublic class Elvis {\n\tprivate static final Elvis INSTANCE = new Elvis();\n\n\tprivate Elvis() {\n\t    ...\n\t}\n\n\tpublic static Elvis getInstance() {\n\t\treturn INSTANCE;\n\t}\n\n\tpublic void leaveTheBuilding() {\n\t\t...\n\t}\n}\n```\n对于静态方法Elvis.getInstance的所有调用，都会返回同一个对象引用，所以永远不会创建其他的Elvis实例，但是同样可以通过反射机制来调用私有构造器。\n\n共有域方法的主要好处在于组成类的成员的声明很清楚地表明了这个类是一个Singleton;公有的静态域是final的，所以该域将总是包含相同的对象引用。\n\n为了使 用上述两种方法实现的Singleton类变成是可序列化的，仅仅实现Serializable是不够的。为了维护并保证Singleton，必须声明所有实例域都是瞬时（transient）的，并提供一个readResolve方法。否则，每次反序列化一个序列化的实例时都会创建一个新的实例。为了防止这种情况，要在Elvies类中加入下面这个readResovle方法：\n\n```java\npublic class Elvis implements Serializable {\n\tpublic static final Elvis INSTANCE = new Elvis();\n\n\tprivate Elvis() {\n\t}\n\n\tpublic void leaveTheBuilding() {\n\t\tSystem.out.println(\"Whoa baby, I'm outta here!\");\n\t}\n\n\tprivate Object readResolve() {\n\t\t// Return the one true Elvis and let the garbage collector\n\t\t// take care of the Elvis impersonator.\n\t\treturn INSTANCE;\n\t}\n\n\t// This code would normally appear outside the class!\n\tpublic static void main(String[] args) {\n\t\tElvis elvis = Elvis.INSTANCE;\n\t\telvis.leaveTheBuilding();\n\t}\n}\n```\n从Java 1.5之后，实现Singeton还有第三种方法。只需编写一个包含单个元素的枚举类型：\n\n```java\npublic enum Elvis {\n\tINSTANCE;\n\n\tpublic void leaveTheBuilding() {\n\t\tSystem.out.println(\"Whoa baby, I'm outta here!\");\n\t}\n\n\t// This code would normally appear outside the class!\n\tpublic static void main(String[] args) {\n\t\tElvis elvis = Elvis.INSTANCE;\n\t\telvis.leaveTheBuilding();\n\t}\n}\n```\n这种方法在功能上与公有域方法相近，但是更加简洁，无偿地提供了序列化机制，绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。单元素的枚举类型已经成为实现Singleton的最佳方法。\n\n\n\n\n\n","slug":"Effective Java 用私有构造器或者枚举类型强化Singlton属性（单例类型）","published":1,"updated":"2017-07-17T01:49:17.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hsnzz0008asvlt9rpe2ys","content":"<p>Singleton指仅仅被实例化一次的类。Singleton通常用来代表那些本质上唯一的系统组件。实现Singleton有多种方法。但是一般的思路都是把构造器保持为私有的，并导出公有的静态成员，以便允许客户端能够访问该类的唯一实例。第一种常见思路：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Singleton with public final field</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t    ...</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">leaveTheBuilding</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这种思路中，共有静态成员是个final域，私有构造器仅被调用一次，用来实例化公有的静态final域Elvies.INSTANCE。由于缺少共有的或者受保护的构造器，所以保证了Elvies的全局唯一性:一旦Elvis类被实例化，只会存在一个Elvis实例。客户端的任何行为都不会改变这一点，但要注意的是享有特权的客户端可以借助AccessibleObject.setAccessible方法，通过反射机制调用私有构造器。如果需要抵御这种攻击，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// This code would normally appear outside the class!</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tElvis elvis = Elvis.INSTANCE;</div><div class=\"line\">\telvis.leaveTheBuilding();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第二种实现思路中，共有的成员是个静态工厂方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t    ...</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Elvis <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> INSTANCE;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">leaveTheBuilding</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于静态方法Elvis.getInstance的所有调用，都会返回同一个对象引用，所以永远不会创建其他的Elvis实例，但是同样可以通过反射机制来调用私有构造器。</p>\n<p>共有域方法的主要好处在于组成类的成员的声明很清楚地表明了这个类是一个Singleton;公有的静态域是final的，所以该域将总是包含相同的对象引用。</p>\n<p>为了使 用上述两种方法实现的Singleton类变成是可序列化的，仅仅实现Serializable是不够的。为了维护并保证Singleton，必须声明所有实例域都是瞬时（transient）的，并提供一个readResolve方法。否则，每次反序列化一个序列化的实例时都会创建一个新的实例。为了防止这种情况，要在Elvies类中加入下面这个readResovle方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">leaveTheBuilding</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"Whoa baby, I'm outta here!\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// Return the one true Elvis and let the garbage collector</span></div><div class=\"line\">\t\t<span class=\"comment\">// take care of the Elvis impersonator.</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> INSTANCE;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// This code would normally appear outside the class!</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tElvis elvis = Elvis.INSTANCE;</div><div class=\"line\">\t\telvis.leaveTheBuilding();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从Java 1.5之后，实现Singeton还有第三种方法。只需编写一个包含单个元素的枚举类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Elvis &#123;</div><div class=\"line\">\tINSTANCE;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">leaveTheBuilding</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"Whoa baby, I'm outta here!\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// This code would normally appear outside the class!</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tElvis elvis = Elvis.INSTANCE;</div><div class=\"line\">\t\telvis.leaveTheBuilding();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方法在功能上与公有域方法相近，但是更加简洁，无偿地提供了序列化机制，绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。单元素的枚举类型已经成为实现Singleton的最佳方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Singleton指仅仅被实例化一次的类。Singleton通常用来代表那些本质上唯一的系统组件。实现Singleton有多种方法。但是一般的思路都是把构造器保持为私有的，并导出公有的静态成员，以便允许客户端能够访问该类的唯一实例。第一种常见思路：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Singleton with public final field</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t    ...</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">leaveTheBuilding</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这种思路中，共有静态成员是个final域，私有构造器仅被调用一次，用来实例化公有的静态final域Elvies.INSTANCE。由于缺少共有的或者受保护的构造器，所以保证了Elvies的全局唯一性:一旦Elvis类被实例化，只会存在一个Elvis实例。客户端的任何行为都不会改变这一点，但要注意的是享有特权的客户端可以借助AccessibleObject.setAccessible方法，通过反射机制调用私有构造器。如果需要抵御这种攻击，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// This code would normally appear outside the class!</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\tElvis elvis = Elvis.INSTANCE;</div><div class=\"line\">\telvis.leaveTheBuilding();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第二种实现思路中，共有的成员是个静态工厂方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t    ...</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Elvis <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> INSTANCE;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">leaveTheBuilding</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t...</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于静态方法Elvis.getInstance的所有调用，都会返回同一个对象引用，所以永远不会创建其他的Elvis实例，但是同样可以通过反射机制来调用私有构造器。</p>\n<p>共有域方法的主要好处在于组成类的成员的声明很清楚地表明了这个类是一个Singleton;公有的静态域是final的，所以该域将总是包含相同的对象引用。</p>\n<p>为了使 用上述两种方法实现的Singleton类变成是可序列化的，仅仅实现Serializable是不够的。为了维护并保证Singleton，必须声明所有实例域都是瞬时（transient）的，并提供一个readResolve方法。否则，每次反序列化一个序列化的实例时都会创建一个新的实例。为了防止这种情况，要在Elvies类中加入下面这个readResovle方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Elvis</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Elvis INSTANCE = <span class=\"keyword\">new</span> Elvis();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Elvis</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">leaveTheBuilding</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"Whoa baby, I'm outta here!\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// Return the one true Elvis and let the garbage collector</span></div><div class=\"line\">\t\t<span class=\"comment\">// take care of the Elvis impersonator.</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> INSTANCE;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// This code would normally appear outside the class!</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tElvis elvis = Elvis.INSTANCE;</div><div class=\"line\">\t\telvis.leaveTheBuilding();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从Java 1.5之后，实现Singeton还有第三种方法。只需编写一个包含单个元素的枚举类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Elvis &#123;</div><div class=\"line\">\tINSTANCE;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">leaveTheBuilding</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"Whoa baby, I'm outta here!\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// This code would normally appear outside the class!</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">\t\tElvis elvis = Elvis.INSTANCE;</div><div class=\"line\">\t\telvis.leaveTheBuilding();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方法在功能上与公有域方法相近，但是更加简洁，无偿地提供了序列化机制，绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。单元素的枚举类型已经成为实现Singleton的最佳方法。</p>\n"},{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">Java线程池</font>","date":"2017-06-16T00:50:06.000Z","_content":"\n背景\n==========\n在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。\n\n所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。如何利用已有对象来服务就是一个需要解决的关键问题，其实这就是一些”池化资源”技术产生的原因。\n\n例如Android中常见到的很多通用组件一般都离不开”池”的概念，如各种图片加载库，网络请求库，即使Android的消息传递机制中的Meaasge当使用Meaasge.obtain()就是使用的Meaasge池中的对象，因此这个概念很重要。本文将介绍的线程池技术同样符合这一思想。\n\n线程池的优点:\n\n - 重用线程池中的线程,减少因对象创建,销毁所带来的性能开销;\n - 能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞;\n - 能够多线程进行简单的管理,使线程的使用简单、高效。\n\n线程池框架Executor\n===========\njava中的线程池是通过Executor框架实现的，Executor框架包括类：Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable和Future、FutureTask的使用等。\n![线程池框架](Java线程池/a.jpg)\n\n**Executor**: 所有线程池的接口,只有一个方法。\n```java\npublic interface Executor {\n    void execute(Runnable command);\n}\n```\n**ExecutorService**: 增加Executor的行为，是Executor实现类的最直接接口。\n**Executors**： 提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。\n**ThreadPoolExecutor**：线程池的具体实现类,一般用的各种线程池都是基于这个类实现的。\n构造方法如下:\n```java\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n                    TimeUnit unit, BlockingQueue<Runnable> workQueue) {\n \n    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n    Executors.defaultThreadFactory(), defaultHandler);\n \n}\n```\n其中各个参数的含义：\n\n 1. corePoolSize：线程池的核心线程数,默认情况下可以一直存活。可以设置allowCoreThreadTimeOut为True,此时 核心线程数就是0,就可以用keepAliveTime控制所有线程的超时时间。\n 2. maximumPoolSize：线程池允许的最大线程数;\n 3. keepAliveTime： 指的是空闲线程结束的超时时间;\n 4. unit ：是一个枚举，表示 keepAliveTime 的单位;\n 5. workQueue：表示存放任务的BlockingQueue<Runnable队列。\n 6. BlockingQueue:阻塞队列（BlockingQueue）是java.util.concurrent下的主要用来控制线程同步的工具。如果BlockQueue是空的,从BlockingQueue取东西的操作将会被阻断进入等待状态,直到BlockingQueue有数据才会被唤醒。同样,如果BlockingQueue是满的,任何试图往里存东西的操作也会被阻断进入等待状态,直到BlockingQueue里有空间才会被唤醒继续操作。具体的实现类有LinkedBlockingQueue,ArrayBlockingQueued,DelayQueue,PriorityBlockingQueue等。\n \n线程池的工作过程：\n=============\n线程池刚创建时，里面没有一个线程。任务放在阻塞队列中作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。\n当调用 execute() 方法添加一个任务时，线程池会做如下判断：\n\n 7. 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；\n 8. 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；\n 9. 如果这时候队列满了，而且正在运行的线程数量小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；\n 10. 如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会抛出异常RejectExecutionException。\n\n当一个线程完成任务时，它会从队列中取下一个任务来执行。\n当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。\n\n线程池的创建和使用\n===============\n线程池的生成：\n--------\n生成线程池采用了工具类Executors的静态方法，以下是几种常见的线程池。\n\n - SingleThreadExecutor：单个后台线程 (其缓冲队列是无界的)\n\n```java\n public static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService ( new ThreadPoolExecutor(1, 1,\n                              0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()));\n}\n```\n创建一个单线程的线程池。可以看到maximumPoolSize和corePoolSize都是1，这个线程池只有一个核心线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\n\n - FixedThreadPool：只有核心线程的线程池,大小固定 (其缓冲队列是无界的) 。\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,\n                            new LinkedBlockingQueue<Runnable>());\n}\n```\n创建固定大小的线程池。可以看到maximumPoolSize和corePoolSize相等，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。\n\n - CachedThreadPool：无界线程池，可以进行自动线程回收。\n \n```java\npublic static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0,Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n                            new SynchronousQueue<Runnable>());\n}\n```\n创建一个无界的线程池，可以看到corePoolSize是0，而maximumPoolSize是整型数的最大值。当任务数增加时，此线程池可以智能的添加新线程来处理任务，而如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。SynchronousQueue是一个是缓冲区为1的阻塞队列。\n\n - ScheduledThreadPool：核心线程池固定，大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\n```java\npublic static ExecutorService newScheduledThreadPool(int corePoolSize) {\n    return new ScheduledThreadPool(corePoolSize,Integer.MAX_VALUE,DEFAULT_KEEPALIVE_MILLIS,\n                                MILLISECONDS,new DelayedWorkQueue());\n}\n```\n创建一个周期性执行任务的线程池。如果闲置,非核心线程池会在DEFAULT_KEEPALIVEMILLIS时间内回收。DleayQueue是一个延迟阻塞队列，它实现了Delayed接口，只有达到指定延迟时间才能从里面取出数据，然后交由线程池中的线程去处理。\n\n - 定制自己的线程池：\n \n除此之外我们也可以定制自己的线程池：比如要实现一个优先级线程池，只需要把PriorityBlockingQueue作为参数传入到线程池中去:\n```java\npublic static ExecutorService newPriorityThreadPool(int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit, PriorityBlockingQueue<Runnable> workQueue){\n    return new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,\n                            workQueue);                                  \n}\n```\n所有任务都实现了Comparable和Runable接口，所以当无法直接向线程池中提交任务的时候，任务就会加入优先级阻塞队列PriorityBlockingQueue中去，PriorityBlockingQueue就会用Comparable接口中的compareTo方法来确定优先级。所以之后就会按优先级向线程池提交任务。但是注意，最开始的corePoolSize个任务由于是直接提交给线程池的，没有加入到PriorityBlockingQueue，所以是按提交顺序去执行而不是优先级。\n\n线程池提交任务的方法：\n-------------\n1、execute:\n```java\nExecutorService.execute(Runnable runable)；\n```\n2、submit:\n```java\nFutureTask task = ExecutorService.submit(Runnable runnable);\n\nFutureTask<T> task = ExecutorService.submit(Runnable runnable,T Result);\n \nFutureTask<T> task = ExecutorService.submit(Callable<T> callable);\n```\n可以去看一看submit方法是怎么实现的，下面列出了submit(Callable callable)的实现源码，submit(Runnable runnable)方法其实也是差不多的：\n```java\npublic <T> Future<T> submit(Callable<T> task) {\n    if (task == null) throw new NullPointerException();\n    FutureTask<T> ftask = newTaskFor(task);\n    execute(ftask);\n    return ftask;\n}\n```\n可以看出submit开启的是有返回结果的任务，会返回一个FutureTask对象，这样就能通过get()方法得到任务执行的结果。其实submit最终调用的也是execute(Runnable runable)，submit只是将Callable对象或Runnable封装成一个FutureTask对象，因为FutureTask是个Runnable，所以可以在execute中执行。\n\n线程池的实现原理：\n==================\n线程池的实现过程没有用到Synchronized关键字，用的都是volatile,Lock和同步(阻塞)队列,Atomic相关类，FutureTask等等，因为后者的性能更优。理解的过程可以很好的学习源码中并发控制的思想。在开篇提到过线程池的优点是可总结为以下三点：线程复用，控制最大并发数和管理线程这三点，下面从这三个方面入手：\n线程复用过程：\n----------\n理解线程复用原理首先应了解普通线程的生命周期（注意：是线程的生命周期，不是线程池的生命周期）：\n![线程生命周期](Java线程池/b.jpg)\n在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态。\n\n我们可以通过Thread类的new()方法来新建一个线程，这个过程是是初始化一些线程信息，如线程名，id,线程所属group等，可以认为只是个普通的对象。新建的线程处于新建状态，而通过调用Thread的start()后，Java虚拟机会为其创建方法调用栈和程序计数器，同时将hasBeenStarted为true,这是线程进入就绪状态，如果这之后再调用start方法就会有异常，所以整个生命周期中start()方法只调用一次。\n处于就绪状态的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。当线程获取cpu后，run()方法会被调用。注意，不要自己去调用Thread的run()方法，系统会自己去调用。之后线程会根据CPU的调度在就绪——运行——阻塞之间切换，直到run()方法结束或其他方式停止线程，进入dead状态。\n\n所以实现线程复用的原理应该就是要保持线程处于存活状态（就绪，运行或阻塞）。接下来来看下ThreadPoolExecutor是怎么实现线程复用的，在ThreadPoolExecutor类中有一个内部类Worker，主要就是这个Worker类来控制线程的复用。看下Worker类简化后的代码，这样方便理解：\n```java\nprivate final class Worker implements Runnable {\n \n    final Thread thread;\n     \n    Runnable firstTask;\n     \n    Worker(Runnable firstTask) {\n        this.firstTask = firstTask;\n        this.thread = getThreadFactory().newThread(this);\n    }\n     \n    public void run() {\n        runWorker(this);\n    }\n     \n    final void runWorker(Worker w) {\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n        while (task != null || (task = getTask()) != null){\n            task.run();\n        }\n    }\n    \n    private Runnable getTask() {\n        if(一些特殊情况) {\n            return null;\n        }\n        Runnable r = workQueue.take();\n        return r;\n    }\n \n}\n```\nWorker是一个实现Runnable接口的对象，同时拥有一个thread，这个thread就是要开启的线程，在调用worker构造方法新建Worker对象的同时会新建一个Thread对象，新建这个Tread对象的时候会将Worker自己作为参数传入进去，这样当Thread的start()方法调用时，线程进入就绪状态，之后获得cpu去运行的时候运行的实际上是Worker的run()方法，worker的run()方法会调用runWorker()方法,runWorker()中有个while循环，会一直从getTask()方法里得到Runnable对象(具体的任务)，然后调用这些Runable对象的run()方法(task.run())去顺序执行。可以看到getTask()方法中有一个workQueue，这个就是初始化TreadPoolExecutor时存放任务的BlockingQueue队列。这个队列中存放的都是将要执行的Runable任务。因为BlockingQueue是个阻塞队列，BlockingQueue.take()如果是空，则进入等待阻塞状态直到BlockingQueue中有新的对象加入时唤醒阻塞的线程。所以一般情况Tread的run()方法就不会结束，而是不断执行从workQueue里取得任务去执行，这就达到线程复用的原理了。\n\n控制最大并发数\n---------------\nRunnable对象是什么时候放入workQueue？Worker又是什么时候创建，Worker里的Thread的又是什么时候调用start()开启新线程来执行Worker的run()方法的呢？有上面的分析看出Worker里的runWorker()执行任务时是一个接一个，串行进行的，那并发是怎么体现的呢？\n\n这些是由ThreadPoolExecutor类中的execute()方法保证的，以下是简化后的代码：\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n\n     int c = ctl.get();\n    // 当前线程数 < corePoolSize\n    if (workerCountOf(c) < corePoolSize) {\n        // 直接启动新的线程。\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n\n    // 活动线程数 >= corePoolSize\n    // runState为RUNNING && 队列未满\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        // 再次检验是否为RUNNING状态\n        // 非RUNNING状态 则从workQueue中移除任务并拒绝\n        if (!isRunning(recheck) && remove(command))\n            reject(command);// 采用线程池指定的策略拒绝任务\n        // 两种情况：\n        // 1.非RUNNING状态拒绝新的任务\n        // 2.队列满了启动新的线程失败（workCount > maximumPoolSize）\n    } else if (!addWorker(command, false))\n        reject(command);\n}\n\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    int wc = workerCountOf(c);\n    if (wc >= (core ? corePoolSize : maximumPoolSize)) {\n        return false;\n    }\n    w = new Worker(firstTask);\n    final Thread t = w.thread;\n    t.start();\n}\n```\n根据代码再来看上面提到的线程池工作过程中的添加任务的情况：\n\n* 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；   \n* 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；\n* 如果这时候队列满了，而且正在运行的线程数量小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；\n* 如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会抛出异常RejectExecutionException；\n\n通过addWorker如果成功创建新的线程成功，则通过start()开启新线程，同时将firstTask作为这个Worker里的run()中执行的第一个任务。虽然每个Worker的任务是串行处理，但如果创建了多个Worker，因为共用一个workQueue，所以就会并行处理了。所以根据corePoolSize和maximumPoolSize来控制最大并发数。大致过程可用下图表示:\n![线程池添加任务过程](Java线程池/c.jpg)\n\n管理线程\n-------------\n通过线程池可以很好的管理线程的复用，控制并发数，以及销毁等过程,线程的复用和控制并发上面已经讲了，而线程的管理过程已经穿插在其中了，也很好理解。\n在ThreadPoolExecutor有个ctl的AtomicInteger变量。通过这一个变量保存了两个内容：\n\n * 所有线程的数量\n * 每个线程所处的状态\n\n其中低29位存线程数，高3位存runState，通过位运算来得到不同的值。\n```java\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n\n//得到线程的状态\nprivate static int runStateOf(int c) {\n    return c & ~CAPACITY;\n}\n\n//得到Worker的的数量\nprivate static int workerCountOf(int c) {\n    return c & CAPACITY;\n}\n\n// 判断线程是否在运行\nprivate static boolean isRunning(int c) {\n    return c < SHUTDOWN;\n}\n```\n这里主要通过shutdown()和shutdownNow()来分析线程池的关闭过程。这两个方法是关闭线程池的方法。首先线程池有五种状态来控制任务添加与执行。主要介绍以下三种：\n\n * RUNNING状态：线程池正常运行，可以接受新的任务并处理队列中的任务；\n * SHUTDOWN状态：不再接受新的任务，但是会执行队列中的任务；\n * STOP状态：不再接受新任务，不处理队列中的任务\n\nshutdown这个方法会将runState置为SHUTDOWN，会终止所有空闲的线程，而仍在工作的线程不受影响，所以队列中的任务仍会被执行，但是线程池不再接受新的任务。shutdownNow方法则将runState置为STOP。和shutdown方法的区别，这个方法会终止所有的线程，所以队列中的任务也不会被执行了，不过线程中正在执行的任务不会突然中断，而是执行完之后线程才会关闭。\n\n\n\n\n","source":"_posts/Java线程池.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">Java线程池</font>\ndate: 2017-06-16 08:50:06\ncategories: java多线程\ntags: [java,多线程,Executor,TreadPoolExecutor,ExecutorService]\n---\n\n背景\n==========\n在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。\n\n所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。如何利用已有对象来服务就是一个需要解决的关键问题，其实这就是一些”池化资源”技术产生的原因。\n\n例如Android中常见到的很多通用组件一般都离不开”池”的概念，如各种图片加载库，网络请求库，即使Android的消息传递机制中的Meaasge当使用Meaasge.obtain()就是使用的Meaasge池中的对象，因此这个概念很重要。本文将介绍的线程池技术同样符合这一思想。\n\n线程池的优点:\n\n - 重用线程池中的线程,减少因对象创建,销毁所带来的性能开销;\n - 能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞;\n - 能够多线程进行简单的管理,使线程的使用简单、高效。\n\n线程池框架Executor\n===========\njava中的线程池是通过Executor框架实现的，Executor框架包括类：Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable和Future、FutureTask的使用等。\n![线程池框架](Java线程池/a.jpg)\n\n**Executor**: 所有线程池的接口,只有一个方法。\n```java\npublic interface Executor {\n    void execute(Runnable command);\n}\n```\n**ExecutorService**: 增加Executor的行为，是Executor实现类的最直接接口。\n**Executors**： 提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。\n**ThreadPoolExecutor**：线程池的具体实现类,一般用的各种线程池都是基于这个类实现的。\n构造方法如下:\n```java\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, \n                    TimeUnit unit, BlockingQueue<Runnable> workQueue) {\n \n    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n    Executors.defaultThreadFactory(), defaultHandler);\n \n}\n```\n其中各个参数的含义：\n\n 1. corePoolSize：线程池的核心线程数,默认情况下可以一直存活。可以设置allowCoreThreadTimeOut为True,此时 核心线程数就是0,就可以用keepAliveTime控制所有线程的超时时间。\n 2. maximumPoolSize：线程池允许的最大线程数;\n 3. keepAliveTime： 指的是空闲线程结束的超时时间;\n 4. unit ：是一个枚举，表示 keepAliveTime 的单位;\n 5. workQueue：表示存放任务的BlockingQueue<Runnable队列。\n 6. BlockingQueue:阻塞队列（BlockingQueue）是java.util.concurrent下的主要用来控制线程同步的工具。如果BlockQueue是空的,从BlockingQueue取东西的操作将会被阻断进入等待状态,直到BlockingQueue有数据才会被唤醒。同样,如果BlockingQueue是满的,任何试图往里存东西的操作也会被阻断进入等待状态,直到BlockingQueue里有空间才会被唤醒继续操作。具体的实现类有LinkedBlockingQueue,ArrayBlockingQueued,DelayQueue,PriorityBlockingQueue等。\n \n线程池的工作过程：\n=============\n线程池刚创建时，里面没有一个线程。任务放在阻塞队列中作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。\n当调用 execute() 方法添加一个任务时，线程池会做如下判断：\n\n 7. 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；\n 8. 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；\n 9. 如果这时候队列满了，而且正在运行的线程数量小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；\n 10. 如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会抛出异常RejectExecutionException。\n\n当一个线程完成任务时，它会从队列中取下一个任务来执行。\n当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。\n\n线程池的创建和使用\n===============\n线程池的生成：\n--------\n生成线程池采用了工具类Executors的静态方法，以下是几种常见的线程池。\n\n - SingleThreadExecutor：单个后台线程 (其缓冲队列是无界的)\n\n```java\n public static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService ( new ThreadPoolExecutor(1, 1,\n                              0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()));\n}\n```\n创建一个单线程的线程池。可以看到maximumPoolSize和corePoolSize都是1，这个线程池只有一个核心线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\n\n - FixedThreadPool：只有核心线程的线程池,大小固定 (其缓冲队列是无界的) 。\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,\n                            new LinkedBlockingQueue<Runnable>());\n}\n```\n创建固定大小的线程池。可以看到maximumPoolSize和corePoolSize相等，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。\n\n - CachedThreadPool：无界线程池，可以进行自动线程回收。\n \n```java\npublic static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0,Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n                            new SynchronousQueue<Runnable>());\n}\n```\n创建一个无界的线程池，可以看到corePoolSize是0，而maximumPoolSize是整型数的最大值。当任务数增加时，此线程池可以智能的添加新线程来处理任务，而如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。SynchronousQueue是一个是缓冲区为1的阻塞队列。\n\n - ScheduledThreadPool：核心线程池固定，大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\n```java\npublic static ExecutorService newScheduledThreadPool(int corePoolSize) {\n    return new ScheduledThreadPool(corePoolSize,Integer.MAX_VALUE,DEFAULT_KEEPALIVE_MILLIS,\n                                MILLISECONDS,new DelayedWorkQueue());\n}\n```\n创建一个周期性执行任务的线程池。如果闲置,非核心线程池会在DEFAULT_KEEPALIVEMILLIS时间内回收。DleayQueue是一个延迟阻塞队列，它实现了Delayed接口，只有达到指定延迟时间才能从里面取出数据，然后交由线程池中的线程去处理。\n\n - 定制自己的线程池：\n \n除此之外我们也可以定制自己的线程池：比如要实现一个优先级线程池，只需要把PriorityBlockingQueue作为参数传入到线程池中去:\n```java\npublic static ExecutorService newPriorityThreadPool(int corePoolSize, int maximumPoolSize, \n            long keepAliveTime, TimeUnit unit, PriorityBlockingQueue<Runnable> workQueue){\n    return new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,\n                            workQueue);                                  \n}\n```\n所有任务都实现了Comparable和Runable接口，所以当无法直接向线程池中提交任务的时候，任务就会加入优先级阻塞队列PriorityBlockingQueue中去，PriorityBlockingQueue就会用Comparable接口中的compareTo方法来确定优先级。所以之后就会按优先级向线程池提交任务。但是注意，最开始的corePoolSize个任务由于是直接提交给线程池的，没有加入到PriorityBlockingQueue，所以是按提交顺序去执行而不是优先级。\n\n线程池提交任务的方法：\n-------------\n1、execute:\n```java\nExecutorService.execute(Runnable runable)；\n```\n2、submit:\n```java\nFutureTask task = ExecutorService.submit(Runnable runnable);\n\nFutureTask<T> task = ExecutorService.submit(Runnable runnable,T Result);\n \nFutureTask<T> task = ExecutorService.submit(Callable<T> callable);\n```\n可以去看一看submit方法是怎么实现的，下面列出了submit(Callable callable)的实现源码，submit(Runnable runnable)方法其实也是差不多的：\n```java\npublic <T> Future<T> submit(Callable<T> task) {\n    if (task == null) throw new NullPointerException();\n    FutureTask<T> ftask = newTaskFor(task);\n    execute(ftask);\n    return ftask;\n}\n```\n可以看出submit开启的是有返回结果的任务，会返回一个FutureTask对象，这样就能通过get()方法得到任务执行的结果。其实submit最终调用的也是execute(Runnable runable)，submit只是将Callable对象或Runnable封装成一个FutureTask对象，因为FutureTask是个Runnable，所以可以在execute中执行。\n\n线程池的实现原理：\n==================\n线程池的实现过程没有用到Synchronized关键字，用的都是volatile,Lock和同步(阻塞)队列,Atomic相关类，FutureTask等等，因为后者的性能更优。理解的过程可以很好的学习源码中并发控制的思想。在开篇提到过线程池的优点是可总结为以下三点：线程复用，控制最大并发数和管理线程这三点，下面从这三个方面入手：\n线程复用过程：\n----------\n理解线程复用原理首先应了解普通线程的生命周期（注意：是线程的生命周期，不是线程池的生命周期）：\n![线程生命周期](Java线程池/b.jpg)\n在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态。\n\n我们可以通过Thread类的new()方法来新建一个线程，这个过程是是初始化一些线程信息，如线程名，id,线程所属group等，可以认为只是个普通的对象。新建的线程处于新建状态，而通过调用Thread的start()后，Java虚拟机会为其创建方法调用栈和程序计数器，同时将hasBeenStarted为true,这是线程进入就绪状态，如果这之后再调用start方法就会有异常，所以整个生命周期中start()方法只调用一次。\n处于就绪状态的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。当线程获取cpu后，run()方法会被调用。注意，不要自己去调用Thread的run()方法，系统会自己去调用。之后线程会根据CPU的调度在就绪——运行——阻塞之间切换，直到run()方法结束或其他方式停止线程，进入dead状态。\n\n所以实现线程复用的原理应该就是要保持线程处于存活状态（就绪，运行或阻塞）。接下来来看下ThreadPoolExecutor是怎么实现线程复用的，在ThreadPoolExecutor类中有一个内部类Worker，主要就是这个Worker类来控制线程的复用。看下Worker类简化后的代码，这样方便理解：\n```java\nprivate final class Worker implements Runnable {\n \n    final Thread thread;\n     \n    Runnable firstTask;\n     \n    Worker(Runnable firstTask) {\n        this.firstTask = firstTask;\n        this.thread = getThreadFactory().newThread(this);\n    }\n     \n    public void run() {\n        runWorker(this);\n    }\n     \n    final void runWorker(Worker w) {\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n        while (task != null || (task = getTask()) != null){\n            task.run();\n        }\n    }\n    \n    private Runnable getTask() {\n        if(一些特殊情况) {\n            return null;\n        }\n        Runnable r = workQueue.take();\n        return r;\n    }\n \n}\n```\nWorker是一个实现Runnable接口的对象，同时拥有一个thread，这个thread就是要开启的线程，在调用worker构造方法新建Worker对象的同时会新建一个Thread对象，新建这个Tread对象的时候会将Worker自己作为参数传入进去，这样当Thread的start()方法调用时，线程进入就绪状态，之后获得cpu去运行的时候运行的实际上是Worker的run()方法，worker的run()方法会调用runWorker()方法,runWorker()中有个while循环，会一直从getTask()方法里得到Runnable对象(具体的任务)，然后调用这些Runable对象的run()方法(task.run())去顺序执行。可以看到getTask()方法中有一个workQueue，这个就是初始化TreadPoolExecutor时存放任务的BlockingQueue队列。这个队列中存放的都是将要执行的Runable任务。因为BlockingQueue是个阻塞队列，BlockingQueue.take()如果是空，则进入等待阻塞状态直到BlockingQueue中有新的对象加入时唤醒阻塞的线程。所以一般情况Tread的run()方法就不会结束，而是不断执行从workQueue里取得任务去执行，这就达到线程复用的原理了。\n\n控制最大并发数\n---------------\nRunnable对象是什么时候放入workQueue？Worker又是什么时候创建，Worker里的Thread的又是什么时候调用start()开启新线程来执行Worker的run()方法的呢？有上面的分析看出Worker里的runWorker()执行任务时是一个接一个，串行进行的，那并发是怎么体现的呢？\n\n这些是由ThreadPoolExecutor类中的execute()方法保证的，以下是简化后的代码：\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n\n     int c = ctl.get();\n    // 当前线程数 < corePoolSize\n    if (workerCountOf(c) < corePoolSize) {\n        // 直接启动新的线程。\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n\n    // 活动线程数 >= corePoolSize\n    // runState为RUNNING && 队列未满\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        // 再次检验是否为RUNNING状态\n        // 非RUNNING状态 则从workQueue中移除任务并拒绝\n        if (!isRunning(recheck) && remove(command))\n            reject(command);// 采用线程池指定的策略拒绝任务\n        // 两种情况：\n        // 1.非RUNNING状态拒绝新的任务\n        // 2.队列满了启动新的线程失败（workCount > maximumPoolSize）\n    } else if (!addWorker(command, false))\n        reject(command);\n}\n\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    int wc = workerCountOf(c);\n    if (wc >= (core ? corePoolSize : maximumPoolSize)) {\n        return false;\n    }\n    w = new Worker(firstTask);\n    final Thread t = w.thread;\n    t.start();\n}\n```\n根据代码再来看上面提到的线程池工作过程中的添加任务的情况：\n\n* 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；   \n* 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；\n* 如果这时候队列满了，而且正在运行的线程数量小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；\n* 如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会抛出异常RejectExecutionException；\n\n通过addWorker如果成功创建新的线程成功，则通过start()开启新线程，同时将firstTask作为这个Worker里的run()中执行的第一个任务。虽然每个Worker的任务是串行处理，但如果创建了多个Worker，因为共用一个workQueue，所以就会并行处理了。所以根据corePoolSize和maximumPoolSize来控制最大并发数。大致过程可用下图表示:\n![线程池添加任务过程](Java线程池/c.jpg)\n\n管理线程\n-------------\n通过线程池可以很好的管理线程的复用，控制并发数，以及销毁等过程,线程的复用和控制并发上面已经讲了，而线程的管理过程已经穿插在其中了，也很好理解。\n在ThreadPoolExecutor有个ctl的AtomicInteger变量。通过这一个变量保存了两个内容：\n\n * 所有线程的数量\n * 每个线程所处的状态\n\n其中低29位存线程数，高3位存runState，通过位运算来得到不同的值。\n```java\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n\n//得到线程的状态\nprivate static int runStateOf(int c) {\n    return c & ~CAPACITY;\n}\n\n//得到Worker的的数量\nprivate static int workerCountOf(int c) {\n    return c & CAPACITY;\n}\n\n// 判断线程是否在运行\nprivate static boolean isRunning(int c) {\n    return c < SHUTDOWN;\n}\n```\n这里主要通过shutdown()和shutdownNow()来分析线程池的关闭过程。这两个方法是关闭线程池的方法。首先线程池有五种状态来控制任务添加与执行。主要介绍以下三种：\n\n * RUNNING状态：线程池正常运行，可以接受新的任务并处理队列中的任务；\n * SHUTDOWN状态：不再接受新的任务，但是会执行队列中的任务；\n * STOP状态：不再接受新任务，不处理队列中的任务\n\nshutdown这个方法会将runState置为SHUTDOWN，会终止所有空闲的线程，而仍在工作的线程不受影响，所以队列中的任务仍会被执行，但是线程池不再接受新的任务。shutdownNow方法则将runState置为STOP。和shutdown方法的区别，这个方法会终止所有的线程，所以队列中的任务也不会被执行了，不过线程中正在执行的任务不会突然中断，而是执行完之后线程才会关闭。\n\n\n\n\n","slug":"Java线程池","published":1,"updated":"2017-07-12T01:49:54.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hsnzz0009asvlx098scwt","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。</p>\n<p>所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。如何利用已有对象来服务就是一个需要解决的关键问题，其实这就是一些”池化资源”技术产生的原因。</p>\n<p>例如Android中常见到的很多通用组件一般都离不开”池”的概念，如各种图片加载库，网络请求库，即使Android的消息传递机制中的Meaasge当使用Meaasge.obtain()就是使用的Meaasge池中的对象，因此这个概念很重要。本文将介绍的线程池技术同样符合这一思想。</p>\n<p>线程池的优点:</p>\n<ul>\n<li>重用线程池中的线程,减少因对象创建,销毁所带来的性能开销;</li>\n<li>能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞;</li>\n<li>能够多线程进行简单的管理,使线程的使用简单、高效。</li>\n</ul>\n<h1 id=\"线程池框架Executor\"><a href=\"#线程池框架Executor\" class=\"headerlink\" title=\"线程池框架Executor\"></a>线程池框架Executor</h1><p>java中的线程池是通过Executor框架实现的，Executor框架包括类：Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable和Future、FutureTask的使用等。<br><img src=\"/2017/06/16/Java线程池/a.jpg\" alt=\"线程池框架\"></p>\n<p><strong>Executor</strong>: 所有线程池的接口,只有一个方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>ExecutorService</strong>: 增加Executor的行为，是Executor实现类的最直接接口。<br><strong>Executors</strong>： 提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。<br><strong>ThreadPoolExecutor</strong>：线程池的具体实现类,一般用的各种线程池都是基于这个类实现的。<br>构造方法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize, <span class=\"keyword\">int</span> maximumPoolSize, <span class=\"keyword\">long</span> keepAliveTime, </span></span></div><div class=\"line\">                    TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class=\"line\">    Executors.defaultThreadFactory(), defaultHandler);</div><div class=\"line\"> </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中各个参数的含义：</p>\n<ol>\n<li>corePoolSize：线程池的核心线程数,默认情况下可以一直存活。可以设置allowCoreThreadTimeOut为True,此时 核心线程数就是0,就可以用keepAliveTime控制所有线程的超时时间。</li>\n<li>maximumPoolSize：线程池允许的最大线程数;</li>\n<li>keepAliveTime： 指的是空闲线程结束的超时时间;</li>\n<li>unit ：是一个枚举，表示 keepAliveTime 的单位;</li>\n<li>workQueue：表示存放任务的BlockingQueue&lt;Runnable队列。</li>\n<li>BlockingQueue:阻塞队列（BlockingQueue）是java.util.concurrent下的主要用来控制线程同步的工具。如果BlockQueue是空的,从BlockingQueue取东西的操作将会被阻断进入等待状态,直到BlockingQueue有数据才会被唤醒。同样,如果BlockingQueue是满的,任何试图往里存东西的操作也会被阻断进入等待状态,直到BlockingQueue里有空间才会被唤醒继续操作。具体的实现类有LinkedBlockingQueue,ArrayBlockingQueued,DelayQueue,PriorityBlockingQueue等。</li>\n</ol>\n<h1 id=\"线程池的工作过程：\"><a href=\"#线程池的工作过程：\" class=\"headerlink\" title=\"线程池的工作过程：\"></a>线程池的工作过程：</h1><p>线程池刚创建时，里面没有一个线程。任务放在阻塞队列中作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。<br>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p>\n<ol>\n<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li>\n<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li>\n<li>如果这时候队列满了，而且正在运行的线程数量小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li>\n<li>如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li>\n</ol>\n<p>当一个线程完成任务时，它会从队列中取下一个任务来执行。<br>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p>\n<h1 id=\"线程池的创建和使用\"><a href=\"#线程池的创建和使用\" class=\"headerlink\" title=\"线程池的创建和使用\"></a>线程池的创建和使用</h1><h2 id=\"线程池的生成：\"><a href=\"#线程池的生成：\" class=\"headerlink\" title=\"线程池的生成：\"></a>线程池的生成：</h2><p>生成线程池采用了工具类Executors的静态方法，以下是几种常见的线程池。</p>\n<ul>\n<li>SingleThreadExecutor：单个后台线程 (其缓冲队列是无界的)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService ( <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</div><div class=\"line\">                              <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建一个单线程的线程池。可以看到maximumPoolSize和corePoolSize都是1，这个线程池只有一个核心线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>\n<ul>\n<li>FixedThreadPool：只有核心线程的线程池,大小固定 (其缓冲队列是无界的) 。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</div><div class=\"line\">                            <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建固定大小的线程池。可以看到maximumPoolSize和corePoolSize相等，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>\n<ul>\n<li>CachedThreadPool：无界线程池，可以进行自动线程回收。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>,Integer.MAX_VALUE, <span class=\"number\">60L</span>, TimeUnit.SECONDS,</div><div class=\"line\">                            <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建一个无界的线程池，可以看到corePoolSize是0，而maximumPoolSize是整型数的最大值。当任务数增加时，此线程池可以智能的添加新线程来处理任务，而如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。SynchronousQueue是一个是缓冲区为1的阻塞队列。</p>\n<ul>\n<li>ScheduledThreadPool：核心线程池固定，大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledThreadPool(corePoolSize,Integer.MAX_VALUE,DEFAULT_KEEPALIVE_MILLIS,</div><div class=\"line\">                                MILLISECONDS,<span class=\"keyword\">new</span> DelayedWorkQueue());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建一个周期性执行任务的线程池。如果闲置,非核心线程池会在DEFAULT_KEEPALIVEMILLIS时间内回收。DleayQueue是一个延迟阻塞队列，它实现了Delayed接口，只有达到指定延迟时间才能从里面取出数据，然后交由线程池中的线程去处理。</p>\n<ul>\n<li>定制自己的线程池：</li>\n</ul>\n<p>除此之外我们也可以定制自己的线程池：比如要实现一个优先级线程池，只需要把PriorityBlockingQueue作为参数传入到线程池中去:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newPriorityThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize, <span class=\"keyword\">int</span> maximumPoolSize, </span></span></div><div class=\"line\">            <span class=\"keyword\">long</span> keepAliveTime, TimeUnit unit, PriorityBlockingQueue&lt;Runnable&gt; workQueue)&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,</div><div class=\"line\">                            workQueue);                                  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所有任务都实现了Comparable和Runable接口，所以当无法直接向线程池中提交任务的时候，任务就会加入优先级阻塞队列PriorityBlockingQueue中去，PriorityBlockingQueue就会用Comparable接口中的compareTo方法来确定优先级。所以之后就会按优先级向线程池提交任务。但是注意，最开始的corePoolSize个任务由于是直接提交给线程池的，没有加入到PriorityBlockingQueue，所以是按提交顺序去执行而不是优先级。</p>\n<h2 id=\"线程池提交任务的方法：\"><a href=\"#线程池提交任务的方法：\" class=\"headerlink\" title=\"线程池提交任务的方法：\"></a>线程池提交任务的方法：</h2><p>1、execute:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExecutorService.execute(Runnable runable)；</div></pre></td></tr></table></figure></p>\n<p>2、submit:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">FutureTask task = ExecutorService.submit(Runnable runnable);</div><div class=\"line\"></div><div class=\"line\">FutureTask&lt;T&gt; task = ExecutorService.submit(Runnable runnable,T Result);</div><div class=\"line\"> </div><div class=\"line\">FutureTask&lt;T&gt; task = ExecutorService.submit(Callable&lt;T&gt; callable);</div></pre></td></tr></table></figure></p>\n<p>可以去看一看submit方法是怎么实现的，下面列出了submit(Callable callable)的实现源码，submit(Runnable runnable)方法其实也是差不多的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">    FutureTask&lt;T&gt; ftask = newTaskFor(task);</div><div class=\"line\">    execute(ftask);</div><div class=\"line\">    <span class=\"keyword\">return</span> ftask;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出submit开启的是有返回结果的任务，会返回一个FutureTask对象，这样就能通过get()方法得到任务执行的结果。其实submit最终调用的也是execute(Runnable runable)，submit只是将Callable对象或Runnable封装成一个FutureTask对象，因为FutureTask是个Runnable，所以可以在execute中执行。</p>\n<h1 id=\"线程池的实现原理：\"><a href=\"#线程池的实现原理：\" class=\"headerlink\" title=\"线程池的实现原理：\"></a>线程池的实现原理：</h1><p>线程池的实现过程没有用到Synchronized关键字，用的都是volatile,Lock和同步(阻塞)队列,Atomic相关类，FutureTask等等，因为后者的性能更优。理解的过程可以很好的学习源码中并发控制的思想。在开篇提到过线程池的优点是可总结为以下三点：线程复用，控制最大并发数和管理线程这三点，下面从这三个方面入手：</p>\n<h2 id=\"线程复用过程：\"><a href=\"#线程复用过程：\" class=\"headerlink\" title=\"线程复用过程：\"></a>线程复用过程：</h2><p>理解线程复用原理首先应了解普通线程的生命周期（注意：是线程的生命周期，不是线程池的生命周期）：<br><img src=\"/2017/06/16/Java线程池/b.jpg\" alt=\"线程生命周期\"><br>在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态。</p>\n<p>我们可以通过Thread类的new()方法来新建一个线程，这个过程是是初始化一些线程信息，如线程名，id,线程所属group等，可以认为只是个普通的对象。新建的线程处于新建状态，而通过调用Thread的start()后，Java虚拟机会为其创建方法调用栈和程序计数器，同时将hasBeenStarted为true,这是线程进入就绪状态，如果这之后再调用start方法就会有异常，所以整个生命周期中start()方法只调用一次。<br>处于就绪状态的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。当线程获取cpu后，run()方法会被调用。注意，不要自己去调用Thread的run()方法，系统会自己去调用。之后线程会根据CPU的调度在就绪——运行——阻塞之间切换，直到run()方法结束或其他方式停止线程，进入dead状态。</p>\n<p>所以实现线程复用的原理应该就是要保持线程处于存活状态（就绪，运行或阻塞）。接下来来看下ThreadPoolExecutor是怎么实现线程复用的，在ThreadPoolExecutor类中有一个内部类Worker，主要就是这个Worker类来控制线程的复用。看下Worker类简化后的代码，这样方便理解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">final</span> Thread thread;</div><div class=\"line\">     </div><div class=\"line\">    Runnable firstTask;</div><div class=\"line\">     </div><div class=\"line\">    Worker(Runnable firstTask) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.firstTask = firstTask;</div><div class=\"line\">        <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">     </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        runWorker(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">     </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</div><div class=\"line\">        Runnable task = w.firstTask;</div><div class=\"line\">        w.firstTask = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            task.run();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(一些特殊情况) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        Runnable r = workQueue.take();</div><div class=\"line\">        <span class=\"keyword\">return</span> r;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Worker是一个实现Runnable接口的对象，同时拥有一个thread，这个thread就是要开启的线程，在调用worker构造方法新建Worker对象的同时会新建一个Thread对象，新建这个Tread对象的时候会将Worker自己作为参数传入进去，这样当Thread的start()方法调用时，线程进入就绪状态，之后获得cpu去运行的时候运行的实际上是Worker的run()方法，worker的run()方法会调用runWorker()方法,runWorker()中有个while循环，会一直从getTask()方法里得到Runnable对象(具体的任务)，然后调用这些Runable对象的run()方法(task.run())去顺序执行。可以看到getTask()方法中有一个workQueue，这个就是初始化TreadPoolExecutor时存放任务的BlockingQueue队列。这个队列中存放的都是将要执行的Runable任务。因为BlockingQueue是个阻塞队列，BlockingQueue.take()如果是空，则进入等待阻塞状态直到BlockingQueue中有新的对象加入时唤醒阻塞的线程。所以一般情况Tread的run()方法就不会结束，而是不断执行从workQueue里取得任务去执行，这就达到线程复用的原理了。</p>\n<h2 id=\"控制最大并发数\"><a href=\"#控制最大并发数\" class=\"headerlink\" title=\"控制最大并发数\"></a>控制最大并发数</h2><p>Runnable对象是什么时候放入workQueue？Worker又是什么时候创建，Worker里的Thread的又是什么时候调用start()开启新线程来执行Worker的run()方法的呢？有上面的分析看出Worker里的runWorker()执行任务时是一个接一个，串行进行的，那并发是怎么体现的呢？</p>\n<p>这些是由ThreadPoolExecutor类中的execute()方法保证的，以下是简化后的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">int</span> c = ctl.get();</div><div class=\"line\">    <span class=\"comment\">// 当前线程数 &lt; corePoolSize</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class=\"line\">        <span class=\"comment\">// 直接启动新的线程。</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        c = ctl.get();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 活动线程数 &gt;= corePoolSize</span></div><div class=\"line\">    <span class=\"comment\">// runState为RUNNING &amp;&amp; 队列未满</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</div><div class=\"line\">        <span class=\"comment\">// 再次检验是否为RUNNING状态</span></div><div class=\"line\">        <span class=\"comment\">// 非RUNNING状态 则从workQueue中移除任务并拒绝</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</div><div class=\"line\">            reject(command);<span class=\"comment\">// 采用线程池指定的策略拒绝任务</span></div><div class=\"line\">        <span class=\"comment\">// 两种情况：</span></div><div class=\"line\">        <span class=\"comment\">// 1.非RUNNING状态拒绝新的任务</span></div><div class=\"line\">        <span class=\"comment\">// 2.队列满了启动新的线程失败（workCount &gt; maximumPoolSize）</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</div><div class=\"line\">        reject(command);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> wc = workerCountOf(c);</div><div class=\"line\">    <span class=\"keyword\">if</span> (wc &gt;= (core ? corePoolSize : maximumPoolSize)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    w = <span class=\"keyword\">new</span> Worker(firstTask);</div><div class=\"line\">    <span class=\"keyword\">final</span> Thread t = w.thread;</div><div class=\"line\">    t.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>根据代码再来看上面提到的线程池工作过程中的添加任务的情况：</p>\n<ul>\n<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；   </li>\n<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li>\n<li>如果这时候队列满了，而且正在运行的线程数量小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li>\n<li>如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会抛出异常RejectExecutionException；</li>\n</ul>\n<p>通过addWorker如果成功创建新的线程成功，则通过start()开启新线程，同时将firstTask作为这个Worker里的run()中执行的第一个任务。虽然每个Worker的任务是串行处理，但如果创建了多个Worker，因为共用一个workQueue，所以就会并行处理了。所以根据corePoolSize和maximumPoolSize来控制最大并发数。大致过程可用下图表示:<br><img src=\"/2017/06/16/Java线程池/c.jpg\" alt=\"线程池添加任务过程\"></p>\n<h2 id=\"管理线程\"><a href=\"#管理线程\" class=\"headerlink\" title=\"管理线程\"></a>管理线程</h2><p>通过线程池可以很好的管理线程的复用，控制并发数，以及销毁等过程,线程的复用和控制并发上面已经讲了，而线程的管理过程已经穿插在其中了，也很好理解。<br>在ThreadPoolExecutor有个ctl的AtomicInteger变量。通过这一个变量保存了两个内容：</p>\n<ul>\n<li>所有线程的数量</li>\n<li>每个线程所处的状态</li>\n</ul>\n<p>其中低29位存线程数，高3位存runState，通过位运算来得到不同的值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//得到线程的状态</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">runStateOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> c &amp; ~CAPACITY;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//得到Worker的的数量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">workerCountOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> c &amp; CAPACITY;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 判断线程是否在运行</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isRunning</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> c &lt; SHUTDOWN;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里主要通过shutdown()和shutdownNow()来分析线程池的关闭过程。这两个方法是关闭线程池的方法。首先线程池有五种状态来控制任务添加与执行。主要介绍以下三种：</p>\n<ul>\n<li>RUNNING状态：线程池正常运行，可以接受新的任务并处理队列中的任务；</li>\n<li>SHUTDOWN状态：不再接受新的任务，但是会执行队列中的任务；</li>\n<li>STOP状态：不再接受新任务，不处理队列中的任务</li>\n</ul>\n<p>shutdown这个方法会将runState置为SHUTDOWN，会终止所有空闲的线程，而仍在工作的线程不受影响，所以队列中的任务仍会被执行，但是线程池不再接受新的任务。shutdownNow方法则将runState置为STOP。和shutdown方法的区别，这个方法会终止所有的线程，所以队列中的任务也不会被执行了，不过线程中正在执行的任务不会突然中断，而是执行完之后线程才会关闭。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。</p>\n<p>所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。如何利用已有对象来服务就是一个需要解决的关键问题，其实这就是一些”池化资源”技术产生的原因。</p>\n<p>例如Android中常见到的很多通用组件一般都离不开”池”的概念，如各种图片加载库，网络请求库，即使Android的消息传递机制中的Meaasge当使用Meaasge.obtain()就是使用的Meaasge池中的对象，因此这个概念很重要。本文将介绍的线程池技术同样符合这一思想。</p>\n<p>线程池的优点:</p>\n<ul>\n<li>重用线程池中的线程,减少因对象创建,销毁所带来的性能开销;</li>\n<li>能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞;</li>\n<li>能够多线程进行简单的管理,使线程的使用简单、高效。</li>\n</ul>\n<h1 id=\"线程池框架Executor\"><a href=\"#线程池框架Executor\" class=\"headerlink\" title=\"线程池框架Executor\"></a>线程池框架Executor</h1><p>java中的线程池是通过Executor框架实现的，Executor框架包括类：Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable和Future、FutureTask的使用等。<br><img src=\"/2017/06/16/Java线程池/a.jpg\" alt=\"线程池框架\"></p>\n<p><strong>Executor</strong>: 所有线程池的接口,只有一个方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>ExecutorService</strong>: 增加Executor的行为，是Executor实现类的最直接接口。<br><strong>Executors</strong>： 提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。<br><strong>ThreadPoolExecutor</strong>：线程池的具体实现类,一般用的各种线程池都是基于这个类实现的。<br>构造方法如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize, <span class=\"keyword\">int</span> maximumPoolSize, <span class=\"keyword\">long</span> keepAliveTime, </span></span></div><div class=\"line\">                    TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class=\"line\">    Executors.defaultThreadFactory(), defaultHandler);</div><div class=\"line\"> </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中各个参数的含义：</p>\n<ol>\n<li>corePoolSize：线程池的核心线程数,默认情况下可以一直存活。可以设置allowCoreThreadTimeOut为True,此时 核心线程数就是0,就可以用keepAliveTime控制所有线程的超时时间。</li>\n<li>maximumPoolSize：线程池允许的最大线程数;</li>\n<li>keepAliveTime： 指的是空闲线程结束的超时时间;</li>\n<li>unit ：是一个枚举，表示 keepAliveTime 的单位;</li>\n<li>workQueue：表示存放任务的BlockingQueue&lt;Runnable队列。</li>\n<li>BlockingQueue:阻塞队列（BlockingQueue）是java.util.concurrent下的主要用来控制线程同步的工具。如果BlockQueue是空的,从BlockingQueue取东西的操作将会被阻断进入等待状态,直到BlockingQueue有数据才会被唤醒。同样,如果BlockingQueue是满的,任何试图往里存东西的操作也会被阻断进入等待状态,直到BlockingQueue里有空间才会被唤醒继续操作。具体的实现类有LinkedBlockingQueue,ArrayBlockingQueued,DelayQueue,PriorityBlockingQueue等。</li>\n</ol>\n<h1 id=\"线程池的工作过程：\"><a href=\"#线程池的工作过程：\" class=\"headerlink\" title=\"线程池的工作过程：\"></a>线程池的工作过程：</h1><p>线程池刚创建时，里面没有一个线程。任务放在阻塞队列中作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。<br>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p>\n<ol>\n<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li>\n<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li>\n<li>如果这时候队列满了，而且正在运行的线程数量小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li>\n<li>如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会抛出异常RejectExecutionException。</li>\n</ol>\n<p>当一个线程完成任务时，它会从队列中取下一个任务来执行。<br>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p>\n<h1 id=\"线程池的创建和使用\"><a href=\"#线程池的创建和使用\" class=\"headerlink\" title=\"线程池的创建和使用\"></a>线程池的创建和使用</h1><h2 id=\"线程池的生成：\"><a href=\"#线程池的生成：\" class=\"headerlink\" title=\"线程池的生成：\"></a>线程池的生成：</h2><p>生成线程池采用了工具类Executors的静态方法，以下是几种常见的线程池。</p>\n<ul>\n<li>SingleThreadExecutor：单个后台线程 (其缓冲队列是无界的)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService ( <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</div><div class=\"line\">                              <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建一个单线程的线程池。可以看到maximumPoolSize和corePoolSize都是1，这个线程池只有一个核心线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>\n<ul>\n<li>FixedThreadPool：只有核心线程的线程池,大小固定 (其缓冲队列是无界的) 。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</div><div class=\"line\">                            <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建固定大小的线程池。可以看到maximumPoolSize和corePoolSize相等，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>\n<ul>\n<li>CachedThreadPool：无界线程池，可以进行自动线程回收。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>,Integer.MAX_VALUE, <span class=\"number\">60L</span>, TimeUnit.SECONDS,</div><div class=\"line\">                            <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建一个无界的线程池，可以看到corePoolSize是0，而maximumPoolSize是整型数的最大值。当任务数增加时，此线程池可以智能的添加新线程来处理任务，而如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。SynchronousQueue是一个是缓冲区为1的阻塞队列。</p>\n<ul>\n<li>ScheduledThreadPool：核心线程池固定，大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScheduledThreadPool(corePoolSize,Integer.MAX_VALUE,DEFAULT_KEEPALIVE_MILLIS,</div><div class=\"line\">                                MILLISECONDS,<span class=\"keyword\">new</span> DelayedWorkQueue());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>创建一个周期性执行任务的线程池。如果闲置,非核心线程池会在DEFAULT_KEEPALIVEMILLIS时间内回收。DleayQueue是一个延迟阻塞队列，它实现了Delayed接口，只有达到指定延迟时间才能从里面取出数据，然后交由线程池中的线程去处理。</p>\n<ul>\n<li>定制自己的线程池：</li>\n</ul>\n<p>除此之外我们也可以定制自己的线程池：比如要实现一个优先级线程池，只需要把PriorityBlockingQueue作为参数传入到线程池中去:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newPriorityThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize, <span class=\"keyword\">int</span> maximumPoolSize, </span></span></div><div class=\"line\">            <span class=\"keyword\">long</span> keepAliveTime, TimeUnit unit, PriorityBlockingQueue&lt;Runnable&gt; workQueue)&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,</div><div class=\"line\">                            workQueue);                                  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所有任务都实现了Comparable和Runable接口，所以当无法直接向线程池中提交任务的时候，任务就会加入优先级阻塞队列PriorityBlockingQueue中去，PriorityBlockingQueue就会用Comparable接口中的compareTo方法来确定优先级。所以之后就会按优先级向线程池提交任务。但是注意，最开始的corePoolSize个任务由于是直接提交给线程池的，没有加入到PriorityBlockingQueue，所以是按提交顺序去执行而不是优先级。</p>\n<h2 id=\"线程池提交任务的方法：\"><a href=\"#线程池提交任务的方法：\" class=\"headerlink\" title=\"线程池提交任务的方法：\"></a>线程池提交任务的方法：</h2><p>1、execute:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ExecutorService.execute(Runnable runable)；</div></pre></td></tr></table></figure></p>\n<p>2、submit:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">FutureTask task = ExecutorService.submit(Runnable runnable);</div><div class=\"line\"></div><div class=\"line\">FutureTask&lt;T&gt; task = ExecutorService.submit(Runnable runnable,T Result);</div><div class=\"line\"> </div><div class=\"line\">FutureTask&lt;T&gt; task = ExecutorService.submit(Callable&lt;T&gt; callable);</div></pre></td></tr></table></figure></p>\n<p>可以去看一看submit方法是怎么实现的，下面列出了submit(Callable callable)的实现源码，submit(Runnable runnable)方法其实也是差不多的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\">    FutureTask&lt;T&gt; ftask = newTaskFor(task);</div><div class=\"line\">    execute(ftask);</div><div class=\"line\">    <span class=\"keyword\">return</span> ftask;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出submit开启的是有返回结果的任务，会返回一个FutureTask对象，这样就能通过get()方法得到任务执行的结果。其实submit最终调用的也是execute(Runnable runable)，submit只是将Callable对象或Runnable封装成一个FutureTask对象，因为FutureTask是个Runnable，所以可以在execute中执行。</p>\n<h1 id=\"线程池的实现原理：\"><a href=\"#线程池的实现原理：\" class=\"headerlink\" title=\"线程池的实现原理：\"></a>线程池的实现原理：</h1><p>线程池的实现过程没有用到Synchronized关键字，用的都是volatile,Lock和同步(阻塞)队列,Atomic相关类，FutureTask等等，因为后者的性能更优。理解的过程可以很好的学习源码中并发控制的思想。在开篇提到过线程池的优点是可总结为以下三点：线程复用，控制最大并发数和管理线程这三点，下面从这三个方面入手：</p>\n<h2 id=\"线程复用过程：\"><a href=\"#线程复用过程：\" class=\"headerlink\" title=\"线程复用过程：\"></a>线程复用过程：</h2><p>理解线程复用原理首先应了解普通线程的生命周期（注意：是线程的生命周期，不是线程池的生命周期）：<br><img src=\"/2017/06/16/Java线程池/b.jpg\" alt=\"线程生命周期\"><br>在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态。</p>\n<p>我们可以通过Thread类的new()方法来新建一个线程，这个过程是是初始化一些线程信息，如线程名，id,线程所属group等，可以认为只是个普通的对象。新建的线程处于新建状态，而通过调用Thread的start()后，Java虚拟机会为其创建方法调用栈和程序计数器，同时将hasBeenStarted为true,这是线程进入就绪状态，如果这之后再调用start方法就会有异常，所以整个生命周期中start()方法只调用一次。<br>处于就绪状态的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。当线程获取cpu后，run()方法会被调用。注意，不要自己去调用Thread的run()方法，系统会自己去调用。之后线程会根据CPU的调度在就绪——运行——阻塞之间切换，直到run()方法结束或其他方式停止线程，进入dead状态。</p>\n<p>所以实现线程复用的原理应该就是要保持线程处于存活状态（就绪，运行或阻塞）。接下来来看下ThreadPoolExecutor是怎么实现线程复用的，在ThreadPoolExecutor类中有一个内部类Worker，主要就是这个Worker类来控制线程的复用。看下Worker类简化后的代码，这样方便理解：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">final</span> Thread thread;</div><div class=\"line\">     </div><div class=\"line\">    Runnable firstTask;</div><div class=\"line\">     </div><div class=\"line\">    Worker(Runnable firstTask) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.firstTask = firstTask;</div><div class=\"line\">        <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">     </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        runWorker(<span class=\"keyword\">this</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">     </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</div><div class=\"line\">        Runnable task = w.firstTask;</div><div class=\"line\">        w.firstTask = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>)&#123;</div><div class=\"line\">            task.run();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(一些特殊情况) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        Runnable r = workQueue.take();</div><div class=\"line\">        <span class=\"keyword\">return</span> r;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Worker是一个实现Runnable接口的对象，同时拥有一个thread，这个thread就是要开启的线程，在调用worker构造方法新建Worker对象的同时会新建一个Thread对象，新建这个Tread对象的时候会将Worker自己作为参数传入进去，这样当Thread的start()方法调用时，线程进入就绪状态，之后获得cpu去运行的时候运行的实际上是Worker的run()方法，worker的run()方法会调用runWorker()方法,runWorker()中有个while循环，会一直从getTask()方法里得到Runnable对象(具体的任务)，然后调用这些Runable对象的run()方法(task.run())去顺序执行。可以看到getTask()方法中有一个workQueue，这个就是初始化TreadPoolExecutor时存放任务的BlockingQueue队列。这个队列中存放的都是将要执行的Runable任务。因为BlockingQueue是个阻塞队列，BlockingQueue.take()如果是空，则进入等待阻塞状态直到BlockingQueue中有新的对象加入时唤醒阻塞的线程。所以一般情况Tread的run()方法就不会结束，而是不断执行从workQueue里取得任务去执行，这就达到线程复用的原理了。</p>\n<h2 id=\"控制最大并发数\"><a href=\"#控制最大并发数\" class=\"headerlink\" title=\"控制最大并发数\"></a>控制最大并发数</h2><p>Runnable对象是什么时候放入workQueue？Worker又是什么时候创建，Worker里的Thread的又是什么时候调用start()开启新线程来执行Worker的run()方法的呢？有上面的分析看出Worker里的runWorker()执行任务时是一个接一个，串行进行的，那并发是怎么体现的呢？</p>\n<p>这些是由ThreadPoolExecutor类中的execute()方法保证的，以下是简化后的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">int</span> c = ctl.get();</div><div class=\"line\">    <span class=\"comment\">// 当前线程数 &lt; corePoolSize</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class=\"line\">        <span class=\"comment\">// 直接启动新的线程。</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</div><div class=\"line\">            <span class=\"keyword\">return</span>;</div><div class=\"line\">        c = ctl.get();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 活动线程数 &gt;= corePoolSize</span></div><div class=\"line\">    <span class=\"comment\">// runState为RUNNING &amp;&amp; 队列未满</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</div><div class=\"line\">        <span class=\"comment\">// 再次检验是否为RUNNING状态</span></div><div class=\"line\">        <span class=\"comment\">// 非RUNNING状态 则从workQueue中移除任务并拒绝</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</div><div class=\"line\">            reject(command);<span class=\"comment\">// 采用线程池指定的策略拒绝任务</span></div><div class=\"line\">        <span class=\"comment\">// 两种情况：</span></div><div class=\"line\">        <span class=\"comment\">// 1.非RUNNING状态拒绝新的任务</span></div><div class=\"line\">        <span class=\"comment\">// 2.队列满了启动新的线程失败（workCount &gt; maximumPoolSize）</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</div><div class=\"line\">        reject(command);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> wc = workerCountOf(c);</div><div class=\"line\">    <span class=\"keyword\">if</span> (wc &gt;= (core ? corePoolSize : maximumPoolSize)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    w = <span class=\"keyword\">new</span> Worker(firstTask);</div><div class=\"line\">    <span class=\"keyword\">final</span> Thread t = w.thread;</div><div class=\"line\">    t.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>根据代码再来看上面提到的线程池工作过程中的添加任务的情况：</p>\n<ul>\n<li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；   </li>\n<li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li>\n<li>如果这时候队列满了，而且正在运行的线程数量小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li>\n<li>如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会抛出异常RejectExecutionException；</li>\n</ul>\n<p>通过addWorker如果成功创建新的线程成功，则通过start()开启新线程，同时将firstTask作为这个Worker里的run()中执行的第一个任务。虽然每个Worker的任务是串行处理，但如果创建了多个Worker，因为共用一个workQueue，所以就会并行处理了。所以根据corePoolSize和maximumPoolSize来控制最大并发数。大致过程可用下图表示:<br><img src=\"/2017/06/16/Java线程池/c.jpg\" alt=\"线程池添加任务过程\"></p>\n<h2 id=\"管理线程\"><a href=\"#管理线程\" class=\"headerlink\" title=\"管理线程\"></a>管理线程</h2><p>通过线程池可以很好的管理线程的复用，控制并发数，以及销毁等过程,线程的复用和控制并发上面已经讲了，而线程的管理过程已经穿插在其中了，也很好理解。<br>在ThreadPoolExecutor有个ctl的AtomicInteger变量。通过这一个变量保存了两个内容：</p>\n<ul>\n<li>所有线程的数量</li>\n<li>每个线程所处的状态</li>\n</ul>\n<p>其中低29位存线程数，高3位存runState，通过位运算来得到不同的值。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//得到线程的状态</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">runStateOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> c &amp; ~CAPACITY;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//得到Worker的的数量</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">workerCountOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> c &amp; CAPACITY;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 判断线程是否在运行</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isRunning</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> c &lt; SHUTDOWN;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里主要通过shutdown()和shutdownNow()来分析线程池的关闭过程。这两个方法是关闭线程池的方法。首先线程池有五种状态来控制任务添加与执行。主要介绍以下三种：</p>\n<ul>\n<li>RUNNING状态：线程池正常运行，可以接受新的任务并处理队列中的任务；</li>\n<li>SHUTDOWN状态：不再接受新的任务，但是会执行队列中的任务；</li>\n<li>STOP状态：不再接受新任务，不处理队列中的任务</li>\n</ul>\n<p>shutdown这个方法会将runState置为SHUTDOWN，会终止所有空闲的线程，而仍在工作的线程不受影响，所以队列中的任务仍会被执行，但是线程池不再接受新的任务。shutdownNow方法则将runState置为STOP。和shutdown方法的区别，这个方法会终止所有的线程，所以队列中的任务也不会被执行了，不过线程中正在执行的任务不会突然中断，而是执行完之后线程才会关闭。</p>\n"},{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">RESTFul API</font>","date":"2017-06-23T00:43:37.000Z","_content":"RESTFul API的特点：\n==============\n1、基于“资源”，数据也好、服务也好，在RESTFul设计里一切都是资源。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。所谓\"上网\"，就是与互联网上一系列的\"资源\"互动，调用它的URI。\n2、无状态。一次调用一般就会返回结果，不存在类似于“打开连接-访问数据-关闭连接”这种依赖于上一次调用的情况。\n3、URL中通常不出现动词，只有名词\n4、URL语义清晰、明确\n5、使用HTTP的GET、POST、DELETE、PUT来表示对于资源的增删改查\n6、使用JSON不使用XML\n\n有些同学可能会说，GET、POST我也经常用啊。但是在网站里的GET和POST同RESTFul中的GET、POST是不一样的。网站里使用GET、POST的选择点在于，简单的用GET、复杂对象用POST；但在REST里，GET对应的是查询一个资源，而POST对应的是新增一个资源，意义是决然不同的。理解这一点非常重要。\n\n我们接着来看一看RESTFul API的一些最佳实践原则：\n1、使用HTTP动词表示增删改查资源， GET：查询，POST：新增，PUT：更新，DELETE：删除\n2、返回结果必须使用JSON\n3、HTTP状态码，在REST中都有特定的意义：200，201,202,204,400,401,403,500。比如401表示用户身份认证失败，403表示你验证身份通过了，但这个资源你不能操作。\n4、如果出现错误，返回一个错误码。比如我通常是这么定义的：\n5、API必须有版本的概念，v1，v2，v3\n6、使用Token令牌来做用户身份的校验与权限分级，而不是Cookie。\n7、url中大小写不敏感，不要出现大写字母\n8、使用 - 而不是使用 _ 做URL路径中字符串连接。\n9、有一份漂亮的文档（很重要）\n\n如何设计一套合理、好用的API\n=====================\n一、协议：API与用户的通信协议，总是使用HTTPs协议。\n二、域名：应该尽量将API部署在专用域名之下。比如：\n```https\nhttps://api.example.com\n```\n三、版本（Versioning）应该将API的版本号放入URL:\n```https\nhttps://api.example.com/v1/\n```\n四、路径（Endpoint）路径又称\"终点\"（endpoint），表示API的具体网址。在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的\"集合\"（collection），所以API中的名词也应该使用复数。举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样:\n```https\nhttps://api.example.com/v1/zoos\nhttps://api.example.com/v1/animals\nhttps://api.example.com/v1/employees\n```\n五、HTTP动词:对于资源的具体操作类型，由HTTP动词表示。常用的HTTP动词有下面五个（括号里是对应的SQL命令）:\n\n|HTTP动词|\n|:-------|\n|GET（SELECT）：从服务器取出资源（一项或多项）。|\n|POST（CREATE）：在服务器新建一个资源。|\n|PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。|\n|PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。|\n|DELETE（DELETE）：从服务器删除资源。|\n\n还有两个不常用的HTTP动词:\n\n|HTTP动词|\n|:-------|\n|HEAD：获取资源的元数据。|\n|OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。|\n\n六、过滤信息（Filtering）如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。下面是一些常见的参数:\n\n - ?limit=10：指定返回记录的数量\n - ?offset=10：指定返回记录的开始位置。\n - ?page=2&per_page=100：指定第几页，以及每页的记录数。\n - ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n - ?animal_type_id=1：指定筛选条件\n \n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。\n\n七、状态码（Status Codes）服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）:\n\n - 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n - 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n - 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n - 204 NO CONTENT - [DELETE]：用户删除数据成功。\n - 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n - 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n - 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n - 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n - 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n - 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n - 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n - 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n \n[状态码的完全列表][1]\n\n八、错误处理（Error handling）如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n```json\n{\n    error: \"Invalid API key\"\n}\n```\n\n九、返回结果\n针对不同操作，服务器向用户返回的结果应该符合以下规范:\n\n - GET /collection：返回资源对象的列表（数组）\n - GET /collection/resource：返回单个资源对象\n - POST /collection：返回新生成的资源对象\n - PUT /collection/resource：返回完整的资源对象\n - PATCH /collection/resource：返回完整的资源对象\n - DELETE /collection/resource：返回一个空文档\n\n十、Hypermedia API\nRESTful API最好做到Hypermedia（超媒体），即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档:\n```json\n{\"link\": {\n  \"rel\":   \"collection https://www.example.com/zoos\",\n  \"href\":  \"https://api.example.com/zoos\",\n  \"title\": \"List of zoos\",\n  \"type\":  \"application/vnd.yourformat+json\"\n}}\n```\n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。\n\n  [1]: https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n  ","source":"_posts/RESTFul API.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">RESTFul API</font>\ndate: 2017-06-23 08:43:37\ncategories: 其它\ntags: [Rest,微服务]\n---\nRESTFul API的特点：\n==============\n1、基于“资源”，数据也好、服务也好，在RESTFul设计里一切都是资源。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。所谓\"上网\"，就是与互联网上一系列的\"资源\"互动，调用它的URI。\n2、无状态。一次调用一般就会返回结果，不存在类似于“打开连接-访问数据-关闭连接”这种依赖于上一次调用的情况。\n3、URL中通常不出现动词，只有名词\n4、URL语义清晰、明确\n5、使用HTTP的GET、POST、DELETE、PUT来表示对于资源的增删改查\n6、使用JSON不使用XML\n\n有些同学可能会说，GET、POST我也经常用啊。但是在网站里的GET和POST同RESTFul中的GET、POST是不一样的。网站里使用GET、POST的选择点在于，简单的用GET、复杂对象用POST；但在REST里，GET对应的是查询一个资源，而POST对应的是新增一个资源，意义是决然不同的。理解这一点非常重要。\n\n我们接着来看一看RESTFul API的一些最佳实践原则：\n1、使用HTTP动词表示增删改查资源， GET：查询，POST：新增，PUT：更新，DELETE：删除\n2、返回结果必须使用JSON\n3、HTTP状态码，在REST中都有特定的意义：200，201,202,204,400,401,403,500。比如401表示用户身份认证失败，403表示你验证身份通过了，但这个资源你不能操作。\n4、如果出现错误，返回一个错误码。比如我通常是这么定义的：\n5、API必须有版本的概念，v1，v2，v3\n6、使用Token令牌来做用户身份的校验与权限分级，而不是Cookie。\n7、url中大小写不敏感，不要出现大写字母\n8、使用 - 而不是使用 _ 做URL路径中字符串连接。\n9、有一份漂亮的文档（很重要）\n\n如何设计一套合理、好用的API\n=====================\n一、协议：API与用户的通信协议，总是使用HTTPs协议。\n二、域名：应该尽量将API部署在专用域名之下。比如：\n```https\nhttps://api.example.com\n```\n三、版本（Versioning）应该将API的版本号放入URL:\n```https\nhttps://api.example.com/v1/\n```\n四、路径（Endpoint）路径又称\"终点\"（endpoint），表示API的具体网址。在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的\"集合\"（collection），所以API中的名词也应该使用复数。举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样:\n```https\nhttps://api.example.com/v1/zoos\nhttps://api.example.com/v1/animals\nhttps://api.example.com/v1/employees\n```\n五、HTTP动词:对于资源的具体操作类型，由HTTP动词表示。常用的HTTP动词有下面五个（括号里是对应的SQL命令）:\n\n|HTTP动词|\n|:-------|\n|GET（SELECT）：从服务器取出资源（一项或多项）。|\n|POST（CREATE）：在服务器新建一个资源。|\n|PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。|\n|PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。|\n|DELETE（DELETE）：从服务器删除资源。|\n\n还有两个不常用的HTTP动词:\n\n|HTTP动词|\n|:-------|\n|HEAD：获取资源的元数据。|\n|OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。|\n\n六、过滤信息（Filtering）如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。下面是一些常见的参数:\n\n - ?limit=10：指定返回记录的数量\n - ?offset=10：指定返回记录的开始位置。\n - ?page=2&per_page=100：指定第几页，以及每页的记录数。\n - ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n - ?animal_type_id=1：指定筛选条件\n \n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。\n\n七、状态码（Status Codes）服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）:\n\n - 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n - 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n - 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n - 204 NO CONTENT - [DELETE]：用户删除数据成功。\n - 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n - 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n - 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n - 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n - 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n - 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n - 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n - 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n \n[状态码的完全列表][1]\n\n八、错误处理（Error handling）如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n```json\n{\n    error: \"Invalid API key\"\n}\n```\n\n九、返回结果\n针对不同操作，服务器向用户返回的结果应该符合以下规范:\n\n - GET /collection：返回资源对象的列表（数组）\n - GET /collection/resource：返回单个资源对象\n - POST /collection：返回新生成的资源对象\n - PUT /collection/resource：返回完整的资源对象\n - PATCH /collection/resource：返回完整的资源对象\n - DELETE /collection/resource：返回一个空文档\n\n十、Hypermedia API\nRESTful API最好做到Hypermedia（超媒体），即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档:\n```json\n{\"link\": {\n  \"rel\":   \"collection https://www.example.com/zoos\",\n  \"href\":  \"https://api.example.com/zoos\",\n  \"title\": \"List of zoos\",\n  \"type\":  \"application/vnd.yourformat+json\"\n}}\n```\n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。\n\n  [1]: https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n  ","slug":"RESTFul API","published":1,"updated":"2017-07-12T01:49:30.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hso03000casvld41mti5h","content":"<h1 id=\"RESTFul-API的特点：\"><a href=\"#RESTFul-API的特点：\" class=\"headerlink\" title=\"RESTFul API的特点：\"></a>RESTFul API的特点：</h1><p>1、基于“资源”，数据也好、服务也好，在RESTFul设计里一切都是资源。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。<br>2、无状态。一次调用一般就会返回结果，不存在类似于“打开连接-访问数据-关闭连接”这种依赖于上一次调用的情况。<br>3、URL中通常不出现动词，只有名词<br>4、URL语义清晰、明确<br>5、使用HTTP的GET、POST、DELETE、PUT来表示对于资源的增删改查<br>6、使用JSON不使用XML</p>\n<p>有些同学可能会说，GET、POST我也经常用啊。但是在网站里的GET和POST同RESTFul中的GET、POST是不一样的。网站里使用GET、POST的选择点在于，简单的用GET、复杂对象用POST；但在REST里，GET对应的是查询一个资源，而POST对应的是新增一个资源，意义是决然不同的。理解这一点非常重要。</p>\n<p>我们接着来看一看RESTFul API的一些最佳实践原则：<br>1、使用HTTP动词表示增删改查资源， GET：查询，POST：新增，PUT：更新，DELETE：删除<br>2、返回结果必须使用JSON<br>3、HTTP状态码，在REST中都有特定的意义：200，201,202,204,400,401,403,500。比如401表示用户身份认证失败，403表示你验证身份通过了，但这个资源你不能操作。<br>4、如果出现错误，返回一个错误码。比如我通常是这么定义的：<br>5、API必须有版本的概念，v1，v2，v3<br>6、使用Token令牌来做用户身份的校验与权限分级，而不是Cookie。<br>7、url中大小写不敏感，不要出现大写字母<br>8、使用 - 而不是使用 _ 做URL路径中字符串连接。<br>9、有一份漂亮的文档（很重要）</p>\n<h1 id=\"如何设计一套合理、好用的API\"><a href=\"#如何设计一套合理、好用的API\" class=\"headerlink\" title=\"如何设计一套合理、好用的API\"></a>如何设计一套合理、好用的API</h1><p>一、协议：API与用户的通信协议，总是使用HTTPs协议。<br>二、域名：应该尽量将API部署在专用域名之下。比如：<br><figure class=\"highlight https\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">https://api.example.com</span></div></pre></td></tr></table></figure></p>\n<p>三、版本（Versioning）应该将API的版本号放入URL:<br><figure class=\"highlight https\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">https://api.example.com/v1/</span></div></pre></td></tr></table></figure></p>\n<p>四、路径（Endpoint）路径又称”终点”（endpoint），表示API的具体网址。在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://api.example.com/v1/zoos</div><div class=\"line\">https://api.example.com/v1/animals</div><div class=\"line\">https://api.example.com/v1/employees</div></pre></td></tr></table></figure></p>\n<p>五、HTTP动词:对于资源的具体操作类型，由HTTP动词表示。常用的HTTP动词有下面五个（括号里是对应的SQL命令）:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">HTTP动词</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">GET（SELECT）：从服务器取出资源（一项或多项）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">POST（CREATE）：在服务器新建一个资源。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DELETE（DELETE）：从服务器删除资源。</td>\n</tr>\n</tbody>\n</table>\n<p>还有两个不常用的HTTP动词:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">HTTP动词</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">HEAD：获取资源的元数据。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</td>\n</tr>\n</tbody>\n</table>\n<p>六、过滤信息（Filtering）如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。下面是一些常见的参数:</p>\n<ul>\n<li>?limit=10：指定返回记录的数量</li>\n<li>?offset=10：指定返回记录的开始位置。</li>\n<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>\n<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>\n<li>?animal_type_id=1：指定筛选条件</li>\n</ul>\n<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>\n<p>七、状态码（Status Codes）服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）:</p>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\n<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>\n<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\n<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n<p><a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\">状态码的完全列表</a></p>\n<p>八、错误处理（Error handling）如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    error: \"Invalid API key\"</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>九、返回结果<br>针对不同操作，服务器向用户返回的结果应该符合以下规范:</p>\n<ul>\n<li>GET /collection：返回资源对象的列表（数组）</li>\n<li>GET /collection/resource：返回单个资源对象</li>\n<li>POST /collection：返回新生成的资源对象</li>\n<li>PUT /collection/resource：返回完整的资源对象</li>\n<li>PATCH /collection/resource：返回完整的资源对象</li>\n<li>DELETE /collection/resource：返回一个空文档</li>\n</ul>\n<p>十、Hypermedia API<br>RESTful API最好做到Hypermedia（超媒体），即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档:<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;<span class=\"attr\">\"link\"</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">\"rel\"</span>:   <span class=\"string\">\"collection https://www.example.com/zoos\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"href\"</span>:  <span class=\"string\">\"https://api.example.com/zoos\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"List of zoos\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"type\"</span>:  <span class=\"string\">\"application/vnd.yourformat+json\"</span></div><div class=\"line\">&#125;&#125;</div></pre></td></tr></table></figure></p>\n<p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"RESTFul-API的特点：\"><a href=\"#RESTFul-API的特点：\" class=\"headerlink\" title=\"RESTFul API的特点：\"></a>RESTFul API的特点：</h1><p>1、基于“资源”，数据也好、服务也好，在RESTFul设计里一切都是资源。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。<br>2、无状态。一次调用一般就会返回结果，不存在类似于“打开连接-访问数据-关闭连接”这种依赖于上一次调用的情况。<br>3、URL中通常不出现动词，只有名词<br>4、URL语义清晰、明确<br>5、使用HTTP的GET、POST、DELETE、PUT来表示对于资源的增删改查<br>6、使用JSON不使用XML</p>\n<p>有些同学可能会说，GET、POST我也经常用啊。但是在网站里的GET和POST同RESTFul中的GET、POST是不一样的。网站里使用GET、POST的选择点在于，简单的用GET、复杂对象用POST；但在REST里，GET对应的是查询一个资源，而POST对应的是新增一个资源，意义是决然不同的。理解这一点非常重要。</p>\n<p>我们接着来看一看RESTFul API的一些最佳实践原则：<br>1、使用HTTP动词表示增删改查资源， GET：查询，POST：新增，PUT：更新，DELETE：删除<br>2、返回结果必须使用JSON<br>3、HTTP状态码，在REST中都有特定的意义：200，201,202,204,400,401,403,500。比如401表示用户身份认证失败，403表示你验证身份通过了，但这个资源你不能操作。<br>4、如果出现错误，返回一个错误码。比如我通常是这么定义的：<br>5、API必须有版本的概念，v1，v2，v3<br>6、使用Token令牌来做用户身份的校验与权限分级，而不是Cookie。<br>7、url中大小写不敏感，不要出现大写字母<br>8、使用 - 而不是使用 _ 做URL路径中字符串连接。<br>9、有一份漂亮的文档（很重要）</p>\n<h1 id=\"如何设计一套合理、好用的API\"><a href=\"#如何设计一套合理、好用的API\" class=\"headerlink\" title=\"如何设计一套合理、好用的API\"></a>如何设计一套合理、好用的API</h1><p>一、协议：API与用户的通信协议，总是使用HTTPs协议。<br>二、域名：应该尽量将API部署在专用域名之下。比如：<br><figure class=\"highlight https\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">https://api.example.com</span></div></pre></td></tr></table></figure></p>\n<p>三、版本（Versioning）应该将API的版本号放入URL:<br><figure class=\"highlight https\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attribute\">https://api.example.com/v1/</span></div></pre></td></tr></table></figure></p>\n<p>四、路径（Endpoint）路径又称”终点”（endpoint），表示API的具体网址。在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">https://api.example.com/v1/zoos</div><div class=\"line\">https://api.example.com/v1/animals</div><div class=\"line\">https://api.example.com/v1/employees</div></pre></td></tr></table></figure></p>\n<p>五、HTTP动词:对于资源的具体操作类型，由HTTP动词表示。常用的HTTP动词有下面五个（括号里是对应的SQL命令）:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">HTTP动词</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">GET（SELECT）：从服务器取出资源（一项或多项）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">POST（CREATE）：在服务器新建一个资源。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DELETE（DELETE）：从服务器删除资源。</td>\n</tr>\n</tbody>\n</table>\n<p>还有两个不常用的HTTP动词:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">HTTP动词</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">HEAD：获取资源的元数据。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</td>\n</tr>\n</tbody>\n</table>\n<p>六、过滤信息（Filtering）如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。下面是一些常见的参数:</p>\n<ul>\n<li>?limit=10：指定返回记录的数量</li>\n<li>?offset=10：指定返回记录的开始位置。</li>\n<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>\n<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>\n<li>?animal_type_id=1：指定筛选条件</li>\n</ul>\n<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>\n<p>七、状态码（Status Codes）服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）:</p>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\n<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>\n<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\n<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n<p><a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\">状态码的完全列表</a></p>\n<p>八、错误处理（Error handling）如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    error: \"Invalid API key\"</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>九、返回结果<br>针对不同操作，服务器向用户返回的结果应该符合以下规范:</p>\n<ul>\n<li>GET /collection：返回资源对象的列表（数组）</li>\n<li>GET /collection/resource：返回单个资源对象</li>\n<li>POST /collection：返回新生成的资源对象</li>\n<li>PUT /collection/resource：返回完整的资源对象</li>\n<li>PATCH /collection/resource：返回完整的资源对象</li>\n<li>DELETE /collection/resource：返回一个空文档</li>\n</ul>\n<p>十、Hypermedia API<br>RESTful API最好做到Hypermedia（超媒体），即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档:<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;<span class=\"attr\">\"link\"</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">\"rel\"</span>:   <span class=\"string\">\"collection https://www.example.com/zoos\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"href\"</span>:  <span class=\"string\">\"https://api.example.com/zoos\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"List of zoos\"</span>,</div><div class=\"line\">  <span class=\"attr\">\"type\"</span>:  <span class=\"string\">\"application/vnd.yourformat+json\"</span></div><div class=\"line\">&#125;&#125;</div></pre></td></tr></table></figure></p>\n<p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>\n"},{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">Spring实战（一） 依赖注入和面向切面编程</font>","date":"2017-06-02T01:15:26.000Z","_content":"\nSpring用bean或者JavaBean来表示应用组件，但并不意味着Spring组件必须要遵循JavaBean规范。一个Spring组件可以是任何形式的POJO。以下都采用JavaBean的广泛定义，即POJO的同义词。\n\nSpring的根本使命就是简化Java开发，而为了降低Java开发的复杂性，Spring采取了以下4种关键策略：\n- 基于POJO的轻量级和最小侵入性编程；\n- 通过依赖注入和面向接口实现松耦合；\n- 基于切面和惯例进行声明式编程；\n- 通过切面和模板减少样板式代码。\n\n依赖注入\n======\n**通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定。对象无需自行创建或管理它们的依赖关系。依赖注入主要是实现松耦合。**\n\n假如现在有一个骑士DamselRescuingKnight：\n```java\npublic class DamselRescuingKnight implements Knight {\n\n  private RescueDamselQuest quest;\n\n  public DamselRescuingKnight() {\n    this.quest = new RescueDamselQuest();\n  }\n\n  public void embarkOnQuest() {\n    quest.embark();\n  }\n  \n}\n```\n可以看到DamselRescuingKnight这个类中有一个成员变量RescueDamselQuest，这是一个具体的探险任务类型，所以DamselRescuingKnight这个类型的骑士就只能执行RescueDamselQuest探险任务。这使得DamselRescuingKnight紧密地和RescueDamselQuest耦合到了一起，因此极大地限制了这个骑士执行探险的能力。\n但是如果我们这样去实现：\n```java\npublic class BraveKnight implements Knight {\n\n  private Quest quest;\n\n  public BraveKnight(Quest quest) {\n    this.quest = quest;\n  }\n\n  public void embarkOnQuest() {\n    quest.embark();\n  }\n\n}\n```\n可以看到BraveKnight没有自行创建具体的探险任务，而是在构造的时候把探险任务作为构造器参数传入。这是依赖注入的方式之一，即构造器注入（constructor injection）。更重要的是，传入的探险类型是Quest，也就是所有探险任务都必须实现的一个接口。所以，BraveKnight能够响应RescueDamselQuest、 SlayDragonQuest、 MakeRoundTableRounderQuest等任意的Quest实现。这就是DI所带来的最大收益——松耦合。\n\n现在BraveKnight类可以接受你传递给它的任意一种Quest的实现，但该怎样把特定的Query实现传给它呢？假设，希望BraveKnight所要进行探险任务是杀死一只怪龙，那么SlayDragonQuest也许挺合适的。但是要怎么把SlayDragonQuest传给BraveKnight呢？\n\n**创建应用组件之间协作的行为通常称为装配（wiring）。Spring有多种装配bean的方式，采用XML是很常见的一种装配方式。**这里就可以用knights.xml把SlayDragonQuest传给BraveKnight：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n      http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n  <bean id=\"knight\" class=\"sia.knights.BraveKnight\">\n    <!--注入Quest Bean-->\n    <constructor-arg ref=\"quest\" /> \n  </bean>\n\n   <!--创建SlayDragonQuest-->\n  <bean id=\"quest\" class=\"sia.knights.SlayDragonQuest\">\n    <constructor-arg value=\"#{T(System).out}\" />\n  </bean>\n\n</beans>\n```\n在这里，BraveKnight和SlayDragonQuest被声明为Spring中的bean。就BraveKnight bean来讲，它在构造时传入了对SlayDragonQuestbean的引用，将其作为构造器参数。同时，SlayDragonQuestbean的声明使用了Spring表达式语言（SpringExpressionLanguage），将System.out（这是一个PrintStream）传入到了SlayDragonQuest的构造器中。\n\n**Spring还支持使用Java来描述配置。**下面的做法和上面xml的功能是一样的，都是将SlayDragonQuest注入到BraveKnight：\n```java\npackage sia.knights.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport sia.knights.BraveKnight;\nimport sia.knights.Knight;\nimport sia.knights.Quest;\nimport sia.knights.SlayDragonQuest;\n\n@Configuration\npublic class KnightConfig {\n\n  @Bean\n  public Knight knight() {\n    return new BraveKnight(quest());\n  }\n  \n  @Bean\n  public Quest quest() {\n    return new SlayDragonQuest(System.out);\n  }\n\n}\n```\n不管你使用的是基于XML的配置还是基于Java的配置，DI所带来的收益都是相同的。尽管BraveKnight依赖于Quest，但是它并不知道传递给它的是什么类型的Quest，也不知道这个Quest来自哪里。只有Spring通过它的配置，能够了解这些组成部分是如何装配起来的。这样的话，就可以在不改变所依赖的类的情况下，修改依赖关系。\n\n现在已经声明了BraveKnight和Quest的关系，接下来我们只需要装载XML配置文件，并把应用启动起来。Spring通过应用上下文（Application Context）装载bean的定义并把它们组装起来。Spring应用上下文全权负责对象的创建和组装。Spring自带了多种应用上下文的实现，它们之间主要的区别仅仅在于如何加载配置。\n\n因为knights.xml中的bean是使用XML文件进行配置的，所以选择Class Path Xml Application Context作为应用上下文相对是比较合适的。该类加载位于应用程序类路径下的一个或多个XML配置文件。下面程序中的main()方法调用ClassPathXmlApplicationContext加载knights.xml，并获得Knight对象的引用。\n```java\npackage sia.knights;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class KnightMain {\n\n  public static void main(String[] args) throws Exception {\n    //加载Spring上下文\n    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"META-INF/spring/knight.xml\");\n    //获取Knight Bean\n    Knight knight = context.getBean(Knight.class);\n    //使用Knight\n    knight.embarkOnQuest();\n    context.close();\n  }\n\n}\n```\n这里的main()方法基于knights.xml文件创建了Spring应用上下文。随后它调用该应用上下文获取一个ID为knight的bean。得到Knight对象的引用后，只需简单调用embarkOnQuest()方法就可以执行所赋予的探险任务了。注意这个类完全不知道我们的英雄骑士接受哪种探险任务，而且完全没有意识到这是由BraveKnight来执行的。只有knights.xml文件知道哪个骑士执行哪种探险任务。\n\n面向切面编程\n======\n**DI能够让相互协作的软件组件保持松散耦合，而面向切面编程(aspect-oriented programming，AOP)允许你把遍布应用各处的功能分离出来形成可重用的组件。**\n\n系统由许多不同的组件组成，每一个组件各负责一块特定功能。除了实现自身核心的功能之外，这些组件还经常承担着额外的职责。诸如日志、事务管理和安全这样的系统服务经常融入到本身具有核心业务逻辑的组件中去，这些系统服务通常被称为横切关注点，因为它们会跨越系统的多个组件。如果将这些关注点分散到多个组件中去，你的代码将会带来双重的复杂性：\n\n- 实现系统关注点功能的代码将会重复出现在多个组件中。这意味着如果你要改变这些关注点的逻辑，必须修改各个模块中的相关实现。即使你把这些关注点抽象为一个独立的模块，其他模块只是调用它的方法，但方法的调用还是会重复出现在各个模块中。\n- 组件会因为那些与自身核心业务无关的代码而变得混乱。一个向地址簿增加地址条目的方法应该只关注如何添加地址，而不应该关注它是不是安全的或者是否需要支持事务。\n\nAOP能够使这些服务模块化，并以声明的方式将它们应用到它们需要影响的组件中去。所造成的结果就是这些组件会具有更高的内聚性并且会更加关注自身的业务，完全不需要了解涉及系统服务所带来复杂性。总之，AOP能够确保POJO的简单性。\n\n**AOP的使用：**\n每一个人都熟知骑士所做的任何事情，这是因为吟游诗人用诗歌记载了骑士的事迹并将其进行传唱。假设我们需要使用吟游诗人这个服务\n类来记载骑士的所有事迹。Minstrel类：\n```java\npackage sia.knights;\n\nimport java.io.PrintStream;\n\npublic class Minstrel {\n\n      private PrintStream stream;\n      \n      public Minstrel(PrintStream stream) {\n        this.stream = stream;\n      }\n\n      //探险之前调用\n      public void singBeforeQuest() {\n        stream.println(\"Fa la la, the knight is so brave!\");\n      }\n    \n      //探险之后调用\n      public void singAfterQuest() {\n        stream.println(\"Tee hee hee, the brave knight \" +\n        \t\t\"did embark on a quest!\");\n      }\n\n}\n```\nMinstrel是只有两个方法的简单类。在骑士执行每一个探险任务之前，singBeforeQuest()方法会被调用；在骑士完成探险任务之后，singAfterQuest()方法会被调用。在这两种情况下，Minstrel都会通过一个PrintStream类来歌颂骑士的事迹，这个类是通过构造器注入进来的。我们适当做一下调整从而让BraveKnight可以使用Minstrel：\n```java\npackage sia.knights;\n  \npublic class BraveKnight implements Knight {\n\n  private Quest quest;\n  private Minstrel minstrel;\n\n  public BraveKnight(Quest quest) {\n    this.quest = quest;\n    this.minstrel = minstrel;\n  }\n\n  public void embarkOnQuest() {\n    minstrel.singBeforeQuest();\n    quest.embark();\n    minstrel.singAfterQuest();\n  }\n\n}\n```\n这应该可以达到预期效果。现在，你所需要做的就是回到Spring配置中，声明Minstrel bean并将其注入到\nBraveKnight的构造器之中。但是，管理吟游诗人的行为真的是骑士职责范围内的工作吗？在我看来，吟游诗人应该做他份内的事，根本不需要骑士命令他这么做。此外，因为骑士需要知道吟游诗人，所以就必须把吟游诗人注入到BarveKnight类中。这不仅使BraveKnight的代码复杂化了，而且还让我疑惑是否还需要一个不需要吟游诗人的骑士呢？如果Minstrel为null会发生什么呢？我是否应该引入一个空值校验逻辑来覆盖该场景？\n\n但利用AOP，你可以声明吟游诗人必须歌颂骑士的探险事迹，而骑士本身并不用直接访问Minstrel的方法。要将\nMinstrel抽象为一个切面，你所需要做的事情就是在一个Spring配置文件中声明它。下面是更新后的knights.xml文件，Minstrel被声明为一个切面：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xmlns:aop=\"http://www.springframework.org/schema/aop\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/aop \n      http://www.springframework.org/schema/aop/spring-aop.xsd\n\t\thttp://www.springframework.org/schema/beans \n      http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n  <bean id=\"knight\" class=\"sia.knights.BraveKnight\">\n    <constructor-arg ref=\"quest\" />\n  </bean>\n\n  <bean id=\"quest\" class=\"sia.knights.SlayDragonQuest\">\n    <constructor-arg value=\"#{T(System).out}\" />\n  </bean>\n\n  <!--声明minstrel bean-->\n  <bean id=\"minstrel\" class=\"sia.knights.Minstrel\">\n    <constructor-arg value=\"#{T(System).out}\" />\n  </bean>\n\n  <!--定义切面-->\n  <aop:config>\n    <aop:aspect ref=\"minstrel\">\n      <aop:pointcut id=\"embark\"\n          expression=\"execution(* *.embarkOnQuest(..))\"/>\n      <!--声明前置通知-->\n      <aop:before pointcut-ref=\"embark\" \n          method=\"singBeforeQuest\"/>\n      <!--声明后置通知-->\n      <aop:after pointcut-ref=\"embark\" \n          method=\"singAfterQuest\"/>\n    </aop:aspect>\n  </aop:config>\n  \n</beans>\n```\n这里使用了Spring的aop配置命名空间把Minstrel bean声明为一个切面。首先，需要把Minstrel声明为一个bean，然后在< aop:aspect>元素中引用该bean。为了进一步定义切面，声明（使用< aop:before>\n）在embarkOnQuest()方法执行前调用Minstrel的singBeforeQuest()方法。这种方式被称为前置通知（before advice）。同时声明（使用< aop:after>）在embarkOnQuest()方法执行后调用singAfterQuest()方法。这种方式被称为后置通知（after advice）。\n在这两种方式中，pointcut-ref属性都引用了名字为embank的切入点。该切入点是在前边的< pointcut>\n元素中定义的，并配置expression属性来选择所应用的通知。表达式的语法采用的是AspectJ的切点表达式语言。这样Spring在骑士执行探险任务前后就会调用Minstrel的singBeforeQuest()和singAfterQuest()方法。\n\nMinstrel仍然是一个POJO，没有任何代码表明它要被作为一个切面使用。当我们按照上面那样进行配置后，在S\npring的上下文中，Minstrel实际上已经变成一个切面了。其次，也是最重要的，Minstrel可以被应用到BraveKnight中，而BraveKnight不需要显式地调用它。实际上，BraveKnight完全不知道Minstrel的存在。必须还要指出的是，尽管我们使用Spring魔法把Minstrel转变为一个切面，但首先要把它声明为一个Spring bean。能够为其他Spring bean做到的事情都可以同样应用到Spring切面中，例如为它们注入依赖。\n\n","source":"_posts/Java读书笔记——Spring实战（一）.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">Spring实战（一） 依赖注入和面向切面编程</font>\ndate: 2017-06-02 09:15:26\ncategories: java读书笔记\ntags: [java,Spring,依赖注入,面向切面编程,IoC,AOP]\n---\n\nSpring用bean或者JavaBean来表示应用组件，但并不意味着Spring组件必须要遵循JavaBean规范。一个Spring组件可以是任何形式的POJO。以下都采用JavaBean的广泛定义，即POJO的同义词。\n\nSpring的根本使命就是简化Java开发，而为了降低Java开发的复杂性，Spring采取了以下4种关键策略：\n- 基于POJO的轻量级和最小侵入性编程；\n- 通过依赖注入和面向接口实现松耦合；\n- 基于切面和惯例进行声明式编程；\n- 通过切面和模板减少样板式代码。\n\n依赖注入\n======\n**通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定。对象无需自行创建或管理它们的依赖关系。依赖注入主要是实现松耦合。**\n\n假如现在有一个骑士DamselRescuingKnight：\n```java\npublic class DamselRescuingKnight implements Knight {\n\n  private RescueDamselQuest quest;\n\n  public DamselRescuingKnight() {\n    this.quest = new RescueDamselQuest();\n  }\n\n  public void embarkOnQuest() {\n    quest.embark();\n  }\n  \n}\n```\n可以看到DamselRescuingKnight这个类中有一个成员变量RescueDamselQuest，这是一个具体的探险任务类型，所以DamselRescuingKnight这个类型的骑士就只能执行RescueDamselQuest探险任务。这使得DamselRescuingKnight紧密地和RescueDamselQuest耦合到了一起，因此极大地限制了这个骑士执行探险的能力。\n但是如果我们这样去实现：\n```java\npublic class BraveKnight implements Knight {\n\n  private Quest quest;\n\n  public BraveKnight(Quest quest) {\n    this.quest = quest;\n  }\n\n  public void embarkOnQuest() {\n    quest.embark();\n  }\n\n}\n```\n可以看到BraveKnight没有自行创建具体的探险任务，而是在构造的时候把探险任务作为构造器参数传入。这是依赖注入的方式之一，即构造器注入（constructor injection）。更重要的是，传入的探险类型是Quest，也就是所有探险任务都必须实现的一个接口。所以，BraveKnight能够响应RescueDamselQuest、 SlayDragonQuest、 MakeRoundTableRounderQuest等任意的Quest实现。这就是DI所带来的最大收益——松耦合。\n\n现在BraveKnight类可以接受你传递给它的任意一种Quest的实现，但该怎样把特定的Query实现传给它呢？假设，希望BraveKnight所要进行探险任务是杀死一只怪龙，那么SlayDragonQuest也许挺合适的。但是要怎么把SlayDragonQuest传给BraveKnight呢？\n\n**创建应用组件之间协作的行为通常称为装配（wiring）。Spring有多种装配bean的方式，采用XML是很常见的一种装配方式。**这里就可以用knights.xml把SlayDragonQuest传给BraveKnight：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n      http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n  <bean id=\"knight\" class=\"sia.knights.BraveKnight\">\n    <!--注入Quest Bean-->\n    <constructor-arg ref=\"quest\" /> \n  </bean>\n\n   <!--创建SlayDragonQuest-->\n  <bean id=\"quest\" class=\"sia.knights.SlayDragonQuest\">\n    <constructor-arg value=\"#{T(System).out}\" />\n  </bean>\n\n</beans>\n```\n在这里，BraveKnight和SlayDragonQuest被声明为Spring中的bean。就BraveKnight bean来讲，它在构造时传入了对SlayDragonQuestbean的引用，将其作为构造器参数。同时，SlayDragonQuestbean的声明使用了Spring表达式语言（SpringExpressionLanguage），将System.out（这是一个PrintStream）传入到了SlayDragonQuest的构造器中。\n\n**Spring还支持使用Java来描述配置。**下面的做法和上面xml的功能是一样的，都是将SlayDragonQuest注入到BraveKnight：\n```java\npackage sia.knights.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport sia.knights.BraveKnight;\nimport sia.knights.Knight;\nimport sia.knights.Quest;\nimport sia.knights.SlayDragonQuest;\n\n@Configuration\npublic class KnightConfig {\n\n  @Bean\n  public Knight knight() {\n    return new BraveKnight(quest());\n  }\n  \n  @Bean\n  public Quest quest() {\n    return new SlayDragonQuest(System.out);\n  }\n\n}\n```\n不管你使用的是基于XML的配置还是基于Java的配置，DI所带来的收益都是相同的。尽管BraveKnight依赖于Quest，但是它并不知道传递给它的是什么类型的Quest，也不知道这个Quest来自哪里。只有Spring通过它的配置，能够了解这些组成部分是如何装配起来的。这样的话，就可以在不改变所依赖的类的情况下，修改依赖关系。\n\n现在已经声明了BraveKnight和Quest的关系，接下来我们只需要装载XML配置文件，并把应用启动起来。Spring通过应用上下文（Application Context）装载bean的定义并把它们组装起来。Spring应用上下文全权负责对象的创建和组装。Spring自带了多种应用上下文的实现，它们之间主要的区别仅仅在于如何加载配置。\n\n因为knights.xml中的bean是使用XML文件进行配置的，所以选择Class Path Xml Application Context作为应用上下文相对是比较合适的。该类加载位于应用程序类路径下的一个或多个XML配置文件。下面程序中的main()方法调用ClassPathXmlApplicationContext加载knights.xml，并获得Knight对象的引用。\n```java\npackage sia.knights;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class KnightMain {\n\n  public static void main(String[] args) throws Exception {\n    //加载Spring上下文\n    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"META-INF/spring/knight.xml\");\n    //获取Knight Bean\n    Knight knight = context.getBean(Knight.class);\n    //使用Knight\n    knight.embarkOnQuest();\n    context.close();\n  }\n\n}\n```\n这里的main()方法基于knights.xml文件创建了Spring应用上下文。随后它调用该应用上下文获取一个ID为knight的bean。得到Knight对象的引用后，只需简单调用embarkOnQuest()方法就可以执行所赋予的探险任务了。注意这个类完全不知道我们的英雄骑士接受哪种探险任务，而且完全没有意识到这是由BraveKnight来执行的。只有knights.xml文件知道哪个骑士执行哪种探险任务。\n\n面向切面编程\n======\n**DI能够让相互协作的软件组件保持松散耦合，而面向切面编程(aspect-oriented programming，AOP)允许你把遍布应用各处的功能分离出来形成可重用的组件。**\n\n系统由许多不同的组件组成，每一个组件各负责一块特定功能。除了实现自身核心的功能之外，这些组件还经常承担着额外的职责。诸如日志、事务管理和安全这样的系统服务经常融入到本身具有核心业务逻辑的组件中去，这些系统服务通常被称为横切关注点，因为它们会跨越系统的多个组件。如果将这些关注点分散到多个组件中去，你的代码将会带来双重的复杂性：\n\n- 实现系统关注点功能的代码将会重复出现在多个组件中。这意味着如果你要改变这些关注点的逻辑，必须修改各个模块中的相关实现。即使你把这些关注点抽象为一个独立的模块，其他模块只是调用它的方法，但方法的调用还是会重复出现在各个模块中。\n- 组件会因为那些与自身核心业务无关的代码而变得混乱。一个向地址簿增加地址条目的方法应该只关注如何添加地址，而不应该关注它是不是安全的或者是否需要支持事务。\n\nAOP能够使这些服务模块化，并以声明的方式将它们应用到它们需要影响的组件中去。所造成的结果就是这些组件会具有更高的内聚性并且会更加关注自身的业务，完全不需要了解涉及系统服务所带来复杂性。总之，AOP能够确保POJO的简单性。\n\n**AOP的使用：**\n每一个人都熟知骑士所做的任何事情，这是因为吟游诗人用诗歌记载了骑士的事迹并将其进行传唱。假设我们需要使用吟游诗人这个服务\n类来记载骑士的所有事迹。Minstrel类：\n```java\npackage sia.knights;\n\nimport java.io.PrintStream;\n\npublic class Minstrel {\n\n      private PrintStream stream;\n      \n      public Minstrel(PrintStream stream) {\n        this.stream = stream;\n      }\n\n      //探险之前调用\n      public void singBeforeQuest() {\n        stream.println(\"Fa la la, the knight is so brave!\");\n      }\n    \n      //探险之后调用\n      public void singAfterQuest() {\n        stream.println(\"Tee hee hee, the brave knight \" +\n        \t\t\"did embark on a quest!\");\n      }\n\n}\n```\nMinstrel是只有两个方法的简单类。在骑士执行每一个探险任务之前，singBeforeQuest()方法会被调用；在骑士完成探险任务之后，singAfterQuest()方法会被调用。在这两种情况下，Minstrel都会通过一个PrintStream类来歌颂骑士的事迹，这个类是通过构造器注入进来的。我们适当做一下调整从而让BraveKnight可以使用Minstrel：\n```java\npackage sia.knights;\n  \npublic class BraveKnight implements Knight {\n\n  private Quest quest;\n  private Minstrel minstrel;\n\n  public BraveKnight(Quest quest) {\n    this.quest = quest;\n    this.minstrel = minstrel;\n  }\n\n  public void embarkOnQuest() {\n    minstrel.singBeforeQuest();\n    quest.embark();\n    minstrel.singAfterQuest();\n  }\n\n}\n```\n这应该可以达到预期效果。现在，你所需要做的就是回到Spring配置中，声明Minstrel bean并将其注入到\nBraveKnight的构造器之中。但是，管理吟游诗人的行为真的是骑士职责范围内的工作吗？在我看来，吟游诗人应该做他份内的事，根本不需要骑士命令他这么做。此外，因为骑士需要知道吟游诗人，所以就必须把吟游诗人注入到BarveKnight类中。这不仅使BraveKnight的代码复杂化了，而且还让我疑惑是否还需要一个不需要吟游诗人的骑士呢？如果Minstrel为null会发生什么呢？我是否应该引入一个空值校验逻辑来覆盖该场景？\n\n但利用AOP，你可以声明吟游诗人必须歌颂骑士的探险事迹，而骑士本身并不用直接访问Minstrel的方法。要将\nMinstrel抽象为一个切面，你所需要做的事情就是在一个Spring配置文件中声明它。下面是更新后的knights.xml文件，Minstrel被声明为一个切面：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xmlns:aop=\"http://www.springframework.org/schema/aop\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/aop \n      http://www.springframework.org/schema/aop/spring-aop.xsd\n\t\thttp://www.springframework.org/schema/beans \n      http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n  <bean id=\"knight\" class=\"sia.knights.BraveKnight\">\n    <constructor-arg ref=\"quest\" />\n  </bean>\n\n  <bean id=\"quest\" class=\"sia.knights.SlayDragonQuest\">\n    <constructor-arg value=\"#{T(System).out}\" />\n  </bean>\n\n  <!--声明minstrel bean-->\n  <bean id=\"minstrel\" class=\"sia.knights.Minstrel\">\n    <constructor-arg value=\"#{T(System).out}\" />\n  </bean>\n\n  <!--定义切面-->\n  <aop:config>\n    <aop:aspect ref=\"minstrel\">\n      <aop:pointcut id=\"embark\"\n          expression=\"execution(* *.embarkOnQuest(..))\"/>\n      <!--声明前置通知-->\n      <aop:before pointcut-ref=\"embark\" \n          method=\"singBeforeQuest\"/>\n      <!--声明后置通知-->\n      <aop:after pointcut-ref=\"embark\" \n          method=\"singAfterQuest\"/>\n    </aop:aspect>\n  </aop:config>\n  \n</beans>\n```\n这里使用了Spring的aop配置命名空间把Minstrel bean声明为一个切面。首先，需要把Minstrel声明为一个bean，然后在< aop:aspect>元素中引用该bean。为了进一步定义切面，声明（使用< aop:before>\n）在embarkOnQuest()方法执行前调用Minstrel的singBeforeQuest()方法。这种方式被称为前置通知（before advice）。同时声明（使用< aop:after>）在embarkOnQuest()方法执行后调用singAfterQuest()方法。这种方式被称为后置通知（after advice）。\n在这两种方式中，pointcut-ref属性都引用了名字为embank的切入点。该切入点是在前边的< pointcut>\n元素中定义的，并配置expression属性来选择所应用的通知。表达式的语法采用的是AspectJ的切点表达式语言。这样Spring在骑士执行探险任务前后就会调用Minstrel的singBeforeQuest()和singAfterQuest()方法。\n\nMinstrel仍然是一个POJO，没有任何代码表明它要被作为一个切面使用。当我们按照上面那样进行配置后，在S\npring的上下文中，Minstrel实际上已经变成一个切面了。其次，也是最重要的，Minstrel可以被应用到BraveKnight中，而BraveKnight不需要显式地调用它。实际上，BraveKnight完全不知道Minstrel的存在。必须还要指出的是，尽管我们使用Spring魔法把Minstrel转变为一个切面，但首先要把它声明为一个Spring bean。能够为其他Spring bean做到的事情都可以同样应用到Spring切面中，例如为它们注入依赖。\n\n","slug":"Java读书笔记——Spring实战（一）","published":1,"updated":"2017-07-12T01:51:13.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hso05000easvllvndz8mm","content":"<p>Spring用bean或者JavaBean来表示应用组件，但并不意味着Spring组件必须要遵循JavaBean规范。一个Spring组件可以是任何形式的POJO。以下都采用JavaBean的广泛定义，即POJO的同义词。</p>\n<p>Spring的根本使命就是简化Java开发，而为了降低Java开发的复杂性，Spring采取了以下4种关键策略：</p>\n<ul>\n<li>基于POJO的轻量级和最小侵入性编程；</li>\n<li>通过依赖注入和面向接口实现松耦合；</li>\n<li>基于切面和惯例进行声明式编程；</li>\n<li>通过切面和模板减少样板式代码。</li>\n</ul>\n<h1 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h1><p><strong>通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定。对象无需自行创建或管理它们的依赖关系。依赖注入主要是实现松耦合。</strong></p>\n<p>假如现在有一个骑士DamselRescuingKnight：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DamselRescuingKnight</span> <span class=\"keyword\">implements</span> <span class=\"title\">Knight</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">private</span> RescueDamselQuest quest;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DamselRescuingKnight</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.quest = <span class=\"keyword\">new</span> RescueDamselQuest();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">embarkOnQuest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    quest.embark();</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到DamselRescuingKnight这个类中有一个成员变量RescueDamselQuest，这是一个具体的探险任务类型，所以DamselRescuingKnight这个类型的骑士就只能执行RescueDamselQuest探险任务。这使得DamselRescuingKnight紧密地和RescueDamselQuest耦合到了一起，因此极大地限制了这个骑士执行探险的能力。<br>但是如果我们这样去实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BraveKnight</span> <span class=\"keyword\">implements</span> <span class=\"title\">Knight</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">private</span> Quest quest;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BraveKnight</span><span class=\"params\">(Quest quest)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.quest = quest;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">embarkOnQuest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    quest.embark();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到BraveKnight没有自行创建具体的探险任务，而是在构造的时候把探险任务作为构造器参数传入。这是依赖注入的方式之一，即构造器注入（constructor injection）。更重要的是，传入的探险类型是Quest，也就是所有探险任务都必须实现的一个接口。所以，BraveKnight能够响应RescueDamselQuest、 SlayDragonQuest、 MakeRoundTableRounderQuest等任意的Quest实现。这就是DI所带来的最大收益——松耦合。</p>\n<p>现在BraveKnight类可以接受你传递给它的任意一种Quest的实现，但该怎样把特定的Query实现传给它呢？假设，希望BraveKnight所要进行探险任务是杀死一只怪龙，那么SlayDragonQuest也许挺合适的。但是要怎么把SlayDragonQuest传给BraveKnight呢？</p>\n<p><strong>创建应用组件之间协作的行为通常称为装配（wiring）。Spring有多种装配bean的方式，采用XML是很常见的一种装配方式。</strong>这里就可以用knights.xml把SlayDragonQuest传给BraveKnight：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">  <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">  <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans </span></div><div class=\"line\">      http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"knight\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.BraveKnight\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!--注入Quest Bean--&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"quest\"</span> /&gt;</span> </div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">&lt;!--创建SlayDragonQuest--&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"quest\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.SlayDragonQuest\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;T(System).out&#125;\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>在这里，BraveKnight和SlayDragonQuest被声明为Spring中的bean。就BraveKnight bean来讲，它在构造时传入了对SlayDragonQuestbean的引用，将其作为构造器参数。同时，SlayDragonQuestbean的声明使用了Spring表达式语言（SpringExpressionLanguage），将System.out（这是一个PrintStream）传入到了SlayDragonQuest的构造器中。</p>\n<p><strong>Spring还支持使用Java来描述配置。</strong>下面的做法和上面xml的功能是一样的，都是将SlayDragonQuest注入到BraveKnight：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> sia.knights.config;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</div><div class=\"line\"><span class=\"keyword\">import</span> sia.knights.BraveKnight;</div><div class=\"line\"><span class=\"keyword\">import</span> sia.knights.Knight;</div><div class=\"line\"><span class=\"keyword\">import</span> sia.knights.Quest;</div><div class=\"line\"><span class=\"keyword\">import</span> sia.knights.SlayDragonQuest;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KnightConfig</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Bean</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Knight <span class=\"title\">knight</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BraveKnight(quest());</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Bean</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Quest <span class=\"title\">quest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SlayDragonQuest(System.out);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>不管你使用的是基于XML的配置还是基于Java的配置，DI所带来的收益都是相同的。尽管BraveKnight依赖于Quest，但是它并不知道传递给它的是什么类型的Quest，也不知道这个Quest来自哪里。只有Spring通过它的配置，能够了解这些组成部分是如何装配起来的。这样的话，就可以在不改变所依赖的类的情况下，修改依赖关系。</p>\n<p>现在已经声明了BraveKnight和Quest的关系，接下来我们只需要装载XML配置文件，并把应用启动起来。Spring通过应用上下文（Application Context）装载bean的定义并把它们组装起来。Spring应用上下文全权负责对象的创建和组装。Spring自带了多种应用上下文的实现，它们之间主要的区别仅仅在于如何加载配置。</p>\n<p>因为knights.xml中的bean是使用XML文件进行配置的，所以选择Class Path Xml Application Context作为应用上下文相对是比较合适的。该类加载位于应用程序类路径下的一个或多个XML配置文件。下面程序中的main()方法调用ClassPathXmlApplicationContext加载knights.xml，并获得Knight对象的引用。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> sia.knights;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KnightMain</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//加载Spring上下文</span></div><div class=\"line\">    ClassPathXmlApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"META-INF/spring/knight.xml\"</span>);</div><div class=\"line\">    <span class=\"comment\">//获取Knight Bean</span></div><div class=\"line\">    Knight knight = context.getBean(Knight.class);</div><div class=\"line\">    <span class=\"comment\">//使用Knight</span></div><div class=\"line\">    knight.embarkOnQuest();</div><div class=\"line\">    context.close();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里的main()方法基于knights.xml文件创建了Spring应用上下文。随后它调用该应用上下文获取一个ID为knight的bean。得到Knight对象的引用后，只需简单调用embarkOnQuest()方法就可以执行所赋予的探险任务了。注意这个类完全不知道我们的英雄骑士接受哪种探险任务，而且完全没有意识到这是由BraveKnight来执行的。只有knights.xml文件知道哪个骑士执行哪种探险任务。</p>\n<h1 id=\"面向切面编程\"><a href=\"#面向切面编程\" class=\"headerlink\" title=\"面向切面编程\"></a>面向切面编程</h1><p><strong>DI能够让相互协作的软件组件保持松散耦合，而面向切面编程(aspect-oriented programming，AOP)允许你把遍布应用各处的功能分离出来形成可重用的组件。</strong></p>\n<p>系统由许多不同的组件组成，每一个组件各负责一块特定功能。除了实现自身核心的功能之外，这些组件还经常承担着额外的职责。诸如日志、事务管理和安全这样的系统服务经常融入到本身具有核心业务逻辑的组件中去，这些系统服务通常被称为横切关注点，因为它们会跨越系统的多个组件。如果将这些关注点分散到多个组件中去，你的代码将会带来双重的复杂性：</p>\n<ul>\n<li>实现系统关注点功能的代码将会重复出现在多个组件中。这意味着如果你要改变这些关注点的逻辑，必须修改各个模块中的相关实现。即使你把这些关注点抽象为一个独立的模块，其他模块只是调用它的方法，但方法的调用还是会重复出现在各个模块中。</li>\n<li>组件会因为那些与自身核心业务无关的代码而变得混乱。一个向地址簿增加地址条目的方法应该只关注如何添加地址，而不应该关注它是不是安全的或者是否需要支持事务。</li>\n</ul>\n<p>AOP能够使这些服务模块化，并以声明的方式将它们应用到它们需要影响的组件中去。所造成的结果就是这些组件会具有更高的内聚性并且会更加关注自身的业务，完全不需要了解涉及系统服务所带来复杂性。总之，AOP能够确保POJO的简单性。</p>\n<p><strong>AOP的使用：</strong><br>每一个人都熟知骑士所做的任何事情，这是因为吟游诗人用诗歌记载了骑士的事迹并将其进行传唱。假设我们需要使用吟游诗人这个服务<br>类来记载骑士的所有事迹。Minstrel类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> sia.knights;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.io.PrintStream;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Minstrel</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">private</span> PrintStream stream;</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Minstrel</span><span class=\"params\">(PrintStream stream)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.stream = stream;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">//探险之前调用</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">singBeforeQuest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        stream.println(<span class=\"string\">\"Fa la la, the knight is so brave!\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">    </div><div class=\"line\">      <span class=\"comment\">//探险之后调用</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">singAfterQuest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        stream.println(<span class=\"string\">\"Tee hee hee, the brave knight \"</span> +</div><div class=\"line\">        \t\t<span class=\"string\">\"did embark on a quest!\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Minstrel是只有两个方法的简单类。在骑士执行每一个探险任务之前，singBeforeQuest()方法会被调用；在骑士完成探险任务之后，singAfterQuest()方法会被调用。在这两种情况下，Minstrel都会通过一个PrintStream类来歌颂骑士的事迹，这个类是通过构造器注入进来的。我们适当做一下调整从而让BraveKnight可以使用Minstrel：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> sia.knights;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BraveKnight</span> <span class=\"keyword\">implements</span> <span class=\"title\">Knight</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">private</span> Quest quest;</div><div class=\"line\">  <span class=\"keyword\">private</span> Minstrel minstrel;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BraveKnight</span><span class=\"params\">(Quest quest)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.quest = quest;</div><div class=\"line\">    <span class=\"keyword\">this</span>.minstrel = minstrel;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">embarkOnQuest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    minstrel.singBeforeQuest();</div><div class=\"line\">    quest.embark();</div><div class=\"line\">    minstrel.singAfterQuest();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这应该可以达到预期效果。现在，你所需要做的就是回到Spring配置中，声明Minstrel bean并将其注入到<br>BraveKnight的构造器之中。但是，管理吟游诗人的行为真的是骑士职责范围内的工作吗？在我看来，吟游诗人应该做他份内的事，根本不需要骑士命令他这么做。此外，因为骑士需要知道吟游诗人，所以就必须把吟游诗人注入到BarveKnight类中。这不仅使BraveKnight的代码复杂化了，而且还让我疑惑是否还需要一个不需要吟游诗人的骑士呢？如果Minstrel为null会发生什么呢？我是否应该引入一个空值校验逻辑来覆盖该场景？</p>\n<p>但利用AOP，你可以声明吟游诗人必须歌颂骑士的探险事迹，而骑士本身并不用直接访问Minstrel的方法。要将<br>Minstrel抽象为一个切面，你所需要做的事情就是在一个Spring配置文件中声明它。下面是更新后的knights.xml文件，Minstrel被声明为一个切面：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">  <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">  <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">\"http://www.springframework.org/schema/aop\"</span></div><div class=\"line\">  <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/aop </span></div><div class=\"line\">      http://www.springframework.org/schema/aop/spring-aop.xsd</div><div class=\"line\">\t\thttp://www.springframework.org/schema/beans </div><div class=\"line\">      http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"knight\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.BraveKnight\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"quest\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"quest\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.SlayDragonQuest\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;T(System).out&#125;\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!--声明minstrel bean--&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"minstrel\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.Minstrel\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;T(System).out&#125;\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!--定义切面--&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:aspect</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"minstrel\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">\"embark\"</span></span></div><div class=\"line\">          <span class=\"attr\">expression</span>=<span class=\"string\">\"execution(* *.embarkOnQuest(..))\"</span>/&gt;</div><div class=\"line\">      <span class=\"comment\">&lt;!--声明前置通知--&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">aop:before</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"embark\"</span> </span></div><div class=\"line\">          <span class=\"attr\">method</span>=<span class=\"string\">\"singBeforeQuest\"</span>/&gt;</div><div class=\"line\">      <span class=\"comment\">&lt;!--声明后置通知--&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">aop:after</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"embark\"</span> </span></div><div class=\"line\">          <span class=\"attr\">method</span>=<span class=\"string\">\"singAfterQuest\"</span>/&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">aop:aspect</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>这里使用了Spring的aop配置命名空间把Minstrel bean声明为一个切面。首先，需要把Minstrel声明为一个bean，然后在&lt; aop:aspect&gt;元素中引用该bean。为了进一步定义切面，声明（使用&lt; aop:before&gt;<br>）在embarkOnQuest()方法执行前调用Minstrel的singBeforeQuest()方法。这种方式被称为前置通知（before advice）。同时声明（使用&lt; aop:after&gt;）在embarkOnQuest()方法执行后调用singAfterQuest()方法。这种方式被称为后置通知（after advice）。<br>在这两种方式中，pointcut-ref属性都引用了名字为embank的切入点。该切入点是在前边的&lt; pointcut&gt;<br>元素中定义的，并配置expression属性来选择所应用的通知。表达式的语法采用的是AspectJ的切点表达式语言。这样Spring在骑士执行探险任务前后就会调用Minstrel的singBeforeQuest()和singAfterQuest()方法。</p>\n<p>Minstrel仍然是一个POJO，没有任何代码表明它要被作为一个切面使用。当我们按照上面那样进行配置后，在S<br>pring的上下文中，Minstrel实际上已经变成一个切面了。其次，也是最重要的，Minstrel可以被应用到BraveKnight中，而BraveKnight不需要显式地调用它。实际上，BraveKnight完全不知道Minstrel的存在。必须还要指出的是，尽管我们使用Spring魔法把Minstrel转变为一个切面，但首先要把它声明为一个Spring bean。能够为其他Spring bean做到的事情都可以同样应用到Spring切面中，例如为它们注入依赖。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Spring用bean或者JavaBean来表示应用组件，但并不意味着Spring组件必须要遵循JavaBean规范。一个Spring组件可以是任何形式的POJO。以下都采用JavaBean的广泛定义，即POJO的同义词。</p>\n<p>Spring的根本使命就是简化Java开发，而为了降低Java开发的复杂性，Spring采取了以下4种关键策略：</p>\n<ul>\n<li>基于POJO的轻量级和最小侵入性编程；</li>\n<li>通过依赖注入和面向接口实现松耦合；</li>\n<li>基于切面和惯例进行声明式编程；</li>\n<li>通过切面和模板减少样板式代码。</li>\n</ul>\n<h1 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h1><p><strong>通过DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象的时候进行设定。对象无需自行创建或管理它们的依赖关系。依赖注入主要是实现松耦合。</strong></p>\n<p>假如现在有一个骑士DamselRescuingKnight：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DamselRescuingKnight</span> <span class=\"keyword\">implements</span> <span class=\"title\">Knight</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">private</span> RescueDamselQuest quest;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DamselRescuingKnight</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.quest = <span class=\"keyword\">new</span> RescueDamselQuest();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">embarkOnQuest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    quest.embark();</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到DamselRescuingKnight这个类中有一个成员变量RescueDamselQuest，这是一个具体的探险任务类型，所以DamselRescuingKnight这个类型的骑士就只能执行RescueDamselQuest探险任务。这使得DamselRescuingKnight紧密地和RescueDamselQuest耦合到了一起，因此极大地限制了这个骑士执行探险的能力。<br>但是如果我们这样去实现：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BraveKnight</span> <span class=\"keyword\">implements</span> <span class=\"title\">Knight</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">private</span> Quest quest;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BraveKnight</span><span class=\"params\">(Quest quest)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.quest = quest;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">embarkOnQuest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    quest.embark();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到BraveKnight没有自行创建具体的探险任务，而是在构造的时候把探险任务作为构造器参数传入。这是依赖注入的方式之一，即构造器注入（constructor injection）。更重要的是，传入的探险类型是Quest，也就是所有探险任务都必须实现的一个接口。所以，BraveKnight能够响应RescueDamselQuest、 SlayDragonQuest、 MakeRoundTableRounderQuest等任意的Quest实现。这就是DI所带来的最大收益——松耦合。</p>\n<p>现在BraveKnight类可以接受你传递给它的任意一种Quest的实现，但该怎样把特定的Query实现传给它呢？假设，希望BraveKnight所要进行探险任务是杀死一只怪龙，那么SlayDragonQuest也许挺合适的。但是要怎么把SlayDragonQuest传给BraveKnight呢？</p>\n<p><strong>创建应用组件之间协作的行为通常称为装配（wiring）。Spring有多种装配bean的方式，采用XML是很常见的一种装配方式。</strong>这里就可以用knights.xml把SlayDragonQuest传给BraveKnight：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">  <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">  <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans </span></div><div class=\"line\">      http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"knight\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.BraveKnight\"</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!--注入Quest Bean--&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"quest\"</span> /&gt;</span> </div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"comment\">&lt;!--创建SlayDragonQuest--&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"quest\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.SlayDragonQuest\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;T(System).out&#125;\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>在这里，BraveKnight和SlayDragonQuest被声明为Spring中的bean。就BraveKnight bean来讲，它在构造时传入了对SlayDragonQuestbean的引用，将其作为构造器参数。同时，SlayDragonQuestbean的声明使用了Spring表达式语言（SpringExpressionLanguage），将System.out（这是一个PrintStream）传入到了SlayDragonQuest的构造器中。</p>\n<p><strong>Spring还支持使用Java来描述配置。</strong>下面的做法和上面xml的功能是一样的，都是将SlayDragonQuest注入到BraveKnight：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> sia.knights.config;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</div><div class=\"line\"><span class=\"keyword\">import</span> sia.knights.BraveKnight;</div><div class=\"line\"><span class=\"keyword\">import</span> sia.knights.Knight;</div><div class=\"line\"><span class=\"keyword\">import</span> sia.knights.Quest;</div><div class=\"line\"><span class=\"keyword\">import</span> sia.knights.SlayDragonQuest;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KnightConfig</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Bean</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Knight <span class=\"title\">knight</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BraveKnight(quest());</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Bean</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Quest <span class=\"title\">quest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SlayDragonQuest(System.out);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>不管你使用的是基于XML的配置还是基于Java的配置，DI所带来的收益都是相同的。尽管BraveKnight依赖于Quest，但是它并不知道传递给它的是什么类型的Quest，也不知道这个Quest来自哪里。只有Spring通过它的配置，能够了解这些组成部分是如何装配起来的。这样的话，就可以在不改变所依赖的类的情况下，修改依赖关系。</p>\n<p>现在已经声明了BraveKnight和Quest的关系，接下来我们只需要装载XML配置文件，并把应用启动起来。Spring通过应用上下文（Application Context）装载bean的定义并把它们组装起来。Spring应用上下文全权负责对象的创建和组装。Spring自带了多种应用上下文的实现，它们之间主要的区别仅仅在于如何加载配置。</p>\n<p>因为knights.xml中的bean是使用XML文件进行配置的，所以选择Class Path Xml Application Context作为应用上下文相对是比较合适的。该类加载位于应用程序类路径下的一个或多个XML配置文件。下面程序中的main()方法调用ClassPathXmlApplicationContext加载knights.xml，并获得Knight对象的引用。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> sia.knights;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KnightMain</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//加载Spring上下文</span></div><div class=\"line\">    ClassPathXmlApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"META-INF/spring/knight.xml\"</span>);</div><div class=\"line\">    <span class=\"comment\">//获取Knight Bean</span></div><div class=\"line\">    Knight knight = context.getBean(Knight.class);</div><div class=\"line\">    <span class=\"comment\">//使用Knight</span></div><div class=\"line\">    knight.embarkOnQuest();</div><div class=\"line\">    context.close();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里的main()方法基于knights.xml文件创建了Spring应用上下文。随后它调用该应用上下文获取一个ID为knight的bean。得到Knight对象的引用后，只需简单调用embarkOnQuest()方法就可以执行所赋予的探险任务了。注意这个类完全不知道我们的英雄骑士接受哪种探险任务，而且完全没有意识到这是由BraveKnight来执行的。只有knights.xml文件知道哪个骑士执行哪种探险任务。</p>\n<h1 id=\"面向切面编程\"><a href=\"#面向切面编程\" class=\"headerlink\" title=\"面向切面编程\"></a>面向切面编程</h1><p><strong>DI能够让相互协作的软件组件保持松散耦合，而面向切面编程(aspect-oriented programming，AOP)允许你把遍布应用各处的功能分离出来形成可重用的组件。</strong></p>\n<p>系统由许多不同的组件组成，每一个组件各负责一块特定功能。除了实现自身核心的功能之外，这些组件还经常承担着额外的职责。诸如日志、事务管理和安全这样的系统服务经常融入到本身具有核心业务逻辑的组件中去，这些系统服务通常被称为横切关注点，因为它们会跨越系统的多个组件。如果将这些关注点分散到多个组件中去，你的代码将会带来双重的复杂性：</p>\n<ul>\n<li>实现系统关注点功能的代码将会重复出现在多个组件中。这意味着如果你要改变这些关注点的逻辑，必须修改各个模块中的相关实现。即使你把这些关注点抽象为一个独立的模块，其他模块只是调用它的方法，但方法的调用还是会重复出现在各个模块中。</li>\n<li>组件会因为那些与自身核心业务无关的代码而变得混乱。一个向地址簿增加地址条目的方法应该只关注如何添加地址，而不应该关注它是不是安全的或者是否需要支持事务。</li>\n</ul>\n<p>AOP能够使这些服务模块化，并以声明的方式将它们应用到它们需要影响的组件中去。所造成的结果就是这些组件会具有更高的内聚性并且会更加关注自身的业务，完全不需要了解涉及系统服务所带来复杂性。总之，AOP能够确保POJO的简单性。</p>\n<p><strong>AOP的使用：</strong><br>每一个人都熟知骑士所做的任何事情，这是因为吟游诗人用诗歌记载了骑士的事迹并将其进行传唱。假设我们需要使用吟游诗人这个服务<br>类来记载骑士的所有事迹。Minstrel类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> sia.knights;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> java.io.PrintStream;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Minstrel</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">private</span> PrintStream stream;</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Minstrel</span><span class=\"params\">(PrintStream stream)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.stream = stream;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">//探险之前调用</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">singBeforeQuest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        stream.println(<span class=\"string\">\"Fa la la, the knight is so brave!\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">    </div><div class=\"line\">      <span class=\"comment\">//探险之后调用</span></div><div class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">singAfterQuest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        stream.println(<span class=\"string\">\"Tee hee hee, the brave knight \"</span> +</div><div class=\"line\">        \t\t<span class=\"string\">\"did embark on a quest!\"</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Minstrel是只有两个方法的简单类。在骑士执行每一个探险任务之前，singBeforeQuest()方法会被调用；在骑士完成探险任务之后，singAfterQuest()方法会被调用。在这两种情况下，Minstrel都会通过一个PrintStream类来歌颂骑士的事迹，这个类是通过构造器注入进来的。我们适当做一下调整从而让BraveKnight可以使用Minstrel：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> sia.knights;</div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BraveKnight</span> <span class=\"keyword\">implements</span> <span class=\"title\">Knight</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">private</span> Quest quest;</div><div class=\"line\">  <span class=\"keyword\">private</span> Minstrel minstrel;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BraveKnight</span><span class=\"params\">(Quest quest)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.quest = quest;</div><div class=\"line\">    <span class=\"keyword\">this</span>.minstrel = minstrel;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">embarkOnQuest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    minstrel.singBeforeQuest();</div><div class=\"line\">    quest.embark();</div><div class=\"line\">    minstrel.singAfterQuest();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这应该可以达到预期效果。现在，你所需要做的就是回到Spring配置中，声明Minstrel bean并将其注入到<br>BraveKnight的构造器之中。但是，管理吟游诗人的行为真的是骑士职责范围内的工作吗？在我看来，吟游诗人应该做他份内的事，根本不需要骑士命令他这么做。此外，因为骑士需要知道吟游诗人，所以就必须把吟游诗人注入到BarveKnight类中。这不仅使BraveKnight的代码复杂化了，而且还让我疑惑是否还需要一个不需要吟游诗人的骑士呢？如果Minstrel为null会发生什么呢？我是否应该引入一个空值校验逻辑来覆盖该场景？</p>\n<p>但利用AOP，你可以声明吟游诗人必须歌颂骑士的探险事迹，而骑士本身并不用直接访问Minstrel的方法。要将<br>Minstrel抽象为一个切面，你所需要做的事情就是在一个Spring配置文件中声明它。下面是更新后的knights.xml文件，Minstrel被声明为一个切面：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">  <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">  <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">\"http://www.springframework.org/schema/aop\"</span></div><div class=\"line\">  <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/aop </span></div><div class=\"line\">      http://www.springframework.org/schema/aop/spring-aop.xsd</div><div class=\"line\">\t\thttp://www.springframework.org/schema/beans </div><div class=\"line\">      http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"knight\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.BraveKnight\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"quest\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"quest\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.SlayDragonQuest\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;T(System).out&#125;\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!--声明minstrel bean--&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"minstrel\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"sia.knights.Minstrel\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;T(System).out&#125;\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">&lt;!--定义切面--&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:aspect</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"minstrel\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">\"embark\"</span></span></div><div class=\"line\">          <span class=\"attr\">expression</span>=<span class=\"string\">\"execution(* *.embarkOnQuest(..))\"</span>/&gt;</div><div class=\"line\">      <span class=\"comment\">&lt;!--声明前置通知--&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">aop:before</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"embark\"</span> </span></div><div class=\"line\">          <span class=\"attr\">method</span>=<span class=\"string\">\"singBeforeQuest\"</span>/&gt;</div><div class=\"line\">      <span class=\"comment\">&lt;!--声明后置通知--&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">aop:after</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"embark\"</span> </span></div><div class=\"line\">          <span class=\"attr\">method</span>=<span class=\"string\">\"singAfterQuest\"</span>/&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">aop:aspect</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>这里使用了Spring的aop配置命名空间把Minstrel bean声明为一个切面。首先，需要把Minstrel声明为一个bean，然后在&lt; aop:aspect&gt;元素中引用该bean。为了进一步定义切面，声明（使用&lt; aop:before&gt;<br>）在embarkOnQuest()方法执行前调用Minstrel的singBeforeQuest()方法。这种方式被称为前置通知（before advice）。同时声明（使用&lt; aop:after&gt;）在embarkOnQuest()方法执行后调用singAfterQuest()方法。这种方式被称为后置通知（after advice）。<br>在这两种方式中，pointcut-ref属性都引用了名字为embank的切入点。该切入点是在前边的&lt; pointcut&gt;<br>元素中定义的，并配置expression属性来选择所应用的通知。表达式的语法采用的是AspectJ的切点表达式语言。这样Spring在骑士执行探险任务前后就会调用Minstrel的singBeforeQuest()和singAfterQuest()方法。</p>\n<p>Minstrel仍然是一个POJO，没有任何代码表明它要被作为一个切面使用。当我们按照上面那样进行配置后，在S<br>pring的上下文中，Minstrel实际上已经变成一个切面了。其次，也是最重要的，Minstrel可以被应用到BraveKnight中，而BraveKnight不需要显式地调用它。实际上，BraveKnight完全不知道Minstrel的存在。必须还要指出的是，尽管我们使用Spring魔法把Minstrel转变为一个切面，但首先要把它声明为一个Spring bean。能够为其他Spring bean做到的事情都可以同样应用到Spring切面中，例如为它们注入依赖。</p>\n"},{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">Spring实战（四） 通过Java代码装配Bean</font>","date":"2017-06-09T01:44:26.000Z","_content":"\n尽管在很多场景下通过组件扫描和自动装配实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如说，你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加@Component和@Autowired注解的，因此就不能使用自动化装配的方案了。\n\n在这种情况下，你必须要采用显式装配的方式。在进行显式配置的时候，有两种可选方案：Java和XML。\n就像我之前所说的，在进行显式配置时，JavaConfig是更好的方案，因为它更为强大、类型安全并且对重构友好。因为它就是Java代码，就像应用程序中的其他Java代码一样。\n\n同时，JavaConfig与其他的Java代码又有所区别，在概念上，它与应用程序中的业务逻辑和领域代码是不同的。尽管它与其他的组件一样都使用相同的语言进行表述，但JavaConfig是配置代码。这意味着它不应该包含任何业务逻辑，Java Config也不应该侵入到业务逻辑代码之中。尽管不是必须的，但通常会将JavaConfig放到单独的包中，使它与其他的应用程序逻辑分离开来，这样对于它的意图就不会产生困惑了。\n\n接下来，让我们看一下如何通过JavaConfig显式配置Spring，之前写过一个CDPlayerConfig的配置类：\n```java\npackage soundsystem\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class CDPlayerConfig{\n}\n```\n创建JavaConfig类的关键在于为其添加@Configuration注解，@Configuration注解表明这个类是一个配置类，该类应该包含在Spring应用上下文中如何创建bean的细节。之前，我们都是依赖组件扫描来发现Spring应该创建的bean。尽管我们可以同时使用组件扫描和显式配置，但是在本节中，我们更加关注于显式配置，因此我将CDPlayerConfig的@ComponentScan注解移除掉了。\n移除了@ComponentScan注解，此时的CDPlayerConfig类就没有任何作用了。如果你现在运行CDPlayerTest的话，测试会失败，并且会出现BeanCreationException异常。测试期望被注入CDPlayer和CompactDisc，但是这些b\nean根本就没有创建，因为组件扫描不会发现它们。\n要如何使用JavaConfig装配CDPlayer和CompactDisc呢？\n\n声明简单的Bean\n------------\n要在JavaConfig中声明bean，我们需要编写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加\n@Bean注解。比方说，下面的代码声明了CompactDisc bean：\n```java\n@Bean\npublic CompactDisc sgtpeppers(){\n    return new Sgtpeppers();\n}\n```\n@Bean注解会告诉Spring这个方法将会返回一个对象，该对象要注册为Spring应用上下文中的bean。方法体中包含了最终产生bean实例的逻辑。默认情况下，bean的ID与带有@Bean注解的方法名是一样的。在本例中，bean的名字将会是sgtPeppers。如果你想为其设置成一个不同的名字的话，那么可以重命名该方法，也可以通过name属性指定一个不同的名字：\n```java\n@Bean(name=\"lonelyHeartsClubBand\")\npublic CompactDisc sgtpeppers(){\n    return new Sgtpeppers();\n}\n```\n不管你采用什么方法来为bean命名，bean声明都是非常简单的。方法体返回了一个新的SgtPeppers实例。这里是使用Java来进行描述的，因此我们可以发挥Java提供的所有功能，只要最终生成一个CompactDisc实例即可。\n\n请稍微发挥一下你的想象力，我们可能希望做一点稍微疯狂的事情，比如说，在一组CD中随机选择一个CompactDisc来播放：\n```java\n@Bean\npublci CompactDisc randomBeatlesCD(){\n    int choice = (int) Math.floor(Math.random()*4);\n    if(choice == 0){\n        return new SgtPeppers();\n    }else if(choice == 1){\n        return new HardDaysNight();\n    }else if(choice == 2){\n        return new Revolver();\n    }else{\n        return new WhiteAlbum();\n    }\n}\n```\n\n借助JavaConfig实现注入\n--------------\n我们前面所声明的CompactDisc bean是非常简单的，它自身没有其他的依赖。但现在，我们需要声明CDPlayerbean，它依赖于CompactDisc。在JavaConfig中，要如何将它们装配在一起呢?\n在JavaConfig中装配bean的最简单方式就是引用创建bean的方法。例如，下面就是一种声明CDPlayer的可行方案：\n```java\n@Bean\npublic CDPlayeer cdPlayer(){\n    return new CDPlayer(sgtPeppers());\n}\n```\ncdPlayer()方法像sgtPeppers()方法一样，同样使用了@Bean注解，这表明这个方法会创建一个bean实例并将其注册到Spring应用上下文中。所创建的beanID为cdPlayer，与方法的名字相同。\n\n看起来，CompactDisc是通过调用sgtPeppers()得到的，但情况并非完全如此。因为sgtPeppers()方法上添加了@Bean注解，Spring将会拦截所有对它的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。比如说，假设你引入了一个其他的CDPlayer bean，它和之前的那个bean完全一样：\n```java\n@Bean\npublic CDPlayeer cdPlayer(){\n    return new CDPlayer(sgtPeppers());\n}\n\n@Bean\npublic CDPlayeer anothorCDPlayer(){\n    return new CDPlayer(sgtPeppers());\n}\n```\n假如对sgtPeppers()的调用就像其他的Java方法调用一样的话，那么每个CDPlayer实例都会有一个自己特有的\nSgtPeppers实例。如果我们讨论的是实际的CD播放器和CD光盘的话，这么做是有意义的。如果你有两台CD播放器，在物理上并没有办法将同一张CD光盘放到两个CD播放器中。\n\n但是，在软件领域中，我们完全可以将同一个SgtPeppers实例注入到任意数量的其他bean之中。默认情况下，Spring中的bean都是单例的，我们并没有必要为第二个CDPlayerbean创建完全相同的SgtPeppers实例。所以，Spring会拦截对sgtPeppers()的调用并确保返回的是Spring所创建的bean，也就是Spring本身在调用sgtPeppers()时所创建的CompactDiscbean。因此，两个CDPlayer bean会得到相同的SgtPeppers实例。\n\n可以看到，通过调用方法来引用bean的方式有点令人困惑。其实还有一种理解起来更为简单的方式：\n```java\n@Bean\npublic CDPlayer cdPlayer(CompactDisc compactDisc){\n    return new CDPlayer(compactDisc);\n}\n```\n在这里，cdPlayer()方法请求一个CompactDisc作为参数。当Spring调用cdPlayer()创建CDPlayerbean的时候，它会自动装配一个CompactDisc到配置方法之中。然后，方法体就可以按照合适的方式来使用它。借助这种技术，cdPlayer()方法也能够将CompactDisc注入到CDPlayer的构造器中，而且不用明确引用CompactDisc的@Bean方法。\n\n通过这种方式引用其他的bean通常是最佳的选择，因为它不会要求将CompactDisc声明到同一个配置类之中。在这里甚至没有要求CompactDisc必须要在JavaConfig中声明，实际上它可以通过组件扫描功能自动发现或者通过XML来进行配置。你可以将配置分散到多个配置类、XML文件以及自动扫描和装配bean之中，只要功能完整健全即可。不管CompactDisc是采用什么方式创建出来的，Spring都会将其传入到配置方法中，并用来创建CDPlayer bean。\n\n另外，需要提醒的是，我们在这里使用CDPlayer的构造器实现了DI功能，但是我们完全可以采用其他风格的D\nI配置。比如说，如果你想通过Setter方法注入CompactDisc的话，那么代码看起来应该是这样的：\n```java\n@Bean\npublic CDPlayer cdPlayer(CompactDisc compactDisc){\n    CDPlayer cdPlayer = new CDPlayer();\n    cdPlayer.setCompactDisc(compactDisc);\n    return cdPlayer;\n}\n```\n带有@Bean注解的方法可以采用任何必要的Java功能来产生bean实例。构造器和Setter方法只是@Bean方法的两个简单样例。这里所存在的可能性仅仅受到Java语言的限制。\n\n","source":"_posts/Spring实战（三） 通过Java代码装配Bean.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">Spring实战（四） 通过Java代码装配Bean</font>\ndate: 2017-06-09 09:44:26\ncategories: java读书笔记\ntags: [java,Spring,Bean,Java装配]\n---\n\n尽管在很多场景下通过组件扫描和自动装配实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如说，你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加@Component和@Autowired注解的，因此就不能使用自动化装配的方案了。\n\n在这种情况下，你必须要采用显式装配的方式。在进行显式配置的时候，有两种可选方案：Java和XML。\n就像我之前所说的，在进行显式配置时，JavaConfig是更好的方案，因为它更为强大、类型安全并且对重构友好。因为它就是Java代码，就像应用程序中的其他Java代码一样。\n\n同时，JavaConfig与其他的Java代码又有所区别，在概念上，它与应用程序中的业务逻辑和领域代码是不同的。尽管它与其他的组件一样都使用相同的语言进行表述，但JavaConfig是配置代码。这意味着它不应该包含任何业务逻辑，Java Config也不应该侵入到业务逻辑代码之中。尽管不是必须的，但通常会将JavaConfig放到单独的包中，使它与其他的应用程序逻辑分离开来，这样对于它的意图就不会产生困惑了。\n\n接下来，让我们看一下如何通过JavaConfig显式配置Spring，之前写过一个CDPlayerConfig的配置类：\n```java\npackage soundsystem\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class CDPlayerConfig{\n}\n```\n创建JavaConfig类的关键在于为其添加@Configuration注解，@Configuration注解表明这个类是一个配置类，该类应该包含在Spring应用上下文中如何创建bean的细节。之前，我们都是依赖组件扫描来发现Spring应该创建的bean。尽管我们可以同时使用组件扫描和显式配置，但是在本节中，我们更加关注于显式配置，因此我将CDPlayerConfig的@ComponentScan注解移除掉了。\n移除了@ComponentScan注解，此时的CDPlayerConfig类就没有任何作用了。如果你现在运行CDPlayerTest的话，测试会失败，并且会出现BeanCreationException异常。测试期望被注入CDPlayer和CompactDisc，但是这些b\nean根本就没有创建，因为组件扫描不会发现它们。\n要如何使用JavaConfig装配CDPlayer和CompactDisc呢？\n\n声明简单的Bean\n------------\n要在JavaConfig中声明bean，我们需要编写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加\n@Bean注解。比方说，下面的代码声明了CompactDisc bean：\n```java\n@Bean\npublic CompactDisc sgtpeppers(){\n    return new Sgtpeppers();\n}\n```\n@Bean注解会告诉Spring这个方法将会返回一个对象，该对象要注册为Spring应用上下文中的bean。方法体中包含了最终产生bean实例的逻辑。默认情况下，bean的ID与带有@Bean注解的方法名是一样的。在本例中，bean的名字将会是sgtPeppers。如果你想为其设置成一个不同的名字的话，那么可以重命名该方法，也可以通过name属性指定一个不同的名字：\n```java\n@Bean(name=\"lonelyHeartsClubBand\")\npublic CompactDisc sgtpeppers(){\n    return new Sgtpeppers();\n}\n```\n不管你采用什么方法来为bean命名，bean声明都是非常简单的。方法体返回了一个新的SgtPeppers实例。这里是使用Java来进行描述的，因此我们可以发挥Java提供的所有功能，只要最终生成一个CompactDisc实例即可。\n\n请稍微发挥一下你的想象力，我们可能希望做一点稍微疯狂的事情，比如说，在一组CD中随机选择一个CompactDisc来播放：\n```java\n@Bean\npublci CompactDisc randomBeatlesCD(){\n    int choice = (int) Math.floor(Math.random()*4);\n    if(choice == 0){\n        return new SgtPeppers();\n    }else if(choice == 1){\n        return new HardDaysNight();\n    }else if(choice == 2){\n        return new Revolver();\n    }else{\n        return new WhiteAlbum();\n    }\n}\n```\n\n借助JavaConfig实现注入\n--------------\n我们前面所声明的CompactDisc bean是非常简单的，它自身没有其他的依赖。但现在，我们需要声明CDPlayerbean，它依赖于CompactDisc。在JavaConfig中，要如何将它们装配在一起呢?\n在JavaConfig中装配bean的最简单方式就是引用创建bean的方法。例如，下面就是一种声明CDPlayer的可行方案：\n```java\n@Bean\npublic CDPlayeer cdPlayer(){\n    return new CDPlayer(sgtPeppers());\n}\n```\ncdPlayer()方法像sgtPeppers()方法一样，同样使用了@Bean注解，这表明这个方法会创建一个bean实例并将其注册到Spring应用上下文中。所创建的beanID为cdPlayer，与方法的名字相同。\n\n看起来，CompactDisc是通过调用sgtPeppers()得到的，但情况并非完全如此。因为sgtPeppers()方法上添加了@Bean注解，Spring将会拦截所有对它的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。比如说，假设你引入了一个其他的CDPlayer bean，它和之前的那个bean完全一样：\n```java\n@Bean\npublic CDPlayeer cdPlayer(){\n    return new CDPlayer(sgtPeppers());\n}\n\n@Bean\npublic CDPlayeer anothorCDPlayer(){\n    return new CDPlayer(sgtPeppers());\n}\n```\n假如对sgtPeppers()的调用就像其他的Java方法调用一样的话，那么每个CDPlayer实例都会有一个自己特有的\nSgtPeppers实例。如果我们讨论的是实际的CD播放器和CD光盘的话，这么做是有意义的。如果你有两台CD播放器，在物理上并没有办法将同一张CD光盘放到两个CD播放器中。\n\n但是，在软件领域中，我们完全可以将同一个SgtPeppers实例注入到任意数量的其他bean之中。默认情况下，Spring中的bean都是单例的，我们并没有必要为第二个CDPlayerbean创建完全相同的SgtPeppers实例。所以，Spring会拦截对sgtPeppers()的调用并确保返回的是Spring所创建的bean，也就是Spring本身在调用sgtPeppers()时所创建的CompactDiscbean。因此，两个CDPlayer bean会得到相同的SgtPeppers实例。\n\n可以看到，通过调用方法来引用bean的方式有点令人困惑。其实还有一种理解起来更为简单的方式：\n```java\n@Bean\npublic CDPlayer cdPlayer(CompactDisc compactDisc){\n    return new CDPlayer(compactDisc);\n}\n```\n在这里，cdPlayer()方法请求一个CompactDisc作为参数。当Spring调用cdPlayer()创建CDPlayerbean的时候，它会自动装配一个CompactDisc到配置方法之中。然后，方法体就可以按照合适的方式来使用它。借助这种技术，cdPlayer()方法也能够将CompactDisc注入到CDPlayer的构造器中，而且不用明确引用CompactDisc的@Bean方法。\n\n通过这种方式引用其他的bean通常是最佳的选择，因为它不会要求将CompactDisc声明到同一个配置类之中。在这里甚至没有要求CompactDisc必须要在JavaConfig中声明，实际上它可以通过组件扫描功能自动发现或者通过XML来进行配置。你可以将配置分散到多个配置类、XML文件以及自动扫描和装配bean之中，只要功能完整健全即可。不管CompactDisc是采用什么方式创建出来的，Spring都会将其传入到配置方法中，并用来创建CDPlayer bean。\n\n另外，需要提醒的是，我们在这里使用CDPlayer的构造器实现了DI功能，但是我们完全可以采用其他风格的D\nI配置。比如说，如果你想通过Setter方法注入CompactDisc的话，那么代码看起来应该是这样的：\n```java\n@Bean\npublic CDPlayer cdPlayer(CompactDisc compactDisc){\n    CDPlayer cdPlayer = new CDPlayer();\n    cdPlayer.setCompactDisc(compactDisc);\n    return cdPlayer;\n}\n```\n带有@Bean注解的方法可以采用任何必要的Java功能来产生bean实例。构造器和Setter方法只是@Bean方法的两个简单样例。这里所存在的可能性仅仅受到Java语言的限制。\n\n","slug":"Spring实战（三） 通过Java代码装配Bean","published":1,"updated":"2017-07-12T01:48:17.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hso08000iasvlm3tb7jaw","content":"<p>尽管在很多场景下通过组件扫描和自动装配实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如说，你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加@Component和@Autowired注解的，因此就不能使用自动化装配的方案了。</p>\n<p>在这种情况下，你必须要采用显式装配的方式。在进行显式配置的时候，有两种可选方案：Java和XML。<br>就像我之前所说的，在进行显式配置时，JavaConfig是更好的方案，因为它更为强大、类型安全并且对重构友好。因为它就是Java代码，就像应用程序中的其他Java代码一样。</p>\n<p>同时，JavaConfig与其他的Java代码又有所区别，在概念上，它与应用程序中的业务逻辑和领域代码是不同的。尽管它与其他的组件一样都使用相同的语言进行表述，但JavaConfig是配置代码。这意味着它不应该包含任何业务逻辑，Java Config也不应该侵入到业务逻辑代码之中。尽管不是必须的，但通常会将JavaConfig放到单独的包中，使它与其他的应用程序逻辑分离开来，这样对于它的意图就不会产生困惑了。</p>\n<p>接下来，让我们看一下如何通过JavaConfig显式配置Spring，之前写过一个CDPlayerConfig的配置类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span></span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>创建JavaConfig类的关键在于为其添加@Configuration注解，@Configuration注解表明这个类是一个配置类，该类应该包含在Spring应用上下文中如何创建bean的细节。之前，我们都是依赖组件扫描来发现Spring应该创建的bean。尽管我们可以同时使用组件扫描和显式配置，但是在本节中，我们更加关注于显式配置，因此我将CDPlayerConfig的@ComponentScan注解移除掉了。<br>移除了@ComponentScan注解，此时的CDPlayerConfig类就没有任何作用了。如果你现在运行CDPlayerTest的话，测试会失败，并且会出现BeanCreationException异常。测试期望被注入CDPlayer和CompactDisc，但是这些b<br>ean根本就没有创建，因为组件扫描不会发现它们。<br>要如何使用JavaConfig装配CDPlayer和CompactDisc呢？</p>\n<h2 id=\"声明简单的Bean\"><a href=\"#声明简单的Bean\" class=\"headerlink\" title=\"声明简单的Bean\"></a>声明简单的Bean</h2><p>要在JavaConfig中声明bean，我们需要编写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加<br>@Bean注解。比方说，下面的代码声明了CompactDisc bean：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CompactDisc <span class=\"title\">sgtpeppers</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Sgtpeppers();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>@Bean注解会告诉Spring这个方法将会返回一个对象，该对象要注册为Spring应用上下文中的bean。方法体中包含了最终产生bean实例的逻辑。默认情况下，bean的ID与带有@Bean注解的方法名是一样的。在本例中，bean的名字将会是sgtPeppers。如果你想为其设置成一个不同的名字的话，那么可以重命名该方法，也可以通过name属性指定一个不同的名字：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span>(name=<span class=\"string\">\"lonelyHeartsClubBand\"</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CompactDisc <span class=\"title\">sgtpeppers</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Sgtpeppers();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>不管你采用什么方法来为bean命名，bean声明都是非常简单的。方法体返回了一个新的SgtPeppers实例。这里是使用Java来进行描述的，因此我们可以发挥Java提供的所有功能，只要最终生成一个CompactDisc实例即可。</p>\n<p>请稍微发挥一下你的想象力，我们可能希望做一点稍微疯狂的事情，比如说，在一组CD中随机选择一个CompactDisc来播放：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\">publci CompactDisc <span class=\"title\">randomBeatlesCD</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> choice = (<span class=\"keyword\">int</span>) Math.floor(Math.random()*<span class=\"number\">4</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>(choice == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SgtPeppers();</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(choice == <span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HardDaysNight();</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(choice == <span class=\"number\">2</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Revolver();</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WhiteAlbum();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"借助JavaConfig实现注入\"><a href=\"#借助JavaConfig实现注入\" class=\"headerlink\" title=\"借助JavaConfig实现注入\"></a>借助JavaConfig实现注入</h2><p>我们前面所声明的CompactDisc bean是非常简单的，它自身没有其他的依赖。但现在，我们需要声明CDPlayerbean，它依赖于CompactDisc。在JavaConfig中，要如何将它们装配在一起呢?<br>在JavaConfig中装配bean的最简单方式就是引用创建bean的方法。例如，下面就是一种声明CDPlayer的可行方案：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CDPlayeer <span class=\"title\">cdPlayer</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CDPlayer(sgtPeppers());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>cdPlayer()方法像sgtPeppers()方法一样，同样使用了@Bean注解，这表明这个方法会创建一个bean实例并将其注册到Spring应用上下文中。所创建的beanID为cdPlayer，与方法的名字相同。</p>\n<p>看起来，CompactDisc是通过调用sgtPeppers()得到的，但情况并非完全如此。因为sgtPeppers()方法上添加了@Bean注解，Spring将会拦截所有对它的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。比如说，假设你引入了一个其他的CDPlayer bean，它和之前的那个bean完全一样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CDPlayeer <span class=\"title\">cdPlayer</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CDPlayer(sgtPeppers());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CDPlayeer <span class=\"title\">anothorCDPlayer</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CDPlayer(sgtPeppers());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>假如对sgtPeppers()的调用就像其他的Java方法调用一样的话，那么每个CDPlayer实例都会有一个自己特有的<br>SgtPeppers实例。如果我们讨论的是实际的CD播放器和CD光盘的话，这么做是有意义的。如果你有两台CD播放器，在物理上并没有办法将同一张CD光盘放到两个CD播放器中。</p>\n<p>但是，在软件领域中，我们完全可以将同一个SgtPeppers实例注入到任意数量的其他bean之中。默认情况下，Spring中的bean都是单例的，我们并没有必要为第二个CDPlayerbean创建完全相同的SgtPeppers实例。所以，Spring会拦截对sgtPeppers()的调用并确保返回的是Spring所创建的bean，也就是Spring本身在调用sgtPeppers()时所创建的CompactDiscbean。因此，两个CDPlayer bean会得到相同的SgtPeppers实例。</p>\n<p>可以看到，通过调用方法来引用bean的方式有点令人困惑。其实还有一种理解起来更为简单的方式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CDPlayer <span class=\"title\">cdPlayer</span><span class=\"params\">(CompactDisc compactDisc)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CDPlayer(compactDisc);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这里，cdPlayer()方法请求一个CompactDisc作为参数。当Spring调用cdPlayer()创建CDPlayerbean的时候，它会自动装配一个CompactDisc到配置方法之中。然后，方法体就可以按照合适的方式来使用它。借助这种技术，cdPlayer()方法也能够将CompactDisc注入到CDPlayer的构造器中，而且不用明确引用CompactDisc的@Bean方法。</p>\n<p>通过这种方式引用其他的bean通常是最佳的选择，因为它不会要求将CompactDisc声明到同一个配置类之中。在这里甚至没有要求CompactDisc必须要在JavaConfig中声明，实际上它可以通过组件扫描功能自动发现或者通过XML来进行配置。你可以将配置分散到多个配置类、XML文件以及自动扫描和装配bean之中，只要功能完整健全即可。不管CompactDisc是采用什么方式创建出来的，Spring都会将其传入到配置方法中，并用来创建CDPlayer bean。</p>\n<p>另外，需要提醒的是，我们在这里使用CDPlayer的构造器实现了DI功能，但是我们完全可以采用其他风格的D<br>I配置。比如说，如果你想通过Setter方法注入CompactDisc的话，那么代码看起来应该是这样的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CDPlayer <span class=\"title\">cdPlayer</span><span class=\"params\">(CompactDisc compactDisc)</span></span>&#123;</div><div class=\"line\">    CDPlayer cdPlayer = <span class=\"keyword\">new</span> CDPlayer();</div><div class=\"line\">    cdPlayer.setCompactDisc(compactDisc);</div><div class=\"line\">    <span class=\"keyword\">return</span> cdPlayer;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>带有@Bean注解的方法可以采用任何必要的Java功能来产生bean实例。构造器和Setter方法只是@Bean方法的两个简单样例。这里所存在的可能性仅仅受到Java语言的限制。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>尽管在很多场景下通过组件扫描和自动装配实现Spring的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要明确配置Spring。比如说，你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加@Component和@Autowired注解的，因此就不能使用自动化装配的方案了。</p>\n<p>在这种情况下，你必须要采用显式装配的方式。在进行显式配置的时候，有两种可选方案：Java和XML。<br>就像我之前所说的，在进行显式配置时，JavaConfig是更好的方案，因为它更为强大、类型安全并且对重构友好。因为它就是Java代码，就像应用程序中的其他Java代码一样。</p>\n<p>同时，JavaConfig与其他的Java代码又有所区别，在概念上，它与应用程序中的业务逻辑和领域代码是不同的。尽管它与其他的组件一样都使用相同的语言进行表述，但JavaConfig是配置代码。这意味着它不应该包含任何业务逻辑，Java Config也不应该侵入到业务逻辑代码之中。尽管不是必须的，但通常会将JavaConfig放到单独的包中，使它与其他的应用程序逻辑分离开来，这样对于它的意图就不会产生困惑了。</p>\n<p>接下来，让我们看一下如何通过JavaConfig显式配置Spring，之前写过一个CDPlayerConfig的配置类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span></span>&#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>创建JavaConfig类的关键在于为其添加@Configuration注解，@Configuration注解表明这个类是一个配置类，该类应该包含在Spring应用上下文中如何创建bean的细节。之前，我们都是依赖组件扫描来发现Spring应该创建的bean。尽管我们可以同时使用组件扫描和显式配置，但是在本节中，我们更加关注于显式配置，因此我将CDPlayerConfig的@ComponentScan注解移除掉了。<br>移除了@ComponentScan注解，此时的CDPlayerConfig类就没有任何作用了。如果你现在运行CDPlayerTest的话，测试会失败，并且会出现BeanCreationException异常。测试期望被注入CDPlayer和CompactDisc，但是这些b<br>ean根本就没有创建，因为组件扫描不会发现它们。<br>要如何使用JavaConfig装配CDPlayer和CompactDisc呢？</p>\n<h2 id=\"声明简单的Bean\"><a href=\"#声明简单的Bean\" class=\"headerlink\" title=\"声明简单的Bean\"></a>声明简单的Bean</h2><p>要在JavaConfig中声明bean，我们需要编写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加<br>@Bean注解。比方说，下面的代码声明了CompactDisc bean：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CompactDisc <span class=\"title\">sgtpeppers</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Sgtpeppers();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>@Bean注解会告诉Spring这个方法将会返回一个对象，该对象要注册为Spring应用上下文中的bean。方法体中包含了最终产生bean实例的逻辑。默认情况下，bean的ID与带有@Bean注解的方法名是一样的。在本例中，bean的名字将会是sgtPeppers。如果你想为其设置成一个不同的名字的话，那么可以重命名该方法，也可以通过name属性指定一个不同的名字：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span>(name=<span class=\"string\">\"lonelyHeartsClubBand\"</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CompactDisc <span class=\"title\">sgtpeppers</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Sgtpeppers();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>不管你采用什么方法来为bean命名，bean声明都是非常简单的。方法体返回了一个新的SgtPeppers实例。这里是使用Java来进行描述的，因此我们可以发挥Java提供的所有功能，只要最终生成一个CompactDisc实例即可。</p>\n<p>请稍微发挥一下你的想象力，我们可能希望做一点稍微疯狂的事情，比如说，在一组CD中随机选择一个CompactDisc来播放：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\">publci CompactDisc <span class=\"title\">randomBeatlesCD</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> choice = (<span class=\"keyword\">int</span>) Math.floor(Math.random()*<span class=\"number\">4</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span>(choice == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SgtPeppers();</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(choice == <span class=\"number\">1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HardDaysNight();</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(choice == <span class=\"number\">2</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Revolver();</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WhiteAlbum();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"借助JavaConfig实现注入\"><a href=\"#借助JavaConfig实现注入\" class=\"headerlink\" title=\"借助JavaConfig实现注入\"></a>借助JavaConfig实现注入</h2><p>我们前面所声明的CompactDisc bean是非常简单的，它自身没有其他的依赖。但现在，我们需要声明CDPlayerbean，它依赖于CompactDisc。在JavaConfig中，要如何将它们装配在一起呢?<br>在JavaConfig中装配bean的最简单方式就是引用创建bean的方法。例如，下面就是一种声明CDPlayer的可行方案：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CDPlayeer <span class=\"title\">cdPlayer</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CDPlayer(sgtPeppers());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>cdPlayer()方法像sgtPeppers()方法一样，同样使用了@Bean注解，这表明这个方法会创建一个bean实例并将其注册到Spring应用上下文中。所创建的beanID为cdPlayer，与方法的名字相同。</p>\n<p>看起来，CompactDisc是通过调用sgtPeppers()得到的，但情况并非完全如此。因为sgtPeppers()方法上添加了@Bean注解，Spring将会拦截所有对它的调用，并确保直接返回该方法所创建的bean，而不是每次都对其进行实际的调用。比如说，假设你引入了一个其他的CDPlayer bean，它和之前的那个bean完全一样：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CDPlayeer <span class=\"title\">cdPlayer</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CDPlayer(sgtPeppers());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CDPlayeer <span class=\"title\">anothorCDPlayer</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CDPlayer(sgtPeppers());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>假如对sgtPeppers()的调用就像其他的Java方法调用一样的话，那么每个CDPlayer实例都会有一个自己特有的<br>SgtPeppers实例。如果我们讨论的是实际的CD播放器和CD光盘的话，这么做是有意义的。如果你有两台CD播放器，在物理上并没有办法将同一张CD光盘放到两个CD播放器中。</p>\n<p>但是，在软件领域中，我们完全可以将同一个SgtPeppers实例注入到任意数量的其他bean之中。默认情况下，Spring中的bean都是单例的，我们并没有必要为第二个CDPlayerbean创建完全相同的SgtPeppers实例。所以，Spring会拦截对sgtPeppers()的调用并确保返回的是Spring所创建的bean，也就是Spring本身在调用sgtPeppers()时所创建的CompactDiscbean。因此，两个CDPlayer bean会得到相同的SgtPeppers实例。</p>\n<p>可以看到，通过调用方法来引用bean的方式有点令人困惑。其实还有一种理解起来更为简单的方式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CDPlayer <span class=\"title\">cdPlayer</span><span class=\"params\">(CompactDisc compactDisc)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CDPlayer(compactDisc);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这里，cdPlayer()方法请求一个CompactDisc作为参数。当Spring调用cdPlayer()创建CDPlayerbean的时候，它会自动装配一个CompactDisc到配置方法之中。然后，方法体就可以按照合适的方式来使用它。借助这种技术，cdPlayer()方法也能够将CompactDisc注入到CDPlayer的构造器中，而且不用明确引用CompactDisc的@Bean方法。</p>\n<p>通过这种方式引用其他的bean通常是最佳的选择，因为它不会要求将CompactDisc声明到同一个配置类之中。在这里甚至没有要求CompactDisc必须要在JavaConfig中声明，实际上它可以通过组件扫描功能自动发现或者通过XML来进行配置。你可以将配置分散到多个配置类、XML文件以及自动扫描和装配bean之中，只要功能完整健全即可。不管CompactDisc是采用什么方式创建出来的，Spring都会将其传入到配置方法中，并用来创建CDPlayer bean。</p>\n<p>另外，需要提醒的是，我们在这里使用CDPlayer的构造器实现了DI功能，但是我们完全可以采用其他风格的D<br>I配置。比如说，如果你想通过Setter方法注入CompactDisc的话，那么代码看起来应该是这样的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Bean</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CDPlayer <span class=\"title\">cdPlayer</span><span class=\"params\">(CompactDisc compactDisc)</span></span>&#123;</div><div class=\"line\">    CDPlayer cdPlayer = <span class=\"keyword\">new</span> CDPlayer();</div><div class=\"line\">    cdPlayer.setCompactDisc(compactDisc);</div><div class=\"line\">    <span class=\"keyword\">return</span> cdPlayer;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>带有@Bean注解的方法可以采用任何必要的Java功能来产生bean实例。构造器和Setter方法只是@Bean方法的两个简单样例。这里所存在的可能性仅仅受到Java语言的限制。</p>\n"},{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">Spring实战（二）上下文Context和Bean的生命周期</font>","date":"2017-06-06T11:43:56.000Z","_content":"在基于Spring的应用中，你的应用对象生存于Spring容器（container）中。Spring容器负责创建对象，装配它们，配置它们并管理它们的整个生命周期，从生存到死亡（在这里，可能就是new到finalize()）。容器是Spring框架的核心。Spring容器使用DI管理构成应用的组件，它会创建相互协作的组件之间的关联。\n\nSpring容器并不是只有一个。Spring自带了多个容器实现，可以归为两种不同的类型。**bean工厂**（由org.springframework.beans.factory.eanFactory接口定义）是最简单的容器，提供基本的DI支持。**应用上下文**（由org.springframework.context.ApplicationContext接口定义）基于BeanFactory构建，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。但是实际应用中，我们往往都会使用应用上下文。\n\n使用应用上下文\n=====\nSpring自带了多种类型的应用上下文。下面罗列的几个是你最有可能遇到的：\n\n- AnnotationConfigApplicationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。\n- AnnotationConfigWebApplicationContext：从一个或多个基于Java的配置类中加载SpringWeb应用上下文。\n- ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。\n- FileSystemXmlapplicationcontext：从文件系统下的一个或多个XML配置文件中加载上下文定义。\n- XmlWebApplicationContext：从Web应用下的一个或多个XML配置文件中加载上下文定义。\n\n如下代码展示了如何加载一个FileSystemXmlApplicationContext：\n```java\nApplicationContext context = new FileSystemXmlApplicationContext(\"c:/knight.xml\");\n```\n类似地，也可以使用ClassPathXmlApplicationContext从应用的类路径下加载应用上下文：\n```java\nApplicationContext context = new ClassPathXmlApplicationContext(\"knight.xml\");\n```\n使用FileSystemXmlApplicationContext和使用ClassPathXmlApplicationContext的区别在于：FileSystemXmlApplicationContext在指定的文件系统路径下查找knight.xml文件；而ClassPathXmlApplicationContext是在所有的类路径（包含JAR文件）下查找knight.xml文件。\n\n如果你想从Java配置中加载应用上下文，那么可以使用AnnotationConfigApplicationContext：\n```java\nApplicationContext context = new AnnotaionConfigApplicationContext(\n    com.springinaction.knights.config.knightconfig.class);\n```\n在这里没有指定加载Spring应用上下文所需的XML文件，AnnotationConfigApplicationContext通过一个配置类加载bean。\n\n应用上下文准备就绪之后，我们就可以调用上下文的getBean()方法从Spring容器中获取bean。\n\nbean的生命周期\n=======\n\n![Bean生命周期](Spring实战（二）上下文和Bean的生命周期/spring1.png)\n对上图进行详细描述：\n1．Spring对bean进行实例化；\n2．Spring将值和bean的引用注入到bean对应的属性中；\n3．如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBeanName()方法；\n4．如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；\n5．如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；\n6．如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessBeforeInitialization()方法；\n7．如果bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；\n8．如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessAfterInitialization()方法；\n**9．此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；**\n10．如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroymethod声明了销毁方法，该方法也会被调用。\n\nSpring模块\n============\n![spring模块](Spring实战（二）上下文和Bean的生命周期/spring2.png)\n**Spring核心容器**\n容器是Spring框架最核心的部分，它管理着Spring应用中bean的创建、配置和管理。在该模块中，包括了Springbean工厂，它为Spring提供了DI的功能。基于bean工厂，我们还会发现有多种Spring应用上下文的实现，每一种都提供了配置Spring的不同方式。除了bean工厂和应用上下文，该模块也提供了许多企业服务，例如E-mail、JNDI访问、EJB集成和调度。所有的Spring模块都构建于核心容器之上。当你配置应用时，其实你隐式地使用了这些类。\n**Spring的AOP模块**\n在AOP模块中，Spring对面向切面编程提供了丰富的支持。这个模块是Spring应用系统中开发切面的基础。与DI一样，AOP可以帮助应用对象解耦。借助于AOP，可以将遍布系统的关注点（例如事务和安全）从它们所应用的对象中解耦出来。\n**数据访问与集成**\n使用JDBC编写代码通常会导致大量的样板式代码，例如获得数据库连接、创建语句、处理结果集到最后关闭数据库连接。Spring的JDBC和DAO（Data Access Object）模块抽象了这些样板式代码，使我们的数据库代码变得简单明了，还可以避免因为关闭数据库资源失败而引发的问题。该模块在多种数据库服务的错误信息之上构建了一个语义丰富的异常层，以后我们再也不需要解释那些隐晦专有的SQL错误信息了！\n对于那些更喜欢ORM（Object Relational Mapping）工具而不愿意直接使用JDBC的开发者，Spring提供了ORM模块。Spring的ORM模块建立在对DAO的支持之上，并为多个ORM框架提供了一种构建DAO的简便方式。Spring没有尝试去创建自己的ORM解决方案，而是对许多流行的ORM框架进行了集成，包括Hibernate、Java Persisternce API、Java Data Object和iBATIS SQL Maps。Spring的事务管理支持所有的ORM框架以及JDBC。\n本模块同样包含了在JMS（Java Message Service）之上构建的Spring抽象层，它会使用消息以异步的方式与其他应用集成。从Spring 3.0开\n始，本模块还包含对象到XML映射的特性，它最初是Spring WebService项目的一部分。\n除此之外，本模块会使用Spring AOP模块为Spring应用中的对象提供事务管理服务。\n**Web与远程调用**\nMVC（Model-View-Controller）模式是一种普遍被接受的构建Web应用的方法，它可以帮助用户将界面逻辑与应用逻辑分离。Java从来不缺少MVC框架，Apache的Struts、JSF、WebWork和Tapestry都是可选的最流行的MVC框架。虽然Spring能够与多种流行的MVC框架进行集成，但它的Web和远程调用模块自带了一个强大的MVC框架，这就是SpringMVC框架，有助于在Web层提升应用的松耦合水平。\n除了面向用户的Web应用，该模块还提供了多种构建与其他应用交互的远程调用方案。Spring远程调用功能集成了RMI（Remote Method Invocation）、Hessian、Burlap、JAX-WS，同时Spring还自带了一个远程调用框架：HTTPinvoker。Spring还提供了暴露和使用REST API的良好支持。\n**Instrumentation**\nSpring的Instrumentation模块提供了为JVM添加代理（agent）的功能。具体来讲，它为Tomcat提供了一个织入代理，能够为Tomcat传递类文件，就像这些文件是被类加载器加载的一样。\n**测试**\n鉴于开发者自测的重要性，Spring提供了测试模块以致力于Spring应用的测试。通过该模块，你会发现Spring为使用JNDI、Servlet和Portlet编写单元测试提供了一系列的mock对象实现。对于集成测试，该模块为加载Spring应用上下文中的bean集合以及与Spring上下文中的bean进行交互提供了支持。\n\nSpringBoot\n=====\nSpring极大地简化了众多的编程任务，减少甚至消除了很多样板式代码，如果没有Spring的话，在日常工作中你不得不编写这样的样板代码。SpringBoot是一个崭新的令人兴奋的项目，它以Spring的视角，致力于简化Spring本身。**SpringBoot大量依赖于自动配置技术，它能够消除大部分（在很多场景中，甚至是全部）Spring配置。它还提供了多个Starter项目，不管你使用Maven还是Gradle，这都能减少Spring工程构建文件的大小。**","source":"_posts/Spring实战（二）上下文和Bean的生命周期.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">Spring实战（二）上下文Context和Bean的生命周期</font>\ndate: 2017-06-06 19:43:56\ncategories: java读书笔记\ntags: [java,Spring,Bean,Context,Spring模块,SpringBoot]\n---\n在基于Spring的应用中，你的应用对象生存于Spring容器（container）中。Spring容器负责创建对象，装配它们，配置它们并管理它们的整个生命周期，从生存到死亡（在这里，可能就是new到finalize()）。容器是Spring框架的核心。Spring容器使用DI管理构成应用的组件，它会创建相互协作的组件之间的关联。\n\nSpring容器并不是只有一个。Spring自带了多个容器实现，可以归为两种不同的类型。**bean工厂**（由org.springframework.beans.factory.eanFactory接口定义）是最简单的容器，提供基本的DI支持。**应用上下文**（由org.springframework.context.ApplicationContext接口定义）基于BeanFactory构建，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。但是实际应用中，我们往往都会使用应用上下文。\n\n使用应用上下文\n=====\nSpring自带了多种类型的应用上下文。下面罗列的几个是你最有可能遇到的：\n\n- AnnotationConfigApplicationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。\n- AnnotationConfigWebApplicationContext：从一个或多个基于Java的配置类中加载SpringWeb应用上下文。\n- ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。\n- FileSystemXmlapplicationcontext：从文件系统下的一个或多个XML配置文件中加载上下文定义。\n- XmlWebApplicationContext：从Web应用下的一个或多个XML配置文件中加载上下文定义。\n\n如下代码展示了如何加载一个FileSystemXmlApplicationContext：\n```java\nApplicationContext context = new FileSystemXmlApplicationContext(\"c:/knight.xml\");\n```\n类似地，也可以使用ClassPathXmlApplicationContext从应用的类路径下加载应用上下文：\n```java\nApplicationContext context = new ClassPathXmlApplicationContext(\"knight.xml\");\n```\n使用FileSystemXmlApplicationContext和使用ClassPathXmlApplicationContext的区别在于：FileSystemXmlApplicationContext在指定的文件系统路径下查找knight.xml文件；而ClassPathXmlApplicationContext是在所有的类路径（包含JAR文件）下查找knight.xml文件。\n\n如果你想从Java配置中加载应用上下文，那么可以使用AnnotationConfigApplicationContext：\n```java\nApplicationContext context = new AnnotaionConfigApplicationContext(\n    com.springinaction.knights.config.knightconfig.class);\n```\n在这里没有指定加载Spring应用上下文所需的XML文件，AnnotationConfigApplicationContext通过一个配置类加载bean。\n\n应用上下文准备就绪之后，我们就可以调用上下文的getBean()方法从Spring容器中获取bean。\n\nbean的生命周期\n=======\n\n![Bean生命周期](Spring实战（二）上下文和Bean的生命周期/spring1.png)\n对上图进行详细描述：\n1．Spring对bean进行实例化；\n2．Spring将值和bean的引用注入到bean对应的属性中；\n3．如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBeanName()方法；\n4．如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；\n5．如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；\n6．如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessBeforeInitialization()方法；\n7．如果bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；\n8．如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessAfterInitialization()方法；\n**9．此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；**\n10．如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroymethod声明了销毁方法，该方法也会被调用。\n\nSpring模块\n============\n![spring模块](Spring实战（二）上下文和Bean的生命周期/spring2.png)\n**Spring核心容器**\n容器是Spring框架最核心的部分，它管理着Spring应用中bean的创建、配置和管理。在该模块中，包括了Springbean工厂，它为Spring提供了DI的功能。基于bean工厂，我们还会发现有多种Spring应用上下文的实现，每一种都提供了配置Spring的不同方式。除了bean工厂和应用上下文，该模块也提供了许多企业服务，例如E-mail、JNDI访问、EJB集成和调度。所有的Spring模块都构建于核心容器之上。当你配置应用时，其实你隐式地使用了这些类。\n**Spring的AOP模块**\n在AOP模块中，Spring对面向切面编程提供了丰富的支持。这个模块是Spring应用系统中开发切面的基础。与DI一样，AOP可以帮助应用对象解耦。借助于AOP，可以将遍布系统的关注点（例如事务和安全）从它们所应用的对象中解耦出来。\n**数据访问与集成**\n使用JDBC编写代码通常会导致大量的样板式代码，例如获得数据库连接、创建语句、处理结果集到最后关闭数据库连接。Spring的JDBC和DAO（Data Access Object）模块抽象了这些样板式代码，使我们的数据库代码变得简单明了，还可以避免因为关闭数据库资源失败而引发的问题。该模块在多种数据库服务的错误信息之上构建了一个语义丰富的异常层，以后我们再也不需要解释那些隐晦专有的SQL错误信息了！\n对于那些更喜欢ORM（Object Relational Mapping）工具而不愿意直接使用JDBC的开发者，Spring提供了ORM模块。Spring的ORM模块建立在对DAO的支持之上，并为多个ORM框架提供了一种构建DAO的简便方式。Spring没有尝试去创建自己的ORM解决方案，而是对许多流行的ORM框架进行了集成，包括Hibernate、Java Persisternce API、Java Data Object和iBATIS SQL Maps。Spring的事务管理支持所有的ORM框架以及JDBC。\n本模块同样包含了在JMS（Java Message Service）之上构建的Spring抽象层，它会使用消息以异步的方式与其他应用集成。从Spring 3.0开\n始，本模块还包含对象到XML映射的特性，它最初是Spring WebService项目的一部分。\n除此之外，本模块会使用Spring AOP模块为Spring应用中的对象提供事务管理服务。\n**Web与远程调用**\nMVC（Model-View-Controller）模式是一种普遍被接受的构建Web应用的方法，它可以帮助用户将界面逻辑与应用逻辑分离。Java从来不缺少MVC框架，Apache的Struts、JSF、WebWork和Tapestry都是可选的最流行的MVC框架。虽然Spring能够与多种流行的MVC框架进行集成，但它的Web和远程调用模块自带了一个强大的MVC框架，这就是SpringMVC框架，有助于在Web层提升应用的松耦合水平。\n除了面向用户的Web应用，该模块还提供了多种构建与其他应用交互的远程调用方案。Spring远程调用功能集成了RMI（Remote Method Invocation）、Hessian、Burlap、JAX-WS，同时Spring还自带了一个远程调用框架：HTTPinvoker。Spring还提供了暴露和使用REST API的良好支持。\n**Instrumentation**\nSpring的Instrumentation模块提供了为JVM添加代理（agent）的功能。具体来讲，它为Tomcat提供了一个织入代理，能够为Tomcat传递类文件，就像这些文件是被类加载器加载的一样。\n**测试**\n鉴于开发者自测的重要性，Spring提供了测试模块以致力于Spring应用的测试。通过该模块，你会发现Spring为使用JNDI、Servlet和Portlet编写单元测试提供了一系列的mock对象实现。对于集成测试，该模块为加载Spring应用上下文中的bean集合以及与Spring上下文中的bean进行交互提供了支持。\n\nSpringBoot\n=====\nSpring极大地简化了众多的编程任务，减少甚至消除了很多样板式代码，如果没有Spring的话，在日常工作中你不得不编写这样的样板代码。SpringBoot是一个崭新的令人兴奋的项目，它以Spring的视角，致力于简化Spring本身。**SpringBoot大量依赖于自动配置技术，它能够消除大部分（在很多场景中，甚至是全部）Spring配置。它还提供了多个Starter项目，不管你使用Maven还是Gradle，这都能减少Spring工程构建文件的大小。**","slug":"Spring实战（二）上下文和Bean的生命周期","published":1,"updated":"2017-07-12T01:48:47.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hso0b000kasvlen6emvdp","content":"<p>在基于Spring的应用中，你的应用对象生存于Spring容器（container）中。Spring容器负责创建对象，装配它们，配置它们并管理它们的整个生命周期，从生存到死亡（在这里，可能就是new到finalize()）。容器是Spring框架的核心。Spring容器使用DI管理构成应用的组件，它会创建相互协作的组件之间的关联。</p>\n<p>Spring容器并不是只有一个。Spring自带了多个容器实现，可以归为两种不同的类型。<strong>bean工厂</strong>（由org.springframework.beans.factory.eanFactory接口定义）是最简单的容器，提供基本的DI支持。<strong>应用上下文</strong>（由org.springframework.context.ApplicationContext接口定义）基于BeanFactory构建，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。但是实际应用中，我们往往都会使用应用上下文。</p>\n<h1 id=\"使用应用上下文\"><a href=\"#使用应用上下文\" class=\"headerlink\" title=\"使用应用上下文\"></a>使用应用上下文</h1><p>Spring自带了多种类型的应用上下文。下面罗列的几个是你最有可能遇到的：</p>\n<ul>\n<li>AnnotationConfigApplicationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。</li>\n<li>AnnotationConfigWebApplicationContext：从一个或多个基于Java的配置类中加载SpringWeb应用上下文。</li>\n<li>ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。</li>\n<li>FileSystemXmlapplicationcontext：从文件系统下的一个或多个XML配置文件中加载上下文定义。</li>\n<li>XmlWebApplicationContext：从Web应用下的一个或多个XML配置文件中加载上下文定义。</li>\n</ul>\n<p>如下代码展示了如何加载一个FileSystemXmlApplicationContext：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ApplicationContext context = <span class=\"keyword\">new</span> FileSystemXmlApplicationContext(<span class=\"string\">\"c:/knight.xml\"</span>);</div></pre></td></tr></table></figure></p>\n<p>类似地，也可以使用ClassPathXmlApplicationContext从应用的类路径下加载应用上下文：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"knight.xml\"</span>);</div></pre></td></tr></table></figure></p>\n<p>使用FileSystemXmlApplicationContext和使用ClassPathXmlApplicationContext的区别在于：FileSystemXmlApplicationContext在指定的文件系统路径下查找knight.xml文件；而ClassPathXmlApplicationContext是在所有的类路径（包含JAR文件）下查找knight.xml文件。</p>\n<p>如果你想从Java配置中加载应用上下文，那么可以使用AnnotationConfigApplicationContext：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ApplicationContext context = <span class=\"keyword\">new</span> AnnotaionConfigApplicationContext(</div><div class=\"line\">    com.springinaction.knights.config.knightconfig.class);</div></pre></td></tr></table></figure></p>\n<p>在这里没有指定加载Spring应用上下文所需的XML文件，AnnotationConfigApplicationContext通过一个配置类加载bean。</p>\n<p>应用上下文准备就绪之后，我们就可以调用上下文的getBean()方法从Spring容器中获取bean。</p>\n<h1 id=\"bean的生命周期\"><a href=\"#bean的生命周期\" class=\"headerlink\" title=\"bean的生命周期\"></a>bean的生命周期</h1><p><img src=\"/2017/06/06/Spring实战（二）上下文和Bean的生命周期/spring1.png\" alt=\"Bean生命周期\"><br>对上图进行详细描述：<br>1．Spring对bean进行实例化；<br>2．Spring将值和bean的引用注入到bean对应的属性中；<br>3．如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBeanName()方法；<br>4．如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；<br>5．如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；<br>6．如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessBeforeInitialization()方法；<br>7．如果bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；<br>8．如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessAfterInitialization()方法；<br><strong>9．此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</strong><br>10．如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroymethod声明了销毁方法，该方法也会被调用。</p>\n<h1 id=\"Spring模块\"><a href=\"#Spring模块\" class=\"headerlink\" title=\"Spring模块\"></a>Spring模块</h1><p><img src=\"/2017/06/06/Spring实战（二）上下文和Bean的生命周期/spring2.png\" alt=\"spring模块\"><br><strong>Spring核心容器</strong><br>容器是Spring框架最核心的部分，它管理着Spring应用中bean的创建、配置和管理。在该模块中，包括了Springbean工厂，它为Spring提供了DI的功能。基于bean工厂，我们还会发现有多种Spring应用上下文的实现，每一种都提供了配置Spring的不同方式。除了bean工厂和应用上下文，该模块也提供了许多企业服务，例如E-mail、JNDI访问、EJB集成和调度。所有的Spring模块都构建于核心容器之上。当你配置应用时，其实你隐式地使用了这些类。<br><strong>Spring的AOP模块</strong><br>在AOP模块中，Spring对面向切面编程提供了丰富的支持。这个模块是Spring应用系统中开发切面的基础。与DI一样，AOP可以帮助应用对象解耦。借助于AOP，可以将遍布系统的关注点（例如事务和安全）从它们所应用的对象中解耦出来。<br><strong>数据访问与集成</strong><br>使用JDBC编写代码通常会导致大量的样板式代码，例如获得数据库连接、创建语句、处理结果集到最后关闭数据库连接。Spring的JDBC和DAO（Data Access Object）模块抽象了这些样板式代码，使我们的数据库代码变得简单明了，还可以避免因为关闭数据库资源失败而引发的问题。该模块在多种数据库服务的错误信息之上构建了一个语义丰富的异常层，以后我们再也不需要解释那些隐晦专有的SQL错误信息了！<br>对于那些更喜欢ORM（Object Relational Mapping）工具而不愿意直接使用JDBC的开发者，Spring提供了ORM模块。Spring的ORM模块建立在对DAO的支持之上，并为多个ORM框架提供了一种构建DAO的简便方式。Spring没有尝试去创建自己的ORM解决方案，而是对许多流行的ORM框架进行了集成，包括Hibernate、Java Persisternce API、Java Data Object和iBATIS SQL Maps。Spring的事务管理支持所有的ORM框架以及JDBC。<br>本模块同样包含了在JMS（Java Message Service）之上构建的Spring抽象层，它会使用消息以异步的方式与其他应用集成。从Spring 3.0开<br>始，本模块还包含对象到XML映射的特性，它最初是Spring WebService项目的一部分。<br>除此之外，本模块会使用Spring AOP模块为Spring应用中的对象提供事务管理服务。<br><strong>Web与远程调用</strong><br>MVC（Model-View-Controller）模式是一种普遍被接受的构建Web应用的方法，它可以帮助用户将界面逻辑与应用逻辑分离。Java从来不缺少MVC框架，Apache的Struts、JSF、WebWork和Tapestry都是可选的最流行的MVC框架。虽然Spring能够与多种流行的MVC框架进行集成，但它的Web和远程调用模块自带了一个强大的MVC框架，这就是SpringMVC框架，有助于在Web层提升应用的松耦合水平。<br>除了面向用户的Web应用，该模块还提供了多种构建与其他应用交互的远程调用方案。Spring远程调用功能集成了RMI（Remote Method Invocation）、Hessian、Burlap、JAX-WS，同时Spring还自带了一个远程调用框架：HTTPinvoker。Spring还提供了暴露和使用REST API的良好支持。<br><strong>Instrumentation</strong><br>Spring的Instrumentation模块提供了为JVM添加代理（agent）的功能。具体来讲，它为Tomcat提供了一个织入代理，能够为Tomcat传递类文件，就像这些文件是被类加载器加载的一样。<br><strong>测试</strong><br>鉴于开发者自测的重要性，Spring提供了测试模块以致力于Spring应用的测试。通过该模块，你会发现Spring为使用JNDI、Servlet和Portlet编写单元测试提供了一系列的mock对象实现。对于集成测试，该模块为加载Spring应用上下文中的bean集合以及与Spring上下文中的bean进行交互提供了支持。</p>\n<h1 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h1><p>Spring极大地简化了众多的编程任务，减少甚至消除了很多样板式代码，如果没有Spring的话，在日常工作中你不得不编写这样的样板代码。SpringBoot是一个崭新的令人兴奋的项目，它以Spring的视角，致力于简化Spring本身。<strong>SpringBoot大量依赖于自动配置技术，它能够消除大部分（在很多场景中，甚至是全部）Spring配置。它还提供了多个Starter项目，不管你使用Maven还是Gradle，这都能减少Spring工程构建文件的大小。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在基于Spring的应用中，你的应用对象生存于Spring容器（container）中。Spring容器负责创建对象，装配它们，配置它们并管理它们的整个生命周期，从生存到死亡（在这里，可能就是new到finalize()）。容器是Spring框架的核心。Spring容器使用DI管理构成应用的组件，它会创建相互协作的组件之间的关联。</p>\n<p>Spring容器并不是只有一个。Spring自带了多个容器实现，可以归为两种不同的类型。<strong>bean工厂</strong>（由org.springframework.beans.factory.eanFactory接口定义）是最简单的容器，提供基本的DI支持。<strong>应用上下文</strong>（由org.springframework.context.ApplicationContext接口定义）基于BeanFactory构建，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。但是实际应用中，我们往往都会使用应用上下文。</p>\n<h1 id=\"使用应用上下文\"><a href=\"#使用应用上下文\" class=\"headerlink\" title=\"使用应用上下文\"></a>使用应用上下文</h1><p>Spring自带了多种类型的应用上下文。下面罗列的几个是你最有可能遇到的：</p>\n<ul>\n<li>AnnotationConfigApplicationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。</li>\n<li>AnnotationConfigWebApplicationContext：从一个或多个基于Java的配置类中加载SpringWeb应用上下文。</li>\n<li>ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。</li>\n<li>FileSystemXmlapplicationcontext：从文件系统下的一个或多个XML配置文件中加载上下文定义。</li>\n<li>XmlWebApplicationContext：从Web应用下的一个或多个XML配置文件中加载上下文定义。</li>\n</ul>\n<p>如下代码展示了如何加载一个FileSystemXmlApplicationContext：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ApplicationContext context = <span class=\"keyword\">new</span> FileSystemXmlApplicationContext(<span class=\"string\">\"c:/knight.xml\"</span>);</div></pre></td></tr></table></figure></p>\n<p>类似地，也可以使用ClassPathXmlApplicationContext从应用的类路径下加载应用上下文：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"knight.xml\"</span>);</div></pre></td></tr></table></figure></p>\n<p>使用FileSystemXmlApplicationContext和使用ClassPathXmlApplicationContext的区别在于：FileSystemXmlApplicationContext在指定的文件系统路径下查找knight.xml文件；而ClassPathXmlApplicationContext是在所有的类路径（包含JAR文件）下查找knight.xml文件。</p>\n<p>如果你想从Java配置中加载应用上下文，那么可以使用AnnotationConfigApplicationContext：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ApplicationContext context = <span class=\"keyword\">new</span> AnnotaionConfigApplicationContext(</div><div class=\"line\">    com.springinaction.knights.config.knightconfig.class);</div></pre></td></tr></table></figure></p>\n<p>在这里没有指定加载Spring应用上下文所需的XML文件，AnnotationConfigApplicationContext通过一个配置类加载bean。</p>\n<p>应用上下文准备就绪之后，我们就可以调用上下文的getBean()方法从Spring容器中获取bean。</p>\n<h1 id=\"bean的生命周期\"><a href=\"#bean的生命周期\" class=\"headerlink\" title=\"bean的生命周期\"></a>bean的生命周期</h1><p><img src=\"/2017/06/06/Spring实战（二）上下文和Bean的生命周期/spring1.png\" alt=\"Bean生命周期\"><br>对上图进行详细描述：<br>1．Spring对bean进行实例化；<br>2．Spring将值和bean的引用注入到bean对应的属性中；<br>3．如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBeanName()方法；<br>4．如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；<br>5．如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；<br>6．如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessBeforeInitialization()方法；<br>7．如果bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；<br>8．如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessAfterInitialization()方法；<br><strong>9．此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</strong><br>10．如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroymethod声明了销毁方法，该方法也会被调用。</p>\n<h1 id=\"Spring模块\"><a href=\"#Spring模块\" class=\"headerlink\" title=\"Spring模块\"></a>Spring模块</h1><p><img src=\"/2017/06/06/Spring实战（二）上下文和Bean的生命周期/spring2.png\" alt=\"spring模块\"><br><strong>Spring核心容器</strong><br>容器是Spring框架最核心的部分，它管理着Spring应用中bean的创建、配置和管理。在该模块中，包括了Springbean工厂，它为Spring提供了DI的功能。基于bean工厂，我们还会发现有多种Spring应用上下文的实现，每一种都提供了配置Spring的不同方式。除了bean工厂和应用上下文，该模块也提供了许多企业服务，例如E-mail、JNDI访问、EJB集成和调度。所有的Spring模块都构建于核心容器之上。当你配置应用时，其实你隐式地使用了这些类。<br><strong>Spring的AOP模块</strong><br>在AOP模块中，Spring对面向切面编程提供了丰富的支持。这个模块是Spring应用系统中开发切面的基础。与DI一样，AOP可以帮助应用对象解耦。借助于AOP，可以将遍布系统的关注点（例如事务和安全）从它们所应用的对象中解耦出来。<br><strong>数据访问与集成</strong><br>使用JDBC编写代码通常会导致大量的样板式代码，例如获得数据库连接、创建语句、处理结果集到最后关闭数据库连接。Spring的JDBC和DAO（Data Access Object）模块抽象了这些样板式代码，使我们的数据库代码变得简单明了，还可以避免因为关闭数据库资源失败而引发的问题。该模块在多种数据库服务的错误信息之上构建了一个语义丰富的异常层，以后我们再也不需要解释那些隐晦专有的SQL错误信息了！<br>对于那些更喜欢ORM（Object Relational Mapping）工具而不愿意直接使用JDBC的开发者，Spring提供了ORM模块。Spring的ORM模块建立在对DAO的支持之上，并为多个ORM框架提供了一种构建DAO的简便方式。Spring没有尝试去创建自己的ORM解决方案，而是对许多流行的ORM框架进行了集成，包括Hibernate、Java Persisternce API、Java Data Object和iBATIS SQL Maps。Spring的事务管理支持所有的ORM框架以及JDBC。<br>本模块同样包含了在JMS（Java Message Service）之上构建的Spring抽象层，它会使用消息以异步的方式与其他应用集成。从Spring 3.0开<br>始，本模块还包含对象到XML映射的特性，它最初是Spring WebService项目的一部分。<br>除此之外，本模块会使用Spring AOP模块为Spring应用中的对象提供事务管理服务。<br><strong>Web与远程调用</strong><br>MVC（Model-View-Controller）模式是一种普遍被接受的构建Web应用的方法，它可以帮助用户将界面逻辑与应用逻辑分离。Java从来不缺少MVC框架，Apache的Struts、JSF、WebWork和Tapestry都是可选的最流行的MVC框架。虽然Spring能够与多种流行的MVC框架进行集成，但它的Web和远程调用模块自带了一个强大的MVC框架，这就是SpringMVC框架，有助于在Web层提升应用的松耦合水平。<br>除了面向用户的Web应用，该模块还提供了多种构建与其他应用交互的远程调用方案。Spring远程调用功能集成了RMI（Remote Method Invocation）、Hessian、Burlap、JAX-WS，同时Spring还自带了一个远程调用框架：HTTPinvoker。Spring还提供了暴露和使用REST API的良好支持。<br><strong>Instrumentation</strong><br>Spring的Instrumentation模块提供了为JVM添加代理（agent）的功能。具体来讲，它为Tomcat提供了一个织入代理，能够为Tomcat传递类文件，就像这些文件是被类加载器加载的一样。<br><strong>测试</strong><br>鉴于开发者自测的重要性，Spring提供了测试模块以致力于Spring应用的测试。通过该模块，你会发现Spring为使用JNDI、Servlet和Portlet编写单元测试提供了一系列的mock对象实现。对于集成测试，该模块为加载Spring应用上下文中的bean集合以及与Spring上下文中的bean进行交互提供了支持。</p>\n<h1 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h1><p>Spring极大地简化了众多的编程任务，减少甚至消除了很多样板式代码，如果没有Spring的话，在日常工作中你不得不编写这样的样板代码。SpringBoot是一个崭新的令人兴奋的项目，它以Spring的视角，致力于简化Spring本身。<strong>SpringBoot大量依赖于自动配置技术，它能够消除大部分（在很多场景中，甚至是全部）Spring配置。它还提供了多个Starter项目，不管你使用Maven还是Gradle，这都能减少Spring工程构建文件的大小。</strong></p>\n"},{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">Spring实战（三） 自动装配Bean</font>","date":"2017-06-09T00:53:26.000Z","_content":"\n在Spring中，对象无需自己查找或创建与其所关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象。例如，一个订单管理组件需要信用卡认证组件，但它不需要自己创建信用卡认证组件。订单管理组件只需要表明自己两手空空，容器就会主动赋予它一个信用卡认证组件。创建应用对象之间协作关系的行为通常称为装配（wiring），这也是依赖注入（DI）的本质。\n\nSpring配置\n===========\nSpring容器负责创建应用程序中的bean并通过DI来协调这些对象之间的关系。但是，作为开发人员，你需要告诉Spring要创建哪些bean并且如何将其装配在一起。当描述bean如何进行装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制：\n\n - 在XML中进行显式配置。\n - 在Java中进行显式配置。\n - 隐式的bean发现机制和自动装配。\n\nSpring的配置风格是可以互相搭配的，所以你可以选择使用XML装配一些bean，使用Spring基于Java的配置（JavaConfig）来装配另一些bean，而将剩余的bean让Spring去自动发现。\n即便如此，我的建议是尽可能地使用自动配置的机制。显式配置越少越好。当你必须要显式配置bean的时候（比如，有些源码不是由你来维护的，而当你需要为这些代码配置bean的时候），我推荐使用类型安全并且比XML更加强大的JavaConfig。最后，只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应该使用XML。\n\n自动装配Bean\n========\nSpring从两个角度来实现自动化装配：\n\n- 组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。\n- 自动装配（autowiring）：Spring自动满足bean之间的依赖。\n\n为了阐述组件扫描和装配，我们需要创建几个bean，它们代表了一个音响系统中的组件。首先，要创建CompactDisc类，Spring会发现它并将其创建为一个bean。然后，会创建一个CDPlayer类，让Spring发现它，并将CompactDisc bean注入进来。\n\n**创建可被发现的Bean**\n现在有一个CD播放器，需要插入CD才能播放。也就是说CD播放器依赖于CD才能完成它的使命。\n先写一个CompactDisc类，它是定义CD的一个接口：\n```java\npackage soundsystem\n\npublic interface CompactDisc {\n    void play;\n}\n```\n然后我们可以创建多个CD的实现，比如可以是摇滚类的也可以是古典类的，它们都要实现CD的上层接口：CompactDisc。这里只创建一个实现——SgtPeppers类：\n```java\npackage soundsystem;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class SgtPeppers implements CompactDisc {\n\n  private String title = \"Sgt. Pepper's Lonely Hearts Club Band\";  \n  private String artist = \"The Beatles\";\n  \n  public void play() {\n    System.out.println(\"Playing \" + title + \" by \" + artist);\n  }\n  \n}\n```\nSgtPeppers类上使用了@Component注解。这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。没有必要显式配置SgtPeppers bean，因为这个类使用了@Component注解，所以Spring会为你把事情处理妥当。\n不过，组件扫描默认是不启用的。我们还需要显式配置一下Spring，从而命令它去寻找带有@Component注解的类，并为其创建bean,CDPlayerConfig类完成了这个工作：\n```java\npackage soundsystem;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ComponentScan\npublic class CDPlayerConfig { \n}\n```\n类CDPlayerConfig通过Java代码定义了Spring的装配规则。但是CDPlayerConfig类并没有显式地声明任何bean，而是使用了@ComponentScan注解，这个注解能够在Spring中启用组件扫描。如果没有其他配置的话，@ComponentScan默认会扫描与配置类相同的包。因为CDPlayerConfig类位于soundsystem包中，因此Spring将会扫描这个包以及这个包下的所有子包，查找带有@Component注解的类。这样的话，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。\n\n这个工作也可以用xml配置来完成：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xmlns:context=\"http://www.springframework.org/schema/context\"\n  xmlns:c=\"http://www.springframework.org/schema/c\"\n  xmlns:p=\"http://www.springframework.org/schema/p\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n\n  <context:component-scan base-package=\"soundsystem\" />\n\n</beans>\n```\n现在就可以创建一个测试类来试着尝试现有的功能了。在这个JUnit测试类中，先会创建Spring上下文，然后判断CompactDisc是不是真的创建出来了：\n```java\npackage soundsystem;\n\nimport static org.junit.Assert.*;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes=CDPlayerConfig.class)\npublic class CDPlayerTest {\n  \n  @Autowired\n  private CompactDisc cd;\n  \n  @Test\n  public void cdShouldNotBeNull() {\n    assertNotNull(cd);\n  }\n\n}\n\n```\nCDPlayerTest使用了Spring的SpringJUnit4ClassRunner，以便在测试开始的时候自动创建Spring的应用上下文。注解@ContextConfiguration会告诉它需要在CDPlayerConfig中加载配置。因为CDPlayerConfig类中包含了@ComponentScan，因此最终的应用上下文中应该包含CompactDisc bean。为了证明这一点，在测试代码中有一个CompactDisc类型的属性，并且这个属性带有@Autowired注解，以便于将CompactDiscbean注入到测试代码之中（稍后，我会讨论@Autowired）。最后，会有一个简单的测试方法断言cd属性不为null。如果它不为null的话，就意味着Spring能够发现CompactDisc类，自动在Spring上下文中将其创建为bean并将其注入到测试代码之中。\n\n尽管我们只用它创建了一个bean，但同样是这么少的配置能够用来发现和创建任意数量的bean。在soundsystem\n包及其子包中，所有带有@Component注解的类都会创建为bean。只添加一行@Component Scan注解就能自动创建无数个bean，这种权衡还是很划算的。\n\n但是使用@ComponentScan和@Component组件扫描还能做别的事情：\n**为组件扫描的Bean命名**\nSpring应用上下文中所有的bean都会给定一个ID。在前面的例子中，尽管我们没有明确地为SgtPeppersbean设置ID，但Spring会根据类名为其指定一个ID。具体来讲，这个bean所给定的ID为sgtPeppers，也就是将类名的第一个字母变为小写。如果想为这个bean设置不同的ID，你所要做的就是将期望的ID作为值传递给@Component\n注解。比如说，如果想将这个bean标识为lonelyHeartsClub，那么你需要将SgtPeppers类的@Component注解配置为如下所示：\n```java\n@Component(\"lonelyHeartsClub\")\npublic class SgtPeppers implements CompactDisc {\n    ...\n}\n```\n还有另外一种为bean命名的方式，这种方式不使用@Component注解，而是使用Java依赖注入规范（Java Dependency Injection）中所提供的@Named注解来为bean设置ID：\n```java\npackage soundsystem;\n\nimport javax.inject.Named;\n\n@Named(\"lonelyHeartsClub\")\npublic class SgtPeppers implements CompactDisc {\n    ...\n}\n```\nSpring支持将@Named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以互相替换的。\n\n**设置组件扫描的的基础包**\n到现在为止，我们没有为@ComponentScan设置任何属性。这意味着，按照默认规则，它会以配置类所在的包作为基础包（basepackage）来扫描组件。但是，如果你想扫描不同的包，那该怎么办呢？或者，如果你想扫描多个基础包，那又该怎么办呢？\n有一个原因会促使我们明确地设置基础包，那就是我们想要将配置类放在单独的包中，使其与其他的应用代码区分开来。如果是这样的话，那默认的基础包就不能满足要求了。要满足这样的需求其实也完全没有问题！为了指定不同的基础包，你所需要做的就是在@ComponentScan的value属性中指明包的名称：\n```java\n@Configuration\n@ComponentScan(\"soundsystem\")\npublic class CDPlayerConfig {}\n```\n如果你想更加清晰地表明你所设置的是基础包，那么你可以通过basePackages属性进行配置：\n```java\n@Configuration\n@ComponentScan(basePackages=\"soundsystem\")\npublic class CDPlayerConfig {}\n```\n可能你已经注意到了basePackages属性使用的是复数形式。如果你揣测这是不是意味着可以设置多个基础包，那么恭喜你猜对了。如果想要这么做的话，只需要将basePackages属性设置为要扫描包的一个数组即可：\n```java\n@Configuration\n@ComponentScan(basePackages={\"soundsystem\",\"video\"})\npublic class CDPlayerConfig {}\n```\n在上面的例子中，所设置的基础包是以String类型表示的。我认为这是可以的，但这种方法是类型不安全（not typesafe）的。如果你重构代码的话，那么所指定的基础包可能就会出现错误了。除了将包设置为简单的String类型之外，@ComponentScan还提供了另外一种方法，那就是将其指定为包中所包含的类或接口：\n```java\n@Configuration\n@ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class})\npublic class CDPlayerConfig {}\n```\n可以看到，basePackages属性被替换成了basePackageClasses。同时，我们不是再使用String类型的名称来指定包，为basePackageClasses属性所设置的数组中包含了类。这些类所在的包将会作为组件扫描的基础包。\n\n\n在你的应用程序中，如果所有的对象都是独立的，彼此之间没有任何依赖，就像SgtPeppersbean这样，那么你所需要的可能就是组件扫描而已。但是，很多对象会依赖其他的对象才能完成任务。这样的话，我们就需要有一种方法能够将组件扫描得到的bean和它们的依赖装配在一起。要完成这项任务，我们需要了解一下Spring自动化配置的另外一方面内容，那就是自动装配。\n\n**通过为bean添加注解实现自动装配**\n------\n简单来说，自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean。为了声明要进行自动装配，我们可以借助Spring的@Autowired注解。\n\n下面完成CDPlayer类：\n```java\npackage soundsystem;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CDPlayer implements MediaPlayer {\n  private CompactDisc cd;\n\n  @Autowired\n  public CDPlayer(CompactDisc cd) {\n    this.cd = cd;\n  }\n\n  public void play() {\n    cd.play();\n  }\n\n}\n```\n它的构造器上添加了@Autowired注解，这表明当Spring创建CDPlayerbean的时候，会通过这个构造器来进行实例化并且会传入一个可设置给CompactDisc类型的bean。\n\n@Autowired注解不仅能够用在构造器上，还能用在属性的Setter方法上。比如说，如果CDPlayer有一个setCompactDisc()方法，那么可以采用如下的注解形式进行自动装配：\n```java\n@Autowired\npublic void setCompactDisc(CompactDisc cd) {\n    this.cd = cd;\n}\n```\n\n@Autowired注解可以用在类的任何方法上。假设CDPlayer类有一个insertDisc()方法，那么@Autowired能够像在setCompactDisc()上那样，发挥完全相同的作用：\n```java\n@Autowired\npublic void insertDisc(CompactDisc cd) {\n    this.cd = cd;\n}\n```\n不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false：\n```java\n@Autowired(required=false)\npublic CDPlayer(CompactDisc cd) {\n    this.cd = cd;\n}\n```\n将required属性设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态。但是，把required属性设置为false时，你需要谨慎对待。如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现NullPointerException。如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常，表明没有明确指定要选择哪个bean进行自动装配。\n\n@Autowired是Spring特有的注解。如果你不愿意在代码中到处使用Spring的特定注解来完成自动装配任务的话，那么你可以考虑将其替换为@Inject：\n```java\npackage soundsystem;\nimport javax.inject.Inject;\nimportjavax.inject.Named;\n\n@Named\npublic cladd CDPlayer{\n    ...\n    \n    @Inject\n    public CDPlayer(CompactDisc cd){\n        this.cd = cd;\n    }\n    \n    ...\n}\n```\n@Inject注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解。在自动装配中，Spring同时支持@Inject和@Autowired。尽管@Inject和@Autowired之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。\n\n现在，我们已经在CDPlayer的构造器中添加了@Autowired注解，Spring将把一个可分配给CompactDisc类型的bean自动注入进来。为了验证这一点，让我们修改一下CDPlayerTest，使其能够借助CDPlayerbean播放CD：\n```java\npackage soundsystem;\n\nimport static org.junit.Assert.*;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.contrib.java.lang.system.StandardOutputStreamLog;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes=CDPlayerConfig.class)\npublic class CDPlayerTest {\n\n  @Rule\n  public final StandardOutputStreamLog log = new StandardOutputStreamLog();\n\n  @Autowired\n  private MediaPlayer player;\n  \n  @Autowired\n  private CompactDisc cd;\n  \n  @Test\n  public void cdShouldNotBeNull() {\n    assertNotNull(cd);\n  }\n\n  @Test\n  public void play() {\n    player.play();\n    assertEquals(\n        \"Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\\n\", \n        log.getLog());\n  }\n\n}\n```\n现在，除了注入CompactDisc，我们还将CDPlayerbean注入到测试代码的player成员变量之中（它是更为通用的\nMediaPlayer类型）。在play()测试方法中，我们可以调用CDPlayer的play()方法，并断言它的行为与你的预期一致。\n\n","source":"_posts/Spring实战（三） 自动装配Bean.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">Spring实战（三） 自动装配Bean</font>\ndate: 2017-06-09 08:53:26\ncategories: java读书笔记\ntags: [java,Spring,Bean,自动装配]\n---\n\n在Spring中，对象无需自己查找或创建与其所关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象。例如，一个订单管理组件需要信用卡认证组件，但它不需要自己创建信用卡认证组件。订单管理组件只需要表明自己两手空空，容器就会主动赋予它一个信用卡认证组件。创建应用对象之间协作关系的行为通常称为装配（wiring），这也是依赖注入（DI）的本质。\n\nSpring配置\n===========\nSpring容器负责创建应用程序中的bean并通过DI来协调这些对象之间的关系。但是，作为开发人员，你需要告诉Spring要创建哪些bean并且如何将其装配在一起。当描述bean如何进行装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制：\n\n - 在XML中进行显式配置。\n - 在Java中进行显式配置。\n - 隐式的bean发现机制和自动装配。\n\nSpring的配置风格是可以互相搭配的，所以你可以选择使用XML装配一些bean，使用Spring基于Java的配置（JavaConfig）来装配另一些bean，而将剩余的bean让Spring去自动发现。\n即便如此，我的建议是尽可能地使用自动配置的机制。显式配置越少越好。当你必须要显式配置bean的时候（比如，有些源码不是由你来维护的，而当你需要为这些代码配置bean的时候），我推荐使用类型安全并且比XML更加强大的JavaConfig。最后，只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应该使用XML。\n\n自动装配Bean\n========\nSpring从两个角度来实现自动化装配：\n\n- 组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。\n- 自动装配（autowiring）：Spring自动满足bean之间的依赖。\n\n为了阐述组件扫描和装配，我们需要创建几个bean，它们代表了一个音响系统中的组件。首先，要创建CompactDisc类，Spring会发现它并将其创建为一个bean。然后，会创建一个CDPlayer类，让Spring发现它，并将CompactDisc bean注入进来。\n\n**创建可被发现的Bean**\n现在有一个CD播放器，需要插入CD才能播放。也就是说CD播放器依赖于CD才能完成它的使命。\n先写一个CompactDisc类，它是定义CD的一个接口：\n```java\npackage soundsystem\n\npublic interface CompactDisc {\n    void play;\n}\n```\n然后我们可以创建多个CD的实现，比如可以是摇滚类的也可以是古典类的，它们都要实现CD的上层接口：CompactDisc。这里只创建一个实现——SgtPeppers类：\n```java\npackage soundsystem;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class SgtPeppers implements CompactDisc {\n\n  private String title = \"Sgt. Pepper's Lonely Hearts Club Band\";  \n  private String artist = \"The Beatles\";\n  \n  public void play() {\n    System.out.println(\"Playing \" + title + \" by \" + artist);\n  }\n  \n}\n```\nSgtPeppers类上使用了@Component注解。这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。没有必要显式配置SgtPeppers bean，因为这个类使用了@Component注解，所以Spring会为你把事情处理妥当。\n不过，组件扫描默认是不启用的。我们还需要显式配置一下Spring，从而命令它去寻找带有@Component注解的类，并为其创建bean,CDPlayerConfig类完成了这个工作：\n```java\npackage soundsystem;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ComponentScan\npublic class CDPlayerConfig { \n}\n```\n类CDPlayerConfig通过Java代码定义了Spring的装配规则。但是CDPlayerConfig类并没有显式地声明任何bean，而是使用了@ComponentScan注解，这个注解能够在Spring中启用组件扫描。如果没有其他配置的话，@ComponentScan默认会扫描与配置类相同的包。因为CDPlayerConfig类位于soundsystem包中，因此Spring将会扫描这个包以及这个包下的所有子包，查找带有@Component注解的类。这样的话，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。\n\n这个工作也可以用xml配置来完成：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xmlns:context=\"http://www.springframework.org/schema/context\"\n  xmlns:c=\"http://www.springframework.org/schema/c\"\n  xmlns:p=\"http://www.springframework.org/schema/p\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n\n  <context:component-scan base-package=\"soundsystem\" />\n\n</beans>\n```\n现在就可以创建一个测试类来试着尝试现有的功能了。在这个JUnit测试类中，先会创建Spring上下文，然后判断CompactDisc是不是真的创建出来了：\n```java\npackage soundsystem;\n\nimport static org.junit.Assert.*;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes=CDPlayerConfig.class)\npublic class CDPlayerTest {\n  \n  @Autowired\n  private CompactDisc cd;\n  \n  @Test\n  public void cdShouldNotBeNull() {\n    assertNotNull(cd);\n  }\n\n}\n\n```\nCDPlayerTest使用了Spring的SpringJUnit4ClassRunner，以便在测试开始的时候自动创建Spring的应用上下文。注解@ContextConfiguration会告诉它需要在CDPlayerConfig中加载配置。因为CDPlayerConfig类中包含了@ComponentScan，因此最终的应用上下文中应该包含CompactDisc bean。为了证明这一点，在测试代码中有一个CompactDisc类型的属性，并且这个属性带有@Autowired注解，以便于将CompactDiscbean注入到测试代码之中（稍后，我会讨论@Autowired）。最后，会有一个简单的测试方法断言cd属性不为null。如果它不为null的话，就意味着Spring能够发现CompactDisc类，自动在Spring上下文中将其创建为bean并将其注入到测试代码之中。\n\n尽管我们只用它创建了一个bean，但同样是这么少的配置能够用来发现和创建任意数量的bean。在soundsystem\n包及其子包中，所有带有@Component注解的类都会创建为bean。只添加一行@Component Scan注解就能自动创建无数个bean，这种权衡还是很划算的。\n\n但是使用@ComponentScan和@Component组件扫描还能做别的事情：\n**为组件扫描的Bean命名**\nSpring应用上下文中所有的bean都会给定一个ID。在前面的例子中，尽管我们没有明确地为SgtPeppersbean设置ID，但Spring会根据类名为其指定一个ID。具体来讲，这个bean所给定的ID为sgtPeppers，也就是将类名的第一个字母变为小写。如果想为这个bean设置不同的ID，你所要做的就是将期望的ID作为值传递给@Component\n注解。比如说，如果想将这个bean标识为lonelyHeartsClub，那么你需要将SgtPeppers类的@Component注解配置为如下所示：\n```java\n@Component(\"lonelyHeartsClub\")\npublic class SgtPeppers implements CompactDisc {\n    ...\n}\n```\n还有另外一种为bean命名的方式，这种方式不使用@Component注解，而是使用Java依赖注入规范（Java Dependency Injection）中所提供的@Named注解来为bean设置ID：\n```java\npackage soundsystem;\n\nimport javax.inject.Named;\n\n@Named(\"lonelyHeartsClub\")\npublic class SgtPeppers implements CompactDisc {\n    ...\n}\n```\nSpring支持将@Named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以互相替换的。\n\n**设置组件扫描的的基础包**\n到现在为止，我们没有为@ComponentScan设置任何属性。这意味着，按照默认规则，它会以配置类所在的包作为基础包（basepackage）来扫描组件。但是，如果你想扫描不同的包，那该怎么办呢？或者，如果你想扫描多个基础包，那又该怎么办呢？\n有一个原因会促使我们明确地设置基础包，那就是我们想要将配置类放在单独的包中，使其与其他的应用代码区分开来。如果是这样的话，那默认的基础包就不能满足要求了。要满足这样的需求其实也完全没有问题！为了指定不同的基础包，你所需要做的就是在@ComponentScan的value属性中指明包的名称：\n```java\n@Configuration\n@ComponentScan(\"soundsystem\")\npublic class CDPlayerConfig {}\n```\n如果你想更加清晰地表明你所设置的是基础包，那么你可以通过basePackages属性进行配置：\n```java\n@Configuration\n@ComponentScan(basePackages=\"soundsystem\")\npublic class CDPlayerConfig {}\n```\n可能你已经注意到了basePackages属性使用的是复数形式。如果你揣测这是不是意味着可以设置多个基础包，那么恭喜你猜对了。如果想要这么做的话，只需要将basePackages属性设置为要扫描包的一个数组即可：\n```java\n@Configuration\n@ComponentScan(basePackages={\"soundsystem\",\"video\"})\npublic class CDPlayerConfig {}\n```\n在上面的例子中，所设置的基础包是以String类型表示的。我认为这是可以的，但这种方法是类型不安全（not typesafe）的。如果你重构代码的话，那么所指定的基础包可能就会出现错误了。除了将包设置为简单的String类型之外，@ComponentScan还提供了另外一种方法，那就是将其指定为包中所包含的类或接口：\n```java\n@Configuration\n@ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class})\npublic class CDPlayerConfig {}\n```\n可以看到，basePackages属性被替换成了basePackageClasses。同时，我们不是再使用String类型的名称来指定包，为basePackageClasses属性所设置的数组中包含了类。这些类所在的包将会作为组件扫描的基础包。\n\n\n在你的应用程序中，如果所有的对象都是独立的，彼此之间没有任何依赖，就像SgtPeppersbean这样，那么你所需要的可能就是组件扫描而已。但是，很多对象会依赖其他的对象才能完成任务。这样的话，我们就需要有一种方法能够将组件扫描得到的bean和它们的依赖装配在一起。要完成这项任务，我们需要了解一下Spring自动化配置的另外一方面内容，那就是自动装配。\n\n**通过为bean添加注解实现自动装配**\n------\n简单来说，自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean。为了声明要进行自动装配，我们可以借助Spring的@Autowired注解。\n\n下面完成CDPlayer类：\n```java\npackage soundsystem;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CDPlayer implements MediaPlayer {\n  private CompactDisc cd;\n\n  @Autowired\n  public CDPlayer(CompactDisc cd) {\n    this.cd = cd;\n  }\n\n  public void play() {\n    cd.play();\n  }\n\n}\n```\n它的构造器上添加了@Autowired注解，这表明当Spring创建CDPlayerbean的时候，会通过这个构造器来进行实例化并且会传入一个可设置给CompactDisc类型的bean。\n\n@Autowired注解不仅能够用在构造器上，还能用在属性的Setter方法上。比如说，如果CDPlayer有一个setCompactDisc()方法，那么可以采用如下的注解形式进行自动装配：\n```java\n@Autowired\npublic void setCompactDisc(CompactDisc cd) {\n    this.cd = cd;\n}\n```\n\n@Autowired注解可以用在类的任何方法上。假设CDPlayer类有一个insertDisc()方法，那么@Autowired能够像在setCompactDisc()上那样，发挥完全相同的作用：\n```java\n@Autowired\npublic void insertDisc(CompactDisc cd) {\n    this.cd = cd;\n}\n```\n不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false：\n```java\n@Autowired(required=false)\npublic CDPlayer(CompactDisc cd) {\n    this.cd = cd;\n}\n```\n将required属性设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态。但是，把required属性设置为false时，你需要谨慎对待。如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现NullPointerException。如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常，表明没有明确指定要选择哪个bean进行自动装配。\n\n@Autowired是Spring特有的注解。如果你不愿意在代码中到处使用Spring的特定注解来完成自动装配任务的话，那么你可以考虑将其替换为@Inject：\n```java\npackage soundsystem;\nimport javax.inject.Inject;\nimportjavax.inject.Named;\n\n@Named\npublic cladd CDPlayer{\n    ...\n    \n    @Inject\n    public CDPlayer(CompactDisc cd){\n        this.cd = cd;\n    }\n    \n    ...\n}\n```\n@Inject注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解。在自动装配中，Spring同时支持@Inject和@Autowired。尽管@Inject和@Autowired之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。\n\n现在，我们已经在CDPlayer的构造器中添加了@Autowired注解，Spring将把一个可分配给CompactDisc类型的bean自动注入进来。为了验证这一点，让我们修改一下CDPlayerTest，使其能够借助CDPlayerbean播放CD：\n```java\npackage soundsystem;\n\nimport static org.junit.Assert.*;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.contrib.java.lang.system.StandardOutputStreamLog;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes=CDPlayerConfig.class)\npublic class CDPlayerTest {\n\n  @Rule\n  public final StandardOutputStreamLog log = new StandardOutputStreamLog();\n\n  @Autowired\n  private MediaPlayer player;\n  \n  @Autowired\n  private CompactDisc cd;\n  \n  @Test\n  public void cdShouldNotBeNull() {\n    assertNotNull(cd);\n  }\n\n  @Test\n  public void play() {\n    player.play();\n    assertEquals(\n        \"Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\\n\", \n        log.getLog());\n  }\n\n}\n```\n现在，除了注入CompactDisc，我们还将CDPlayerbean注入到测试代码的player成员变量之中（它是更为通用的\nMediaPlayer类型）。在play()测试方法中，我们可以调用CDPlayer的play()方法，并断言它的行为与你的预期一致。\n\n","slug":"Spring实战（三） 自动装配Bean","published":1,"updated":"2017-07-12T01:47:44.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hso0e000oasvl5b5rfdpx","content":"<p>在Spring中，对象无需自己查找或创建与其所关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象。例如，一个订单管理组件需要信用卡认证组件，但它不需要自己创建信用卡认证组件。订单管理组件只需要表明自己两手空空，容器就会主动赋予它一个信用卡认证组件。创建应用对象之间协作关系的行为通常称为装配（wiring），这也是依赖注入（DI）的本质。</p>\n<h1 id=\"Spring配置\"><a href=\"#Spring配置\" class=\"headerlink\" title=\"Spring配置\"></a>Spring配置</h1><p>Spring容器负责创建应用程序中的bean并通过DI来协调这些对象之间的关系。但是，作为开发人员，你需要告诉Spring要创建哪些bean并且如何将其装配在一起。当描述bean如何进行装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制：</p>\n<ul>\n<li>在XML中进行显式配置。</li>\n<li>在Java中进行显式配置。</li>\n<li>隐式的bean发现机制和自动装配。</li>\n</ul>\n<p>Spring的配置风格是可以互相搭配的，所以你可以选择使用XML装配一些bean，使用Spring基于Java的配置（JavaConfig）来装配另一些bean，而将剩余的bean让Spring去自动发现。<br>即便如此，我的建议是尽可能地使用自动配置的机制。显式配置越少越好。当你必须要显式配置bean的时候（比如，有些源码不是由你来维护的，而当你需要为这些代码配置bean的时候），我推荐使用类型安全并且比XML更加强大的JavaConfig。最后，只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应该使用XML。</p>\n<h1 id=\"自动装配Bean\"><a href=\"#自动装配Bean\" class=\"headerlink\" title=\"自动装配Bean\"></a>自动装配Bean</h1><p>Spring从两个角度来实现自动化装配：</p>\n<ul>\n<li>组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。</li>\n<li>自动装配（autowiring）：Spring自动满足bean之间的依赖。</li>\n</ul>\n<p>为了阐述组件扫描和装配，我们需要创建几个bean，它们代表了一个音响系统中的组件。首先，要创建CompactDisc类，Spring会发现它并将其创建为一个bean。然后，会创建一个CDPlayer类，让Spring发现它，并将CompactDisc bean注入进来。</p>\n<p><strong>创建可被发现的Bean</strong><br>现在有一个CD播放器，需要插入CD才能播放。也就是说CD播放器依赖于CD才能完成它的使命。<br>先写一个CompactDisc类，它是定义CD的一个接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CompactDisc</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">void</span> play;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后我们可以创建多个CD的实现，比如可以是摇滚类的也可以是古典类的，它们都要实现CD的上层接口：CompactDisc。这里只创建一个实现——SgtPeppers类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Component</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span> <span class=\"keyword\">implements</span> <span class=\"title\">CompactDisc</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">private</span> String title = <span class=\"string\">\"Sgt. Pepper's Lonely Hearts Club Band\"</span>;  </div><div class=\"line\">  <span class=\"keyword\">private</span> String artist = <span class=\"string\">\"The Beatles\"</span>;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    System.out.println(<span class=\"string\">\"Playing \"</span> + title + <span class=\"string\">\" by \"</span> + artist);</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>SgtPeppers类上使用了@Component注解。这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。没有必要显式配置SgtPeppers bean，因为这个类使用了@Component注解，所以Spring会为你把事情处理妥当。<br>不过，组件扫描默认是不启用的。我们还需要显式配置一下Spring，从而命令它去寻找带有@Component注解的类，并为其创建bean,CDPlayerConfig类完成了这个工作：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@ComponentScan</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>&#123; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>类CDPlayerConfig通过Java代码定义了Spring的装配规则。但是CDPlayerConfig类并没有显式地声明任何bean，而是使用了@ComponentScan注解，这个注解能够在Spring中启用组件扫描。如果没有其他配置的话，@ComponentScan默认会扫描与配置类相同的包。因为CDPlayerConfig类位于soundsystem包中，因此Spring将会扫描这个包以及这个包下的所有子包，查找带有@Component注解的类。这样的话，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。</p>\n<p>这个工作也可以用xml配置来完成：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">  <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">  <span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></div><div class=\"line\">  <span class=\"attr\">xmlns:c</span>=<span class=\"string\">\"http://www.springframework.org/schema/c\"</span></div><div class=\"line\">  <span class=\"attr\">xmlns:p</span>=<span class=\"string\">\"http://www.springframework.org/schema/p\"</span></div><div class=\"line\">  <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></div><div class=\"line\">\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"soundsystem\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>现在就可以创建一个测试类来试着尝试现有的功能了。在这个JUnit测试类中，先会创建Spring上下文，然后判断CompactDisc是不是真的创建出来了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.junit.Assert.*;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</div><div class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.RunWith;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.test.context.ContextConfiguration;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=CDPlayerConfig.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"keyword\">private</span> CompactDisc cd;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Test</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cdShouldNotBeNull</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    assertNotNull(cd);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>CDPlayerTest使用了Spring的SpringJUnit4ClassRunner，以便在测试开始的时候自动创建Spring的应用上下文。注解@ContextConfiguration会告诉它需要在CDPlayerConfig中加载配置。因为CDPlayerConfig类中包含了@ComponentScan，因此最终的应用上下文中应该包含CompactDisc bean。为了证明这一点，在测试代码中有一个CompactDisc类型的属性，并且这个属性带有@Autowired注解，以便于将CompactDiscbean注入到测试代码之中（稍后，我会讨论@Autowired）。最后，会有一个简单的测试方法断言cd属性不为null。如果它不为null的话，就意味着Spring能够发现CompactDisc类，自动在Spring上下文中将其创建为bean并将其注入到测试代码之中。</p>\n<p>尽管我们只用它创建了一个bean，但同样是这么少的配置能够用来发现和创建任意数量的bean。在soundsystem<br>包及其子包中，所有带有@Component注解的类都会创建为bean。只添加一行@Component Scan注解就能自动创建无数个bean，这种权衡还是很划算的。</p>\n<p>但是使用@ComponentScan和@Component组件扫描还能做别的事情：<br><strong>为组件扫描的Bean命名</strong><br>Spring应用上下文中所有的bean都会给定一个ID。在前面的例子中，尽管我们没有明确地为SgtPeppersbean设置ID，但Spring会根据类名为其指定一个ID。具体来讲，这个bean所给定的ID为sgtPeppers，也就是将类名的第一个字母变为小写。如果想为这个bean设置不同的ID，你所要做的就是将期望的ID作为值传递给@Component<br>注解。比如说，如果想将这个bean标识为lonelyHeartsClub，那么你需要将SgtPeppers类的@Component注解配置为如下所示：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Component</span>(<span class=\"string\">\"lonelyHeartsClub\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span> <span class=\"keyword\">implements</span> <span class=\"title\">CompactDisc</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>还有另外一种为bean命名的方式，这种方式不使用@Component注解，而是使用Java依赖注入规范（Java Dependency Injection）中所提供的@Named注解来为bean设置ID：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> javax.inject.Named;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Named</span>(<span class=\"string\">\"lonelyHeartsClub\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span> <span class=\"keyword\">implements</span> <span class=\"title\">CompactDisc</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Spring支持将@Named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以互相替换的。</p>\n<p><strong>设置组件扫描的的基础包</strong><br>到现在为止，我们没有为@ComponentScan设置任何属性。这意味着，按照默认规则，它会以配置类所在的包作为基础包（basepackage）来扫描组件。但是，如果你想扫描不同的包，那该怎么办呢？或者，如果你想扫描多个基础包，那又该怎么办呢？<br>有一个原因会促使我们明确地设置基础包，那就是我们想要将配置类放在单独的包中，使其与其他的应用代码区分开来。如果是这样的话，那默认的基础包就不能满足要求了。要满足这样的需求其实也完全没有问题！为了指定不同的基础包，你所需要做的就是在@ComponentScan的value属性中指明包的名称：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"soundsystem\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>\n<p>如果你想更加清晰地表明你所设置的是基础包，那么你可以通过basePackages属性进行配置：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@ComponentScan</span>(basePackages=<span class=\"string\">\"soundsystem\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>\n<p>可能你已经注意到了basePackages属性使用的是复数形式。如果你揣测这是不是意味着可以设置多个基础包，那么恭喜你猜对了。如果想要这么做的话，只需要将basePackages属性设置为要扫描包的一个数组即可：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@ComponentScan</span>(basePackages=&#123;<span class=\"string\">\"soundsystem\"</span>,<span class=\"string\">\"video\"</span>&#125;)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>\n<p>在上面的例子中，所设置的基础包是以String类型表示的。我认为这是可以的，但这种方法是类型不安全（not typesafe）的。如果你重构代码的话，那么所指定的基础包可能就会出现错误了。除了将包设置为简单的String类型之外，@ComponentScan还提供了另外一种方法，那就是将其指定为包中所包含的类或接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@ComponentScan</span>(basePackageClasses=&#123;CDPlayer.class, DVDPlayer.class&#125;)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到，basePackages属性被替换成了basePackageClasses。同时，我们不是再使用String类型的名称来指定包，为basePackageClasses属性所设置的数组中包含了类。这些类所在的包将会作为组件扫描的基础包。</p>\n<p>在你的应用程序中，如果所有的对象都是独立的，彼此之间没有任何依赖，就像SgtPeppersbean这样，那么你所需要的可能就是组件扫描而已。但是，很多对象会依赖其他的对象才能完成任务。这样的话，我们就需要有一种方法能够将组件扫描得到的bean和它们的依赖装配在一起。要完成这项任务，我们需要了解一下Spring自动化配置的另外一方面内容，那就是自动装配。</p>\n<h2 id=\"通过为bean添加注解实现自动装配\"><a href=\"#通过为bean添加注解实现自动装配\" class=\"headerlink\" title=\"通过为bean添加注解实现自动装配\"></a><strong>通过为bean添加注解实现自动装配</strong></h2><p>简单来说，自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean。为了声明要进行自动装配，我们可以借助Spring的@Autowired注解。</p>\n<p>下面完成CDPlayer类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Component</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayer</span> <span class=\"keyword\">implements</span> <span class=\"title\">MediaPlayer</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> CompactDisc cd;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CDPlayer</span><span class=\"params\">(CompactDisc cd)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cd = cd;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    cd.play();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>它的构造器上添加了@Autowired注解，这表明当Spring创建CDPlayerbean的时候，会通过这个构造器来进行实例化并且会传入一个可设置给CompactDisc类型的bean。</p>\n<p>@Autowired注解不仅能够用在构造器上，还能用在属性的Setter方法上。比如说，如果CDPlayer有一个setCompactDisc()方法，那么可以采用如下的注解形式进行自动装配：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Autowired</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCompactDisc</span><span class=\"params\">(CompactDisc cd)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cd = cd;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>@Autowired注解可以用在类的任何方法上。假设CDPlayer类有一个insertDisc()方法，那么@Autowired能够像在setCompactDisc()上那样，发挥完全相同的作用：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Autowired</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insertDisc</span><span class=\"params\">(CompactDisc cd)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cd = cd;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Autowired</span>(required=<span class=\"keyword\">false</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CDPlayer</span><span class=\"params\">(CompactDisc cd)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cd = cd;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>将required属性设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态。但是，把required属性设置为false时，你需要谨慎对待。如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现NullPointerException。如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常，表明没有明确指定要选择哪个bean进行自动装配。</p>\n<p>@Autowired是Spring特有的注解。如果你不愿意在代码中到处使用Spring的特定注解来完成自动装配任务的话，那么你可以考虑将其替换为@Inject：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.inject.Inject;</div><div class=\"line\">importjavax.inject.Named;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Named</span></div><div class=\"line\"><span class=\"keyword\">public</span> cladd CDPlayer&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Inject</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CDPlayer</span><span class=\"params\">(CompactDisc cd)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.cd = cd;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>@Inject注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解。在自动装配中，Spring同时支持@Inject和@Autowired。尽管@Inject和@Autowired之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。</p>\n<p>现在，我们已经在CDPlayer的构造器中添加了@Autowired注解，Spring将把一个可分配给CompactDisc类型的bean自动注入进来。为了验证这一点，让我们修改一下CDPlayerTest，使其能够借助CDPlayerbean播放CD：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.junit.Assert.*;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.junit.Rule;</div><div class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</div><div class=\"line\"><span class=\"keyword\">import</span> org.junit.contrib.java.lang.system.StandardOutputStreamLog;</div><div class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.RunWith;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.test.context.ContextConfiguration;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=CDPlayerConfig.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Rule</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> StandardOutputStreamLog log = <span class=\"keyword\">new</span> StandardOutputStreamLog();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"keyword\">private</span> MediaPlayer player;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"keyword\">private</span> CompactDisc cd;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Test</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cdShouldNotBeNull</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    assertNotNull(cd);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Test</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    player.play();</div><div class=\"line\">    assertEquals(</div><div class=\"line\">        <span class=\"string\">\"Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\\n\"</span>, </div><div class=\"line\">        log.getLog());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>现在，除了注入CompactDisc，我们还将CDPlayerbean注入到测试代码的player成员变量之中（它是更为通用的<br>MediaPlayer类型）。在play()测试方法中，我们可以调用CDPlayer的play()方法，并断言它的行为与你的预期一致。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在Spring中，对象无需自己查找或创建与其所关联的其他对象。相反，容器负责把需要相互协作的对象引用赋予各个对象。例如，一个订单管理组件需要信用卡认证组件，但它不需要自己创建信用卡认证组件。订单管理组件只需要表明自己两手空空，容器就会主动赋予它一个信用卡认证组件。创建应用对象之间协作关系的行为通常称为装配（wiring），这也是依赖注入（DI）的本质。</p>\n<h1 id=\"Spring配置\"><a href=\"#Spring配置\" class=\"headerlink\" title=\"Spring配置\"></a>Spring配置</h1><p>Spring容器负责创建应用程序中的bean并通过DI来协调这些对象之间的关系。但是，作为开发人员，你需要告诉Spring要创建哪些bean并且如何将其装配在一起。当描述bean如何进行装配时，Spring具有非常大的灵活性，它提供了三种主要的装配机制：</p>\n<ul>\n<li>在XML中进行显式配置。</li>\n<li>在Java中进行显式配置。</li>\n<li>隐式的bean发现机制和自动装配。</li>\n</ul>\n<p>Spring的配置风格是可以互相搭配的，所以你可以选择使用XML装配一些bean，使用Spring基于Java的配置（JavaConfig）来装配另一些bean，而将剩余的bean让Spring去自动发现。<br>即便如此，我的建议是尽可能地使用自动配置的机制。显式配置越少越好。当你必须要显式配置bean的时候（比如，有些源码不是由你来维护的，而当你需要为这些代码配置bean的时候），我推荐使用类型安全并且比XML更加强大的JavaConfig。最后，只有当你想要使用便利的XML命名空间，并且在JavaConfig中没有同样的实现时，才应该使用XML。</p>\n<h1 id=\"自动装配Bean\"><a href=\"#自动装配Bean\" class=\"headerlink\" title=\"自动装配Bean\"></a>自动装配Bean</h1><p>Spring从两个角度来实现自动化装配：</p>\n<ul>\n<li>组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。</li>\n<li>自动装配（autowiring）：Spring自动满足bean之间的依赖。</li>\n</ul>\n<p>为了阐述组件扫描和装配，我们需要创建几个bean，它们代表了一个音响系统中的组件。首先，要创建CompactDisc类，Spring会发现它并将其创建为一个bean。然后，会创建一个CDPlayer类，让Spring发现它，并将CompactDisc bean注入进来。</p>\n<p><strong>创建可被发现的Bean</strong><br>现在有一个CD播放器，需要插入CD才能播放。也就是说CD播放器依赖于CD才能完成它的使命。<br>先写一个CompactDisc类，它是定义CD的一个接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CompactDisc</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">void</span> play;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后我们可以创建多个CD的实现，比如可以是摇滚类的也可以是古典类的，它们都要实现CD的上层接口：CompactDisc。这里只创建一个实现——SgtPeppers类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Component</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span> <span class=\"keyword\">implements</span> <span class=\"title\">CompactDisc</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">private</span> String title = <span class=\"string\">\"Sgt. Pepper's Lonely Hearts Club Band\"</span>;  </div><div class=\"line\">  <span class=\"keyword\">private</span> String artist = <span class=\"string\">\"The Beatles\"</span>;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    System.out.println(<span class=\"string\">\"Playing \"</span> + title + <span class=\"string\">\" by \"</span> + artist);</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>SgtPeppers类上使用了@Component注解。这个简单的注解表明该类会作为组件类，并告知Spring要为这个类创建bean。没有必要显式配置SgtPeppers bean，因为这个类使用了@Component注解，所以Spring会为你把事情处理妥当。<br>不过，组件扫描默认是不启用的。我们还需要显式配置一下Spring，从而命令它去寻找带有@Component注解的类，并为其创建bean,CDPlayerConfig类完成了这个工作：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.ComponentScan;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@ComponentScan</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>&#123; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>类CDPlayerConfig通过Java代码定义了Spring的装配规则。但是CDPlayerConfig类并没有显式地声明任何bean，而是使用了@ComponentScan注解，这个注解能够在Spring中启用组件扫描。如果没有其他配置的话，@ComponentScan默认会扫描与配置类相同的包。因为CDPlayerConfig类位于soundsystem包中，因此Spring将会扫描这个包以及这个包下的所有子包，查找带有@Component注解的类。这样的话，就能发现CompactDisc，并且会在Spring中自动为其创建一个bean。</p>\n<p>这个工作也可以用xml配置来完成：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></div><div class=\"line\">  <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></div><div class=\"line\">  <span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span></div><div class=\"line\">  <span class=\"attr\">xmlns:c</span>=<span class=\"string\">\"http://www.springframework.org/schema/c\"</span></div><div class=\"line\">  <span class=\"attr\">xmlns:p</span>=<span class=\"string\">\"http://www.springframework.org/schema/p\"</span></div><div class=\"line\">  <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></div><div class=\"line\">\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"soundsystem\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>现在就可以创建一个测试类来试着尝试现有的功能了。在这个JUnit测试类中，先会创建Spring上下文，然后判断CompactDisc是不是真的创建出来了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.junit.Assert.*;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</div><div class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.RunWith;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.test.context.ContextConfiguration;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=CDPlayerConfig.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"keyword\">private</span> CompactDisc cd;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Test</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cdShouldNotBeNull</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    assertNotNull(cd);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>CDPlayerTest使用了Spring的SpringJUnit4ClassRunner，以便在测试开始的时候自动创建Spring的应用上下文。注解@ContextConfiguration会告诉它需要在CDPlayerConfig中加载配置。因为CDPlayerConfig类中包含了@ComponentScan，因此最终的应用上下文中应该包含CompactDisc bean。为了证明这一点，在测试代码中有一个CompactDisc类型的属性，并且这个属性带有@Autowired注解，以便于将CompactDiscbean注入到测试代码之中（稍后，我会讨论@Autowired）。最后，会有一个简单的测试方法断言cd属性不为null。如果它不为null的话，就意味着Spring能够发现CompactDisc类，自动在Spring上下文中将其创建为bean并将其注入到测试代码之中。</p>\n<p>尽管我们只用它创建了一个bean，但同样是这么少的配置能够用来发现和创建任意数量的bean。在soundsystem<br>包及其子包中，所有带有@Component注解的类都会创建为bean。只添加一行@Component Scan注解就能自动创建无数个bean，这种权衡还是很划算的。</p>\n<p>但是使用@ComponentScan和@Component组件扫描还能做别的事情：<br><strong>为组件扫描的Bean命名</strong><br>Spring应用上下文中所有的bean都会给定一个ID。在前面的例子中，尽管我们没有明确地为SgtPeppersbean设置ID，但Spring会根据类名为其指定一个ID。具体来讲，这个bean所给定的ID为sgtPeppers，也就是将类名的第一个字母变为小写。如果想为这个bean设置不同的ID，你所要做的就是将期望的ID作为值传递给@Component<br>注解。比如说，如果想将这个bean标识为lonelyHeartsClub，那么你需要将SgtPeppers类的@Component注解配置为如下所示：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Component</span>(<span class=\"string\">\"lonelyHeartsClub\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span> <span class=\"keyword\">implements</span> <span class=\"title\">CompactDisc</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>还有另外一种为bean命名的方式，这种方式不使用@Component注解，而是使用Java依赖注入规范（Java Dependency Injection）中所提供的@Named注解来为bean设置ID：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> javax.inject.Named;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Named</span>(<span class=\"string\">\"lonelyHeartsClub\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SgtPeppers</span> <span class=\"keyword\">implements</span> <span class=\"title\">CompactDisc</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Spring支持将@Named作为@Component注解的替代方案。两者之间有一些细微的差异，但是在大多数场景中，它们是可以互相替换的。</p>\n<p><strong>设置组件扫描的的基础包</strong><br>到现在为止，我们没有为@ComponentScan设置任何属性。这意味着，按照默认规则，它会以配置类所在的包作为基础包（basepackage）来扫描组件。但是，如果你想扫描不同的包，那该怎么办呢？或者，如果你想扫描多个基础包，那又该怎么办呢？<br>有一个原因会促使我们明确地设置基础包，那就是我们想要将配置类放在单独的包中，使其与其他的应用代码区分开来。如果是这样的话，那默认的基础包就不能满足要求了。要满足这样的需求其实也完全没有问题！为了指定不同的基础包，你所需要做的就是在@ComponentScan的value属性中指明包的名称：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"soundsystem\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>\n<p>如果你想更加清晰地表明你所设置的是基础包，那么你可以通过basePackages属性进行配置：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@ComponentScan</span>(basePackages=<span class=\"string\">\"soundsystem\"</span>)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>\n<p>可能你已经注意到了basePackages属性使用的是复数形式。如果你揣测这是不是意味着可以设置多个基础包，那么恭喜你猜对了。如果想要这么做的话，只需要将basePackages属性设置为要扫描包的一个数组即可：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@ComponentScan</span>(basePackages=&#123;<span class=\"string\">\"soundsystem\"</span>,<span class=\"string\">\"video\"</span>&#125;)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>\n<p>在上面的例子中，所设置的基础包是以String类型表示的。我认为这是可以的，但这种方法是类型不安全（not typesafe）的。如果你重构代码的话，那么所指定的基础包可能就会出现错误了。除了将包设置为简单的String类型之外，@ComponentScan还提供了另外一种方法，那就是将其指定为包中所包含的类或接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Configuration</span></div><div class=\"line\"><span class=\"meta\">@ComponentScan</span>(basePackageClasses=&#123;CDPlayer.class, DVDPlayer.class&#125;)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerConfig</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到，basePackages属性被替换成了basePackageClasses。同时，我们不是再使用String类型的名称来指定包，为basePackageClasses属性所设置的数组中包含了类。这些类所在的包将会作为组件扫描的基础包。</p>\n<p>在你的应用程序中，如果所有的对象都是独立的，彼此之间没有任何依赖，就像SgtPeppersbean这样，那么你所需要的可能就是组件扫描而已。但是，很多对象会依赖其他的对象才能完成任务。这样的话，我们就需要有一种方法能够将组件扫描得到的bean和它们的依赖装配在一起。要完成这项任务，我们需要了解一下Spring自动化配置的另外一方面内容，那就是自动装配。</p>\n<h2 id=\"通过为bean添加注解实现自动装配\"><a href=\"#通过为bean添加注解实现自动装配\" class=\"headerlink\" title=\"通过为bean添加注解实现自动装配\"></a><strong>通过为bean添加注解实现自动装配</strong></h2><p>简单来说，自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其他bean。为了声明要进行自动装配，我们可以借助Spring的@Autowired注解。</p>\n<p>下面完成CDPlayer类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Component</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayer</span> <span class=\"keyword\">implements</span> <span class=\"title\">MediaPlayer</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> CompactDisc cd;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CDPlayer</span><span class=\"params\">(CompactDisc cd)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cd = cd;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    cd.play();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>它的构造器上添加了@Autowired注解，这表明当Spring创建CDPlayerbean的时候，会通过这个构造器来进行实例化并且会传入一个可设置给CompactDisc类型的bean。</p>\n<p>@Autowired注解不仅能够用在构造器上，还能用在属性的Setter方法上。比如说，如果CDPlayer有一个setCompactDisc()方法，那么可以采用如下的注解形式进行自动装配：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Autowired</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCompactDisc</span><span class=\"params\">(CompactDisc cd)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cd = cd;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>@Autowired注解可以用在类的任何方法上。假设CDPlayer类有一个insertDisc()方法，那么@Autowired能够像在setCompactDisc()上那样，发挥完全相同的作用：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Autowired</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insertDisc</span><span class=\"params\">(CompactDisc cd)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cd = cd;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>不管是构造器、Setter方法还是其他的方法，Spring都会尝试满足方法参数上所声明的依赖。假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被装配进来。如果没有匹配的bean，那么在应用上下文创建的时候，Spring会抛出一个异常。为了避免异常的出现，你可以将@Autowired的required属性设置为false：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Autowired</span>(required=<span class=\"keyword\">false</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CDPlayer</span><span class=\"params\">(CompactDisc cd)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cd = cd;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>将required属性设置为false时，Spring会尝试执行自动装配，但是如果没有匹配的bean的话，Spring将会让这个bean处于未装配的状态。但是，把required属性设置为false时，你需要谨慎对待。如果在你的代码中没有进行null检查的话，这个处于未装配状态的属性有可能会出现NullPointerException。如果有多个bean都能满足依赖关系的话，Spring将会抛出一个异常，表明没有明确指定要选择哪个bean进行自动装配。</p>\n<p>@Autowired是Spring特有的注解。如果你不愿意在代码中到处使用Spring的特定注解来完成自动装配任务的话，那么你可以考虑将其替换为@Inject：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"><span class=\"keyword\">import</span> javax.inject.Inject;</div><div class=\"line\">importjavax.inject.Named;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@Named</span></div><div class=\"line\"><span class=\"keyword\">public</span> cladd CDPlayer&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Inject</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CDPlayer</span><span class=\"params\">(CompactDisc cd)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.cd = cd;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>@Inject注解来源于Java依赖注入规范，该规范同时还为我们定义了@Named注解。在自动装配中，Spring同时支持@Inject和@Autowired。尽管@Inject和@Autowired之间有着一些细微的差别，但是在大多数场景下，它们都是可以互相替换的。</p>\n<p>现在，我们已经在CDPlayer的构造器中添加了@Autowired注解，Spring将把一个可分配给CompactDisc类型的bean自动注入进来。为了验证这一点，让我们修改一下CDPlayerTest，使其能够借助CDPlayerbean播放CD：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> soundsystem;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.junit.Assert.*;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> org.junit.Rule;</div><div class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</div><div class=\"line\"><span class=\"keyword\">import</span> org.junit.contrib.java.lang.system.StandardOutputStreamLog;</div><div class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.RunWith;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.test.context.ContextConfiguration;</div><div class=\"line\"><span class=\"keyword\">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</div><div class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=CDPlayerConfig.class)</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CDPlayerTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Rule</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> StandardOutputStreamLog log = <span class=\"keyword\">new</span> StandardOutputStreamLog();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"keyword\">private</span> MediaPlayer player;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Autowired</span></div><div class=\"line\">  <span class=\"keyword\">private</span> CompactDisc cd;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"meta\">@Test</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cdShouldNotBeNull</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    assertNotNull(cd);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"meta\">@Test</span></div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    player.play();</div><div class=\"line\">    assertEquals(</div><div class=\"line\">        <span class=\"string\">\"Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\\n\"</span>, </div><div class=\"line\">        log.getLog());</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>现在，除了注入CompactDisc，我们还将CDPlayerbean注入到测试代码的player成员变量之中（它是更为通用的<br>MediaPlayer类型）。在play()测试方法中，我们可以调用CDPlayer的play()方法，并断言它的行为与你的预期一致。</p>\n"},{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">Head First设计模式-策略模式</font>","date":"2017-05-23T00:59:26.000Z","_content":"**设计原则：**\n=========\n\n - 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。把会变化的部分取出并封装起来，好让其他部分不会受到影响。\n - 针对接口编程，而不是针对实现编程。“针对接口编程”的真正意思是针对超类编程。即：变量的申明类应该是超类型，通常是一个抽象类或者一个接口，如此，只要是具体实现此超类的类所产生的对象，都可以指定给这个变量。这也意味着，声明类时不用理会以后执行时的真正对象类型。\n - 多用组合，少用继承\n\n**举例：**\n===\n世界上有各种鸭子，它们外观不同，但是都会游泳，也都会叫。用传统的面向对象的思路来设计，首先有一个Duck的抽象超类，并让各种鸭子继承这个超类。\n\n| Duck |\n|:------|\n|quack()//鸭子叫的方法|\n|swim()//鸭子游泳的方法|\n|display()//鸭子外观的方法|\n如果是传统的面向对象思想，所有的鸭子都会叫，也都会游泳，所以quack()方法和swim()方法放在超类Duck中实现，而由于每只鸭子的外观不同，所以display()方法在Duck类中设计成抽象方法，由具体的鸭子继承超类后自己去实现。比如现在有绿头鸭MallardDuck和红头鸭ReaheadDuck，它们继承超类Duck，所以有了quack和swim的功能，同时实现display方法从而有了不同的外观。\n\n但是这样设计有一个问题：\n需求开始增加，经过分析，发现鸭子都会飞，所以要给鸭子加上飞的功能。最普通的方法是在Duck超类中加一个fly()的方法并实现。这样每一个鸭子继承Duck之后就有了fly()的功能。但是发现需求有误，实际上并不是所有鸭子都会飞。比如尖叫鸭（类似于尖叫鸡），会叫也会游泳，但是尖叫鸭的叫声是“吱吱”，而不是普通鸭子的“咕咕”。所以尖叫鸭继承Duck之后首先要覆盖掉超类中的quack()方法。最严重的问题是尖叫鸭不会飞，但是继承Duck后它有了飞的功能，这肯定不对。同样的方法就是子类继承超类之后覆盖掉Duck中的fly()方法。但是，如果以后还要加入另一种诱饵鸭子，它其实是一个木头假鸭，不会叫也不会飞。难道又要覆盖掉quack()方法和fly()方法吗？这样太不优雅了。可以看到用继承的方式来提供Duck的行为，会使代码牵一发动全身，不便于维护，也不便于扩展。\n\n所以需要一个更清晰的方法，让“某些”而不是全部鸭子可飞或者可叫。\n很自然的一种想法是把飞好叫的行为从Duck超类拿出来，另外设计成接口：Flyable和Quackable。\n\n| Duck//抽象类 | | Flyable//接口|  | Quackable//接口|\n|:------| |:--------|  |:--------|\n|swim()//普通方法| | fly()//接口中的抽象方法| | quack()//接口中的抽象方法|\n|display()//抽象方法||||||\n这样尖叫鸭可以继承Duck超类，同时实现Quackable接口，而普通鸭子可以继承Duck超类并同时实现Flyable和Quack接口，但是可以看到，每实现一次接口就要重写一此接口中的方法，重复的代码就会急剧增加。显然这不是一种好的方法。\n\n可以看出造成目前这种困境的原因是需求一直在改变。而现实中需求的改变又恰恰是经常会出现的问题。这个时候就要**找出应用中可能需要经常变化的地方，把他们独立出来，不要和那些不需要变化的代码混在一起。也就是把会变化的部分取出并封装起来，好让其他部分不会受到影响。**\n那么具体到这个例子中要怎么做呢？首先在原始的Duck类中把fly()和quack()拿掉，然后建立两组类，一类与fly相关，一类与quack相关，它们分别实现FlyBehavior和QuackBehavior接口。每一组类将实现各自的动作，可能有一个类实现Quackbehhavior接口完成了“咕咕叫”(Quack类)，另一个类实现Quackbehhavior接口完成了“吱吱叫”(SQuack类)，还有一个类实现Quackbehhavior接口完成了“安静”(MuteQuack类)。另外还有一个类实现FlyBehavior接口完成了“飞”的功能（FlyWithSwing类），还有一个类实现FlyBehavior接口完成了“不能飞”（FlyNoWay类）。\n但仅仅是这样还不够，因为Java中并没有多继承，如果继承了Duck超类，就不能继承那些实现了FlyBehavior或QuackBehavior的具体实现类。所以要想一种办法把Duck类和我们分离出来的行为整合起来。其实就是在Duck类中添加FlyBehavior和QuackBehavior的属性：\n\n|Duck|\n|:-------------------|\n|FlyBehavior flyBehavior//飞属性    |\n|QuackBehavior quackBehavior//叫属性|\n|swim()//鸭子游泳的方法            |\n|display()//鸭子外观的方法         |\n|performFly()//飞行方法            |\n|performQuack()//叫方法            |\n```java\npublic class Duck{\n    FlyBehavior flyBehavior;\n    QuackBehavior quackBehavior;\n    \n    //set、get方法\n    ...\n    public abstract void display();\n    public void swim(){\n        ...\n    }\n    public void performFly(){\n        flyBehavior.fly();\n    }\n    public void performQuack(){\n        quackBehavior.quack();\n    }\n}\n```\n这样当我们实现尖叫鸭的时候：\n```java\npublic class ScreamDuck extends Duck{\n    public ScreamDuck(){\n        quackBehavior = new SQuack();\n        flyBehavior = new FlyNoWay();\n    }\n    @override\n    public void display(){\n        ...\n    }\n}\n```\n这样就实现了一个尖叫鸭。而普通绿头鸭子就是：\n```java\npublic class MallardDuck extends Duck{\n    public MallardDuck(){\n        quackBehavior = new Quack();\n        flyBehavior = new FlyWithSwing();\n    }\n    @override\n    public void display(){\n        ...\n    }\n}\n```\n这样维护和扩展都容易多了。\n\n这就是**策略模式**，\n**\n**策略模式的定义：**\n========\n\n**\n定义了算法簇，分别封装起来，让它们之间可以互相替换。这个模式可以让算法的变化独立于使用算法的客户。\n**策略模式的结构：**\n======\n![策略模式的结构][1]\n  [1]: http://my.csdn.net/uploads/201205/11/1336732187_4598.jpg\n**\n**策略模式的组成：**\n=======\n**环境类(Context)**:用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。\n**抽象策略类(Strategy)**:定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。\n**具体策略类(ConcreteStrategy)**:以Strategy接口实现某具体算法。\n","source":"_posts/java设计模式-策略模式.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">Head First设计模式-策略模式</font>\ndate: 2017-05-23 08:59:26\ncategories: java读书笔记\ntags: [java,设计模式,策略模式]\n---\n**设计原则：**\n=========\n\n - 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。把会变化的部分取出并封装起来，好让其他部分不会受到影响。\n - 针对接口编程，而不是针对实现编程。“针对接口编程”的真正意思是针对超类编程。即：变量的申明类应该是超类型，通常是一个抽象类或者一个接口，如此，只要是具体实现此超类的类所产生的对象，都可以指定给这个变量。这也意味着，声明类时不用理会以后执行时的真正对象类型。\n - 多用组合，少用继承\n\n**举例：**\n===\n世界上有各种鸭子，它们外观不同，但是都会游泳，也都会叫。用传统的面向对象的思路来设计，首先有一个Duck的抽象超类，并让各种鸭子继承这个超类。\n\n| Duck |\n|:------|\n|quack()//鸭子叫的方法|\n|swim()//鸭子游泳的方法|\n|display()//鸭子外观的方法|\n如果是传统的面向对象思想，所有的鸭子都会叫，也都会游泳，所以quack()方法和swim()方法放在超类Duck中实现，而由于每只鸭子的外观不同，所以display()方法在Duck类中设计成抽象方法，由具体的鸭子继承超类后自己去实现。比如现在有绿头鸭MallardDuck和红头鸭ReaheadDuck，它们继承超类Duck，所以有了quack和swim的功能，同时实现display方法从而有了不同的外观。\n\n但是这样设计有一个问题：\n需求开始增加，经过分析，发现鸭子都会飞，所以要给鸭子加上飞的功能。最普通的方法是在Duck超类中加一个fly()的方法并实现。这样每一个鸭子继承Duck之后就有了fly()的功能。但是发现需求有误，实际上并不是所有鸭子都会飞。比如尖叫鸭（类似于尖叫鸡），会叫也会游泳，但是尖叫鸭的叫声是“吱吱”，而不是普通鸭子的“咕咕”。所以尖叫鸭继承Duck之后首先要覆盖掉超类中的quack()方法。最严重的问题是尖叫鸭不会飞，但是继承Duck后它有了飞的功能，这肯定不对。同样的方法就是子类继承超类之后覆盖掉Duck中的fly()方法。但是，如果以后还要加入另一种诱饵鸭子，它其实是一个木头假鸭，不会叫也不会飞。难道又要覆盖掉quack()方法和fly()方法吗？这样太不优雅了。可以看到用继承的方式来提供Duck的行为，会使代码牵一发动全身，不便于维护，也不便于扩展。\n\n所以需要一个更清晰的方法，让“某些”而不是全部鸭子可飞或者可叫。\n很自然的一种想法是把飞好叫的行为从Duck超类拿出来，另外设计成接口：Flyable和Quackable。\n\n| Duck//抽象类 | | Flyable//接口|  | Quackable//接口|\n|:------| |:--------|  |:--------|\n|swim()//普通方法| | fly()//接口中的抽象方法| | quack()//接口中的抽象方法|\n|display()//抽象方法||||||\n这样尖叫鸭可以继承Duck超类，同时实现Quackable接口，而普通鸭子可以继承Duck超类并同时实现Flyable和Quack接口，但是可以看到，每实现一次接口就要重写一此接口中的方法，重复的代码就会急剧增加。显然这不是一种好的方法。\n\n可以看出造成目前这种困境的原因是需求一直在改变。而现实中需求的改变又恰恰是经常会出现的问题。这个时候就要**找出应用中可能需要经常变化的地方，把他们独立出来，不要和那些不需要变化的代码混在一起。也就是把会变化的部分取出并封装起来，好让其他部分不会受到影响。**\n那么具体到这个例子中要怎么做呢？首先在原始的Duck类中把fly()和quack()拿掉，然后建立两组类，一类与fly相关，一类与quack相关，它们分别实现FlyBehavior和QuackBehavior接口。每一组类将实现各自的动作，可能有一个类实现Quackbehhavior接口完成了“咕咕叫”(Quack类)，另一个类实现Quackbehhavior接口完成了“吱吱叫”(SQuack类)，还有一个类实现Quackbehhavior接口完成了“安静”(MuteQuack类)。另外还有一个类实现FlyBehavior接口完成了“飞”的功能（FlyWithSwing类），还有一个类实现FlyBehavior接口完成了“不能飞”（FlyNoWay类）。\n但仅仅是这样还不够，因为Java中并没有多继承，如果继承了Duck超类，就不能继承那些实现了FlyBehavior或QuackBehavior的具体实现类。所以要想一种办法把Duck类和我们分离出来的行为整合起来。其实就是在Duck类中添加FlyBehavior和QuackBehavior的属性：\n\n|Duck|\n|:-------------------|\n|FlyBehavior flyBehavior//飞属性    |\n|QuackBehavior quackBehavior//叫属性|\n|swim()//鸭子游泳的方法            |\n|display()//鸭子外观的方法         |\n|performFly()//飞行方法            |\n|performQuack()//叫方法            |\n```java\npublic class Duck{\n    FlyBehavior flyBehavior;\n    QuackBehavior quackBehavior;\n    \n    //set、get方法\n    ...\n    public abstract void display();\n    public void swim(){\n        ...\n    }\n    public void performFly(){\n        flyBehavior.fly();\n    }\n    public void performQuack(){\n        quackBehavior.quack();\n    }\n}\n```\n这样当我们实现尖叫鸭的时候：\n```java\npublic class ScreamDuck extends Duck{\n    public ScreamDuck(){\n        quackBehavior = new SQuack();\n        flyBehavior = new FlyNoWay();\n    }\n    @override\n    public void display(){\n        ...\n    }\n}\n```\n这样就实现了一个尖叫鸭。而普通绿头鸭子就是：\n```java\npublic class MallardDuck extends Duck{\n    public MallardDuck(){\n        quackBehavior = new Quack();\n        flyBehavior = new FlyWithSwing();\n    }\n    @override\n    public void display(){\n        ...\n    }\n}\n```\n这样维护和扩展都容易多了。\n\n这就是**策略模式**，\n**\n**策略模式的定义：**\n========\n\n**\n定义了算法簇，分别封装起来，让它们之间可以互相替换。这个模式可以让算法的变化独立于使用算法的客户。\n**策略模式的结构：**\n======\n![策略模式的结构][1]\n  [1]: http://my.csdn.net/uploads/201205/11/1336732187_4598.jpg\n**\n**策略模式的组成：**\n=======\n**环境类(Context)**:用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。\n**抽象策略类(Strategy)**:定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。\n**具体策略类(ConcreteStrategy)**:以Strategy接口实现某具体算法。\n","slug":"java设计模式-策略模式","published":1,"updated":"2017-07-12T01:50:18.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hso0f000rasvlxsdqnrew","content":"<h1 id=\"设计原则：\"><a href=\"#设计原则：\" class=\"headerlink\" title=\"设计原则：\"></a><strong>设计原则：</strong></h1><ul>\n<li>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。把会变化的部分取出并封装起来，好让其他部分不会受到影响。</li>\n<li>针对接口编程，而不是针对实现编程。“针对接口编程”的真正意思是针对超类编程。即：变量的申明类应该是超类型，通常是一个抽象类或者一个接口，如此，只要是具体实现此超类的类所产生的对象，都可以指定给这个变量。这也意味着，声明类时不用理会以后执行时的真正对象类型。</li>\n<li>多用组合，少用继承</li>\n</ul>\n<h1 id=\"举例：\"><a href=\"#举例：\" class=\"headerlink\" title=\"举例：\"></a><strong>举例：</strong></h1><p>世界上有各种鸭子，它们外观不同，但是都会游泳，也都会叫。用传统的面向对象的思路来设计，首先有一个Duck的抽象超类，并让各种鸭子继承这个超类。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Duck</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">quack()//鸭子叫的方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">swim()//鸭子游泳的方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">display()//鸭子外观的方法</td>\n</tr>\n</tbody>\n</table>\n<p>如果是传统的面向对象思想，所有的鸭子都会叫，也都会游泳，所以quack()方法和swim()方法放在超类Duck中实现，而由于每只鸭子的外观不同，所以display()方法在Duck类中设计成抽象方法，由具体的鸭子继承超类后自己去实现。比如现在有绿头鸭MallardDuck和红头鸭ReaheadDuck，它们继承超类Duck，所以有了quack和swim的功能，同时实现display方法从而有了不同的外观。</p>\n<p>但是这样设计有一个问题：<br>需求开始增加，经过分析，发现鸭子都会飞，所以要给鸭子加上飞的功能。最普通的方法是在Duck超类中加一个fly()的方法并实现。这样每一个鸭子继承Duck之后就有了fly()的功能。但是发现需求有误，实际上并不是所有鸭子都会飞。比如尖叫鸭（类似于尖叫鸡），会叫也会游泳，但是尖叫鸭的叫声是“吱吱”，而不是普通鸭子的“咕咕”。所以尖叫鸭继承Duck之后首先要覆盖掉超类中的quack()方法。最严重的问题是尖叫鸭不会飞，但是继承Duck后它有了飞的功能，这肯定不对。同样的方法就是子类继承超类之后覆盖掉Duck中的fly()方法。但是，如果以后还要加入另一种诱饵鸭子，它其实是一个木头假鸭，不会叫也不会飞。难道又要覆盖掉quack()方法和fly()方法吗？这样太不优雅了。可以看到用继承的方式来提供Duck的行为，会使代码牵一发动全身，不便于维护，也不便于扩展。</p>\n<p>所以需要一个更清晰的方法，让“某些”而不是全部鸭子可飞或者可叫。<br>很自然的一种想法是把飞好叫的行为从Duck超类拿出来，另外设计成接口：Flyable和Quackable。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Duck//抽象类</th>\n<th></th>\n<th style=\"text-align:left\">Flyable//接口</th>\n<th></th>\n<th style=\"text-align:left\">Quackable//接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">swim()//普通方法</td>\n<td></td>\n<td style=\"text-align:left\">fly()//接口中的抽象方法</td>\n<td></td>\n<td style=\"text-align:left\">quack()//接口中的抽象方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">display()//抽象方法</td>\n<td></td>\n<td style=\"text-align:left\"></td>\n<td></td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<p>这样尖叫鸭可以继承Duck超类，同时实现Quackable接口，而普通鸭子可以继承Duck超类并同时实现Flyable和Quack接口，但是可以看到，每实现一次接口就要重写一此接口中的方法，重复的代码就会急剧增加。显然这不是一种好的方法。</p>\n<p>可以看出造成目前这种困境的原因是需求一直在改变。而现实中需求的改变又恰恰是经常会出现的问题。这个时候就要<strong>找出应用中可能需要经常变化的地方，把他们独立出来，不要和那些不需要变化的代码混在一起。也就是把会变化的部分取出并封装起来，好让其他部分不会受到影响。</strong><br>那么具体到这个例子中要怎么做呢？首先在原始的Duck类中把fly()和quack()拿掉，然后建立两组类，一类与fly相关，一类与quack相关，它们分别实现FlyBehavior和QuackBehavior接口。每一组类将实现各自的动作，可能有一个类实现Quackbehhavior接口完成了“咕咕叫”(Quack类)，另一个类实现Quackbehhavior接口完成了“吱吱叫”(SQuack类)，还有一个类实现Quackbehhavior接口完成了“安静”(MuteQuack类)。另外还有一个类实现FlyBehavior接口完成了“飞”的功能（FlyWithSwing类），还有一个类实现FlyBehavior接口完成了“不能飞”（FlyNoWay类）。<br>但仅仅是这样还不够，因为Java中并没有多继承，如果继承了Duck超类，就不能继承那些实现了FlyBehavior或QuackBehavior的具体实现类。所以要想一种办法把Duck类和我们分离出来的行为整合起来。其实就是在Duck类中添加FlyBehavior和QuackBehavior的属性：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Duck</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">FlyBehavior flyBehavior//飞属性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">QuackBehavior quackBehavior//叫属性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">swim()//鸭子游泳的方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">display()//鸭子外观的方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">performFly()//飞行方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">performQuack()//叫方法</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Duck</span></span>&#123;</div><div class=\"line\">    FlyBehavior flyBehavior;</div><div class=\"line\">    QuackBehavior quackBehavior;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//set、get方法</span></div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">performFly</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        flyBehavior.fly();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">performQuack</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        quackBehavior.quack();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样当我们实现尖叫鸭的时候：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScreamDuck</span> <span class=\"keyword\">extends</span> <span class=\"title\">Duck</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScreamDuck</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        quackBehavior = <span class=\"keyword\">new</span> SQuack();</div><div class=\"line\">        flyBehavior = <span class=\"keyword\">new</span> FlyNoWay();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样就实现了一个尖叫鸭。而普通绿头鸭子就是：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MallardDuck</span> <span class=\"keyword\">extends</span> <span class=\"title\">Duck</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MallardDuck</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        quackBehavior = <span class=\"keyword\">new</span> Quack();</div><div class=\"line\">        flyBehavior = <span class=\"keyword\">new</span> FlyWithSwing();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样维护和扩展都容易多了。</p>\n<p>这就是<strong>策略模式</strong>，<br>**</p>\n<h1 id=\"策略模式的定义：\"><a href=\"#策略模式的定义：\" class=\"headerlink\" title=\"策略模式的定义：\"></a><strong>策略模式的定义：</strong></h1><p>**<br>定义了算法簇，分别封装起来，让它们之间可以互相替换。这个模式可以让算法的变化独立于使用算法的客户。</p>\n<h1 id=\"策略模式的结构：\"><a href=\"#策略模式的结构：\" class=\"headerlink\" title=\"策略模式的结构：\"></a><strong>策略模式的结构：</strong></h1><p><img src=\"http://my.csdn.net/uploads/201205/11/1336732187_4598.jpg\" alt=\"策略模式的结构\"></p>\n<p>**</p>\n<h1 id=\"策略模式的组成：\"><a href=\"#策略模式的组成：\" class=\"headerlink\" title=\"策略模式的组成：\"></a><strong>策略模式的组成：</strong></h1><p><strong>环境类(Context)</strong>:用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。<br><strong>抽象策略类(Strategy)</strong>:定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。<br><strong>具体策略类(ConcreteStrategy)</strong>:以Strategy接口实现某具体算法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"设计原则：\"><a href=\"#设计原则：\" class=\"headerlink\" title=\"设计原则：\"></a><strong>设计原则：</strong></h1><ul>\n<li>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。把会变化的部分取出并封装起来，好让其他部分不会受到影响。</li>\n<li>针对接口编程，而不是针对实现编程。“针对接口编程”的真正意思是针对超类编程。即：变量的申明类应该是超类型，通常是一个抽象类或者一个接口，如此，只要是具体实现此超类的类所产生的对象，都可以指定给这个变量。这也意味着，声明类时不用理会以后执行时的真正对象类型。</li>\n<li>多用组合，少用继承</li>\n</ul>\n<h1 id=\"举例：\"><a href=\"#举例：\" class=\"headerlink\" title=\"举例：\"></a><strong>举例：</strong></h1><p>世界上有各种鸭子，它们外观不同，但是都会游泳，也都会叫。用传统的面向对象的思路来设计，首先有一个Duck的抽象超类，并让各种鸭子继承这个超类。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Duck</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">quack()//鸭子叫的方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">swim()//鸭子游泳的方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">display()//鸭子外观的方法</td>\n</tr>\n</tbody>\n</table>\n<p>如果是传统的面向对象思想，所有的鸭子都会叫，也都会游泳，所以quack()方法和swim()方法放在超类Duck中实现，而由于每只鸭子的外观不同，所以display()方法在Duck类中设计成抽象方法，由具体的鸭子继承超类后自己去实现。比如现在有绿头鸭MallardDuck和红头鸭ReaheadDuck，它们继承超类Duck，所以有了quack和swim的功能，同时实现display方法从而有了不同的外观。</p>\n<p>但是这样设计有一个问题：<br>需求开始增加，经过分析，发现鸭子都会飞，所以要给鸭子加上飞的功能。最普通的方法是在Duck超类中加一个fly()的方法并实现。这样每一个鸭子继承Duck之后就有了fly()的功能。但是发现需求有误，实际上并不是所有鸭子都会飞。比如尖叫鸭（类似于尖叫鸡），会叫也会游泳，但是尖叫鸭的叫声是“吱吱”，而不是普通鸭子的“咕咕”。所以尖叫鸭继承Duck之后首先要覆盖掉超类中的quack()方法。最严重的问题是尖叫鸭不会飞，但是继承Duck后它有了飞的功能，这肯定不对。同样的方法就是子类继承超类之后覆盖掉Duck中的fly()方法。但是，如果以后还要加入另一种诱饵鸭子，它其实是一个木头假鸭，不会叫也不会飞。难道又要覆盖掉quack()方法和fly()方法吗？这样太不优雅了。可以看到用继承的方式来提供Duck的行为，会使代码牵一发动全身，不便于维护，也不便于扩展。</p>\n<p>所以需要一个更清晰的方法，让“某些”而不是全部鸭子可飞或者可叫。<br>很自然的一种想法是把飞好叫的行为从Duck超类拿出来，另外设计成接口：Flyable和Quackable。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Duck//抽象类</th>\n<th></th>\n<th style=\"text-align:left\">Flyable//接口</th>\n<th></th>\n<th style=\"text-align:left\">Quackable//接口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">swim()//普通方法</td>\n<td></td>\n<td style=\"text-align:left\">fly()//接口中的抽象方法</td>\n<td></td>\n<td style=\"text-align:left\">quack()//接口中的抽象方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">display()//抽象方法</td>\n<td></td>\n<td style=\"text-align:left\"></td>\n<td></td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<p>这样尖叫鸭可以继承Duck超类，同时实现Quackable接口，而普通鸭子可以继承Duck超类并同时实现Flyable和Quack接口，但是可以看到，每实现一次接口就要重写一此接口中的方法，重复的代码就会急剧增加。显然这不是一种好的方法。</p>\n<p>可以看出造成目前这种困境的原因是需求一直在改变。而现实中需求的改变又恰恰是经常会出现的问题。这个时候就要<strong>找出应用中可能需要经常变化的地方，把他们独立出来，不要和那些不需要变化的代码混在一起。也就是把会变化的部分取出并封装起来，好让其他部分不会受到影响。</strong><br>那么具体到这个例子中要怎么做呢？首先在原始的Duck类中把fly()和quack()拿掉，然后建立两组类，一类与fly相关，一类与quack相关，它们分别实现FlyBehavior和QuackBehavior接口。每一组类将实现各自的动作，可能有一个类实现Quackbehhavior接口完成了“咕咕叫”(Quack类)，另一个类实现Quackbehhavior接口完成了“吱吱叫”(SQuack类)，还有一个类实现Quackbehhavior接口完成了“安静”(MuteQuack类)。另外还有一个类实现FlyBehavior接口完成了“飞”的功能（FlyWithSwing类），还有一个类实现FlyBehavior接口完成了“不能飞”（FlyNoWay类）。<br>但仅仅是这样还不够，因为Java中并没有多继承，如果继承了Duck超类，就不能继承那些实现了FlyBehavior或QuackBehavior的具体实现类。所以要想一种办法把Duck类和我们分离出来的行为整合起来。其实就是在Duck类中添加FlyBehavior和QuackBehavior的属性：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Duck</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">FlyBehavior flyBehavior//飞属性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">QuackBehavior quackBehavior//叫属性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">swim()//鸭子游泳的方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">display()//鸭子外观的方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">performFly()//飞行方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">performQuack()//叫方法</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Duck</span></span>&#123;</div><div class=\"line\">    FlyBehavior flyBehavior;</div><div class=\"line\">    QuackBehavior quackBehavior;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">//set、get方法</span></div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">performFly</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        flyBehavior.fly();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">performQuack</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        quackBehavior.quack();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样当我们实现尖叫鸭的时候：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScreamDuck</span> <span class=\"keyword\">extends</span> <span class=\"title\">Duck</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScreamDuck</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        quackBehavior = <span class=\"keyword\">new</span> SQuack();</div><div class=\"line\">        flyBehavior = <span class=\"keyword\">new</span> FlyNoWay();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样就实现了一个尖叫鸭。而普通绿头鸭子就是：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MallardDuck</span> <span class=\"keyword\">extends</span> <span class=\"title\">Duck</span></span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MallardDuck</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        quackBehavior = <span class=\"keyword\">new</span> Quack();</div><div class=\"line\">        flyBehavior = <span class=\"keyword\">new</span> FlyWithSwing();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样维护和扩展都容易多了。</p>\n<p>这就是<strong>策略模式</strong>，<br>**</p>\n<h1 id=\"策略模式的定义：\"><a href=\"#策略模式的定义：\" class=\"headerlink\" title=\"策略模式的定义：\"></a><strong>策略模式的定义：</strong></h1><p>**<br>定义了算法簇，分别封装起来，让它们之间可以互相替换。这个模式可以让算法的变化独立于使用算法的客户。</p>\n<h1 id=\"策略模式的结构：\"><a href=\"#策略模式的结构：\" class=\"headerlink\" title=\"策略模式的结构：\"></a><strong>策略模式的结构：</strong></h1><p><img src=\"http://my.csdn.net/uploads/201205/11/1336732187_4598.jpg\" alt=\"策略模式的结构\"></p>\n<p>**</p>\n<h1 id=\"策略模式的组成：\"><a href=\"#策略模式的组成：\" class=\"headerlink\" title=\"策略模式的组成：\"></a><strong>策略模式的组成：</strong></h1><p><strong>环境类(Context)</strong>:用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。<br><strong>抽象策略类(Strategy)</strong>:定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。<br><strong>具体策略类(ConcreteStrategy)</strong>:以Strategy接口实现某具体算法。</p>\n"},{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">编写属于自己的Service(服务)</font>","date":"2017-05-31T13:10:26.000Z","_content":"\n用Apache james搭建自己的邮件服务器，需要运行james解压包中/bin目录下的run.sh来开启邮件服务器的，然而只能在前台开启，开启后就会邮件服务器会一直运行，也就是说这个终端窗口就不能做别的事情了，除非另外开一个终端窗口。怎样解决呢？其实可以用nohup命令让其变为后台服务。比如说我的james放在/usr/local目录下，那么我可以这么做：\n```shell\nnohup sh /usr/local/james/bin/run.sh > RUNNING_REPORT 2>&1 &\n```\nnohup可以让某个程序在后台运行，用&在程序结尾让程序自动运行。中间的> RUNNING_REPORT是将原程序的标准输出重定向输出到RUNNING_REPORT文件中去，2>&1是指把标准错误输出也重定向到标准输出中去，也就是说如果有错误信息，最终也将输出到RUNNING_REPORT文件中。\n\n像邮件服务器这样一个持续运行的服务更像是一个系统服务，所以我们可以把它写成自己的service。使用到的是chkconfig，chkconfig命令可以用来检查、设置系统的各种服务。一个service有启动、停止，查询状态和重启这些基础命令，所以这里有一种通用的写法：\n```shell\n# chkconfig: 2345 90 10\n# description:auto_run\n\n#因为james需要java环境，如果找不到就重定向到一个已知的java环境\nexport JAVA_HOME=${JAVA_HOME:-/usr/java/latest}\nexport JS_HOME=/usr/james\nexport JS_BIN_DIR=$JS_HOME/bin\n#RUNNING_REPORT用来记录程序的标准输出，起到log的作用\nexport JS_PID_FILE=$JS_HOME/RUNNING_REPORT\n\n#启动\nfunction start {\n    if [ -f \"$JS_PID_FILE\" ]; then\n        echo \"James PID file already exists. Skipped start process\"\n        exit 0\n    fi\n\n    echo \"Starting james service...\"\n    cd $JS_BIN_DIR\n    nohup sh run.sh > $JS_PID_FILE 2>&1 &\n    sleep 1\n}\n\n#停止\nfunction stop {\n    if [ -f $JS_PID_FILE ]; then\n        set +e\n        kill -9 `cat $JS_PID_FILE` > /dev/null 2>&1 &\n        rm -f $JS_PID_FILE\n        set -e\n        sleep 1\n    fi\n}\n\n#状态\nfunction status {\n    if [ -f $JS_PID_FILE ]; then\n        echo \"James is running\"\n    else\n        echo \"James is not running\"\n    fi\n}\n\n#重启\nfunction restart {\n    stop\n    start\n}\n\ncase \"$1\" in\n    start)\n    start\n    ;;\n    stop)\n    stop\n    ;;\n    status)\n    status\n    ;;\n    restart)\n    restart\n    ;;\n    *)\n    echo \"Usage: $0 start|stop|status|restart\"\nesac\n```\n这个脚本应该很清晰，文件只需要要无后缀保存就可以了，比如保存为mailServer，然后把它放到/etc/init.d目录下，这样就可以用下面的命令来启动了：\n```shell\nservice NAME start\n```\n其中的NAME就是文件名。\n\n下面来详细讲一下chkconfig命令：\n严格来说chkconfig命令主要用来更新（启动或停止）和查询系统服务的运行级信息。首先要弄明白什么是运行级，在Linux中，运行级别就是操作系统当前正在运行的功能级别。级别可以从0到6，具有不同的功能。这些级别定义在/ect/inittab文件中。这个文件是init程序寻找的主要文件，而最先运行的服务是那些放在/ect/rc.d目录下的文件。\n\n**Linux下的7个运行级别：**\n**0**：系统停机状态，系统默认运行级别不能设置为0，否则不能正常启动，机器关闭。\n**1**：单用户工作状态，root权限，用于系统维护，禁止远程登陆，就像Windows下的安全模式登录。\n**2**：无网络连接的多用户命令行模式\n**3**：有网络连接的多用户命令行模式\n**4**：系统未使用状态，保留一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。\n**5**：带图形界面的多用户模式。\n**6**：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动。运行init 6机器就会重启。\n\n在目录/etc/init.d下有许多服务器脚本程序，一般称为服务(service)\n在/etc/下有7个名为rc[N].d(N为0~6)的目录，对应系统的7个运行级别\nrc[N].d目录下都是一些符号链接文件，这些链接文件都指向init.d目录下的service脚本文件，命名规则为K+nn+服务名或S+nn+服务名，其中nn为两位数字。\n系统会根据指定的运行级别进入对应的rc[N].d目录，并按照文件名顺序检索目录下的链接文件：对于以K开头的文件，系统将终止对应的服务； 对于以S开头的文件，系统将启动对应的服务\n\n上面代码中第一行中的2345就是指运行级别。而之后的90代表Start的优先级，10代表Kill（Stop）的优先级。如果启动优先级配置的太小可能会启动不成功，因为可能它依赖的一些环境（比如网络环境）还没启动，从而导致启动失败。\n\nChkconfig有五个很明确的功能：为管理增加一个新的功能、删除一个功能、列出当前服务的启动信息、改变一个服务的启动信息和检测特殊服务的启动状态。\n对应的命令行;\n```shell\nchkconfig --add name\nchkconfig --del name\nchkconfig --list [name]\nchkconfig [--level levels] name <on|off|reset>\nchkconfig [--level levels] name\n```\n将需要自动启动的脚本/etc/init.d目录下，然后使用如下命令\n```shell\nchkconfig --add filename\n```\n这样就可以使服务自动注册开机启动和关机关闭。实质就是在rc0.d-rc6.d目录下生成一些文件连接，这些连接连接到/etc/init.d目录下指定文件的shell脚本。\n\n所以如果我们想把上面写过的mail服务设置成开机自启，就需要先把它放到/etc/init.d目录下，然后赋予它可执行的权限：\n```shell\nchmod +x mailserver\n```\n然后执行\n```shell\nchkconfig --add mailserver\n```\n命令，或者直接在rc0.d-rc6.d目录下分别创建文件连接:\nln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc2.d/S99mailserver\nln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc3.d/S99mailserver\nln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc5.d/S99mailserver\nln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc0.d/K01mailserver\nln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc6.d/K01mailserver\n这样系统在启动的时候，就会运行auto_run 并加上start参数，等同于执行命令mailserver start。\n在系统关闭的时候，就会运行auto_run，并加上stop参数，等同于运行命令mailserver stop。","source":"_posts/编写属于自己的Service（服务）.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">编写属于自己的Service(服务)</font>\ndate: 2017-05-31 21:10:26\ncategories: Linux\ntags: [Linux,Service,后台服务,Chkconfig]\n---\n\n用Apache james搭建自己的邮件服务器，需要运行james解压包中/bin目录下的run.sh来开启邮件服务器的，然而只能在前台开启，开启后就会邮件服务器会一直运行，也就是说这个终端窗口就不能做别的事情了，除非另外开一个终端窗口。怎样解决呢？其实可以用nohup命令让其变为后台服务。比如说我的james放在/usr/local目录下，那么我可以这么做：\n```shell\nnohup sh /usr/local/james/bin/run.sh > RUNNING_REPORT 2>&1 &\n```\nnohup可以让某个程序在后台运行，用&在程序结尾让程序自动运行。中间的> RUNNING_REPORT是将原程序的标准输出重定向输出到RUNNING_REPORT文件中去，2>&1是指把标准错误输出也重定向到标准输出中去，也就是说如果有错误信息，最终也将输出到RUNNING_REPORT文件中。\n\n像邮件服务器这样一个持续运行的服务更像是一个系统服务，所以我们可以把它写成自己的service。使用到的是chkconfig，chkconfig命令可以用来检查、设置系统的各种服务。一个service有启动、停止，查询状态和重启这些基础命令，所以这里有一种通用的写法：\n```shell\n# chkconfig: 2345 90 10\n# description:auto_run\n\n#因为james需要java环境，如果找不到就重定向到一个已知的java环境\nexport JAVA_HOME=${JAVA_HOME:-/usr/java/latest}\nexport JS_HOME=/usr/james\nexport JS_BIN_DIR=$JS_HOME/bin\n#RUNNING_REPORT用来记录程序的标准输出，起到log的作用\nexport JS_PID_FILE=$JS_HOME/RUNNING_REPORT\n\n#启动\nfunction start {\n    if [ -f \"$JS_PID_FILE\" ]; then\n        echo \"James PID file already exists. Skipped start process\"\n        exit 0\n    fi\n\n    echo \"Starting james service...\"\n    cd $JS_BIN_DIR\n    nohup sh run.sh > $JS_PID_FILE 2>&1 &\n    sleep 1\n}\n\n#停止\nfunction stop {\n    if [ -f $JS_PID_FILE ]; then\n        set +e\n        kill -9 `cat $JS_PID_FILE` > /dev/null 2>&1 &\n        rm -f $JS_PID_FILE\n        set -e\n        sleep 1\n    fi\n}\n\n#状态\nfunction status {\n    if [ -f $JS_PID_FILE ]; then\n        echo \"James is running\"\n    else\n        echo \"James is not running\"\n    fi\n}\n\n#重启\nfunction restart {\n    stop\n    start\n}\n\ncase \"$1\" in\n    start)\n    start\n    ;;\n    stop)\n    stop\n    ;;\n    status)\n    status\n    ;;\n    restart)\n    restart\n    ;;\n    *)\n    echo \"Usage: $0 start|stop|status|restart\"\nesac\n```\n这个脚本应该很清晰，文件只需要要无后缀保存就可以了，比如保存为mailServer，然后把它放到/etc/init.d目录下，这样就可以用下面的命令来启动了：\n```shell\nservice NAME start\n```\n其中的NAME就是文件名。\n\n下面来详细讲一下chkconfig命令：\n严格来说chkconfig命令主要用来更新（启动或停止）和查询系统服务的运行级信息。首先要弄明白什么是运行级，在Linux中，运行级别就是操作系统当前正在运行的功能级别。级别可以从0到6，具有不同的功能。这些级别定义在/ect/inittab文件中。这个文件是init程序寻找的主要文件，而最先运行的服务是那些放在/ect/rc.d目录下的文件。\n\n**Linux下的7个运行级别：**\n**0**：系统停机状态，系统默认运行级别不能设置为0，否则不能正常启动，机器关闭。\n**1**：单用户工作状态，root权限，用于系统维护，禁止远程登陆，就像Windows下的安全模式登录。\n**2**：无网络连接的多用户命令行模式\n**3**：有网络连接的多用户命令行模式\n**4**：系统未使用状态，保留一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。\n**5**：带图形界面的多用户模式。\n**6**：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动。运行init 6机器就会重启。\n\n在目录/etc/init.d下有许多服务器脚本程序，一般称为服务(service)\n在/etc/下有7个名为rc[N].d(N为0~6)的目录，对应系统的7个运行级别\nrc[N].d目录下都是一些符号链接文件，这些链接文件都指向init.d目录下的service脚本文件，命名规则为K+nn+服务名或S+nn+服务名，其中nn为两位数字。\n系统会根据指定的运行级别进入对应的rc[N].d目录，并按照文件名顺序检索目录下的链接文件：对于以K开头的文件，系统将终止对应的服务； 对于以S开头的文件，系统将启动对应的服务\n\n上面代码中第一行中的2345就是指运行级别。而之后的90代表Start的优先级，10代表Kill（Stop）的优先级。如果启动优先级配置的太小可能会启动不成功，因为可能它依赖的一些环境（比如网络环境）还没启动，从而导致启动失败。\n\nChkconfig有五个很明确的功能：为管理增加一个新的功能、删除一个功能、列出当前服务的启动信息、改变一个服务的启动信息和检测特殊服务的启动状态。\n对应的命令行;\n```shell\nchkconfig --add name\nchkconfig --del name\nchkconfig --list [name]\nchkconfig [--level levels] name <on|off|reset>\nchkconfig [--level levels] name\n```\n将需要自动启动的脚本/etc/init.d目录下，然后使用如下命令\n```shell\nchkconfig --add filename\n```\n这样就可以使服务自动注册开机启动和关机关闭。实质就是在rc0.d-rc6.d目录下生成一些文件连接，这些连接连接到/etc/init.d目录下指定文件的shell脚本。\n\n所以如果我们想把上面写过的mail服务设置成开机自启，就需要先把它放到/etc/init.d目录下，然后赋予它可执行的权限：\n```shell\nchmod +x mailserver\n```\n然后执行\n```shell\nchkconfig --add mailserver\n```\n命令，或者直接在rc0.d-rc6.d目录下分别创建文件连接:\nln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc2.d/S99mailserver\nln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc3.d/S99mailserver\nln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc5.d/S99mailserver\nln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc0.d/K01mailserver\nln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc6.d/K01mailserver\n这样系统在启动的时候，就会运行auto_run 并加上start参数，等同于执行命令mailserver start。\n在系统关闭的时候，就会运行auto_run，并加上stop参数，等同于运行命令mailserver stop。","slug":"编写属于自己的Service（服务）","published":1,"updated":"2017-07-12T01:47:15.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hso0h000wasvlahjz9snw","content":"<p>用Apache james搭建自己的邮件服务器，需要运行james解压包中/bin目录下的run.sh来开启邮件服务器的，然而只能在前台开启，开启后就会邮件服务器会一直运行，也就是说这个终端窗口就不能做别的事情了，除非另外开一个终端窗口。怎样解决呢？其实可以用nohup命令让其变为后台服务。比如说我的james放在/usr/local目录下，那么我可以这么做：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup sh /usr/local/james/bin/run.sh &gt; RUNNING_REPORT 2&gt;&amp;1 &amp;</div></pre></td></tr></table></figure></p>\n<p>nohup可以让某个程序在后台运行，用&amp;在程序结尾让程序自动运行。中间的&gt; RUNNING_REPORT是将原程序的标准输出重定向输出到RUNNING_REPORT文件中去，2&gt;&amp;1是指把标准错误输出也重定向到标准输出中去，也就是说如果有错误信息，最终也将输出到RUNNING_REPORT文件中。</p>\n<p>像邮件服务器这样一个持续运行的服务更像是一个系统服务，所以我们可以把它写成自己的service。使用到的是chkconfig，chkconfig命令可以用来检查、设置系统的各种服务。一个service有启动、停止，查询状态和重启这些基础命令，所以这里有一种通用的写法：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span> chkconfig: 2345 90 10</div><div class=\"line\"><span class=\"meta\">#</span> description:auto_run</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#因为james需要java环境，如果找不到就重定向到一个已知的java环境</div><div class=\"line\">export JAVA_HOME=$&#123;JAVA_HOME:-/usr/java/latest&#125;</div><div class=\"line\">export JS_HOME=/usr/james</div><div class=\"line\">export JS_BIN_DIR=$JS_HOME/bin</div><div class=\"line\"><span class=\"meta\">#</span>RUNNING_REPORT用来记录程序的标准输出，起到log的作用</div><div class=\"line\">export JS_PID_FILE=$JS_HOME/RUNNING_REPORT</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#启动</div><div class=\"line\">function start &#123;</div><div class=\"line\">    if [ -f \"$JS_PID_FILE\" ]; then</div><div class=\"line\">        echo \"James PID file already exists. Skipped start process\"</div><div class=\"line\">        exit 0</div><div class=\"line\">    fi</div><div class=\"line\"></div><div class=\"line\">    echo \"Starting james service...\"</div><div class=\"line\">    cd $JS_BIN_DIR</div><div class=\"line\">    nohup sh run.sh &gt; $JS_PID_FILE 2&gt;&amp;1 &amp;</div><div class=\"line\">    sleep 1</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#停止</div><div class=\"line\">function stop &#123;</div><div class=\"line\">    if [ -f $JS_PID_FILE ]; then</div><div class=\"line\">        set +e</div><div class=\"line\">        kill -9 `cat $JS_PID_FILE` &gt; /dev/null 2&gt;&amp;1 &amp;</div><div class=\"line\">        rm -f $JS_PID_FILE</div><div class=\"line\">        set -e</div><div class=\"line\">        sleep 1</div><div class=\"line\">    fi</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#状态</div><div class=\"line\">function status &#123;</div><div class=\"line\">    if [ -f $JS_PID_FILE ]; then</div><div class=\"line\">        echo \"James is running\"</div><div class=\"line\">    else</div><div class=\"line\">        echo \"James is not running\"</div><div class=\"line\">    fi</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#重启</div><div class=\"line\">function restart &#123;</div><div class=\"line\">    stop</div><div class=\"line\">    start</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">case \"$1\" in</div><div class=\"line\">    start)</div><div class=\"line\">    start</div><div class=\"line\">    ;;</div><div class=\"line\">    stop)</div><div class=\"line\">    stop</div><div class=\"line\">    ;;</div><div class=\"line\">    status)</div><div class=\"line\">    status</div><div class=\"line\">    ;;</div><div class=\"line\">    restart)</div><div class=\"line\">    restart</div><div class=\"line\">    ;;</div><div class=\"line\">    *)</div><div class=\"line\">    echo \"Usage: $0 start|stop|status|restart\"</div><div class=\"line\">esac</div></pre></td></tr></table></figure></p>\n<p>这个脚本应该很清晰，文件只需要要无后缀保存就可以了，比如保存为mailServer，然后把它放到/etc/init.d目录下，这样就可以用下面的命令来启动了：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service NAME start</div></pre></td></tr></table></figure></p>\n<p>其中的NAME就是文件名。</p>\n<p>下面来详细讲一下chkconfig命令：<br>严格来说chkconfig命令主要用来更新（启动或停止）和查询系统服务的运行级信息。首先要弄明白什么是运行级，在Linux中，运行级别就是操作系统当前正在运行的功能级别。级别可以从0到6，具有不同的功能。这些级别定义在/ect/inittab文件中。这个文件是init程序寻找的主要文件，而最先运行的服务是那些放在/ect/rc.d目录下的文件。</p>\n<p><strong>Linux下的7个运行级别：</strong><br><strong>0</strong>：系统停机状态，系统默认运行级别不能设置为0，否则不能正常启动，机器关闭。<br><strong>1</strong>：单用户工作状态，root权限，用于系统维护，禁止远程登陆，就像Windows下的安全模式登录。<br><strong>2</strong>：无网络连接的多用户命令行模式<br><strong>3</strong>：有网络连接的多用户命令行模式<br><strong>4</strong>：系统未使用状态，保留一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。<br><strong>5</strong>：带图形界面的多用户模式。<br><strong>6</strong>：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动。运行init 6机器就会重启。</p>\n<p>在目录/etc/init.d下有许多服务器脚本程序，一般称为服务(service)<br>在/etc/下有7个名为rc[N].d(N为0~6)的目录，对应系统的7个运行级别<br>rc[N].d目录下都是一些符号链接文件，这些链接文件都指向init.d目录下的service脚本文件，命名规则为K+nn+服务名或S+nn+服务名，其中nn为两位数字。<br>系统会根据指定的运行级别进入对应的rc[N].d目录，并按照文件名顺序检索目录下的链接文件：对于以K开头的文件，系统将终止对应的服务； 对于以S开头的文件，系统将启动对应的服务</p>\n<p>上面代码中第一行中的2345就是指运行级别。而之后的90代表Start的优先级，10代表Kill（Stop）的优先级。如果启动优先级配置的太小可能会启动不成功，因为可能它依赖的一些环境（比如网络环境）还没启动，从而导致启动失败。</p>\n<p>Chkconfig有五个很明确的功能：为管理增加一个新的功能、删除一个功能、列出当前服务的启动信息、改变一个服务的启动信息和检测特殊服务的启动状态。<br>对应的命令行;<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">chkconfig --add name</div><div class=\"line\">chkconfig --del name</div><div class=\"line\">chkconfig --list [name]</div><div class=\"line\">chkconfig [--level levels] name &lt;on|off|reset&gt;</div><div class=\"line\">chkconfig [--level levels] name</div></pre></td></tr></table></figure></p>\n<p>将需要自动启动的脚本/etc/init.d目录下，然后使用如下命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chkconfig --add filename</div></pre></td></tr></table></figure></p>\n<p>这样就可以使服务自动注册开机启动和关机关闭。实质就是在rc0.d-rc6.d目录下生成一些文件连接，这些连接连接到/etc/init.d目录下指定文件的shell脚本。</p>\n<p>所以如果我们想把上面写过的mail服务设置成开机自启，就需要先把它放到/etc/init.d目录下，然后赋予它可执行的权限：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x mailserver</div></pre></td></tr></table></figure></p>\n<p>然后执行<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chkconfig --add mailserver</div></pre></td></tr></table></figure></p>\n<p>命令，或者直接在rc0.d-rc6.d目录下分别创建文件连接:<br>ln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc2.d/S99mailserver<br>ln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc3.d/S99mailserver<br>ln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc5.d/S99mailserver<br>ln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc0.d/K01mailserver<br>ln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc6.d/K01mailserver<br>这样系统在启动的时候，就会运行auto_run 并加上start参数，等同于执行命令mailserver start。<br>在系统关闭的时候，就会运行auto_run，并加上stop参数，等同于运行命令mailserver stop。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>用Apache james搭建自己的邮件服务器，需要运行james解压包中/bin目录下的run.sh来开启邮件服务器的，然而只能在前台开启，开启后就会邮件服务器会一直运行，也就是说这个终端窗口就不能做别的事情了，除非另外开一个终端窗口。怎样解决呢？其实可以用nohup命令让其变为后台服务。比如说我的james放在/usr/local目录下，那么我可以这么做：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nohup sh /usr/local/james/bin/run.sh &gt; RUNNING_REPORT 2&gt;&amp;1 &amp;</div></pre></td></tr></table></figure></p>\n<p>nohup可以让某个程序在后台运行，用&amp;在程序结尾让程序自动运行。中间的&gt; RUNNING_REPORT是将原程序的标准输出重定向输出到RUNNING_REPORT文件中去，2&gt;&amp;1是指把标准错误输出也重定向到标准输出中去，也就是说如果有错误信息，最终也将输出到RUNNING_REPORT文件中。</p>\n<p>像邮件服务器这样一个持续运行的服务更像是一个系统服务，所以我们可以把它写成自己的service。使用到的是chkconfig，chkconfig命令可以用来检查、设置系统的各种服务。一个service有启动、停止，查询状态和重启这些基础命令，所以这里有一种通用的写法：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#</span> chkconfig: 2345 90 10</div><div class=\"line\"><span class=\"meta\">#</span> description:auto_run</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#因为james需要java环境，如果找不到就重定向到一个已知的java环境</div><div class=\"line\">export JAVA_HOME=$&#123;JAVA_HOME:-/usr/java/latest&#125;</div><div class=\"line\">export JS_HOME=/usr/james</div><div class=\"line\">export JS_BIN_DIR=$JS_HOME/bin</div><div class=\"line\"><span class=\"meta\">#</span>RUNNING_REPORT用来记录程序的标准输出，起到log的作用</div><div class=\"line\">export JS_PID_FILE=$JS_HOME/RUNNING_REPORT</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#启动</div><div class=\"line\">function start &#123;</div><div class=\"line\">    if [ -f \"$JS_PID_FILE\" ]; then</div><div class=\"line\">        echo \"James PID file already exists. Skipped start process\"</div><div class=\"line\">        exit 0</div><div class=\"line\">    fi</div><div class=\"line\"></div><div class=\"line\">    echo \"Starting james service...\"</div><div class=\"line\">    cd $JS_BIN_DIR</div><div class=\"line\">    nohup sh run.sh &gt; $JS_PID_FILE 2&gt;&amp;1 &amp;</div><div class=\"line\">    sleep 1</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#停止</div><div class=\"line\">function stop &#123;</div><div class=\"line\">    if [ -f $JS_PID_FILE ]; then</div><div class=\"line\">        set +e</div><div class=\"line\">        kill -9 `cat $JS_PID_FILE` &gt; /dev/null 2&gt;&amp;1 &amp;</div><div class=\"line\">        rm -f $JS_PID_FILE</div><div class=\"line\">        set -e</div><div class=\"line\">        sleep 1</div><div class=\"line\">    fi</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#状态</div><div class=\"line\">function status &#123;</div><div class=\"line\">    if [ -f $JS_PID_FILE ]; then</div><div class=\"line\">        echo \"James is running\"</div><div class=\"line\">    else</div><div class=\"line\">        echo \"James is not running\"</div><div class=\"line\">    fi</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">#重启</div><div class=\"line\">function restart &#123;</div><div class=\"line\">    stop</div><div class=\"line\">    start</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">case \"$1\" in</div><div class=\"line\">    start)</div><div class=\"line\">    start</div><div class=\"line\">    ;;</div><div class=\"line\">    stop)</div><div class=\"line\">    stop</div><div class=\"line\">    ;;</div><div class=\"line\">    status)</div><div class=\"line\">    status</div><div class=\"line\">    ;;</div><div class=\"line\">    restart)</div><div class=\"line\">    restart</div><div class=\"line\">    ;;</div><div class=\"line\">    *)</div><div class=\"line\">    echo \"Usage: $0 start|stop|status|restart\"</div><div class=\"line\">esac</div></pre></td></tr></table></figure></p>\n<p>这个脚本应该很清晰，文件只需要要无后缀保存就可以了，比如保存为mailServer，然后把它放到/etc/init.d目录下，这样就可以用下面的命令来启动了：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service NAME start</div></pre></td></tr></table></figure></p>\n<p>其中的NAME就是文件名。</p>\n<p>下面来详细讲一下chkconfig命令：<br>严格来说chkconfig命令主要用来更新（启动或停止）和查询系统服务的运行级信息。首先要弄明白什么是运行级，在Linux中，运行级别就是操作系统当前正在运行的功能级别。级别可以从0到6，具有不同的功能。这些级别定义在/ect/inittab文件中。这个文件是init程序寻找的主要文件，而最先运行的服务是那些放在/ect/rc.d目录下的文件。</p>\n<p><strong>Linux下的7个运行级别：</strong><br><strong>0</strong>：系统停机状态，系统默认运行级别不能设置为0，否则不能正常启动，机器关闭。<br><strong>1</strong>：单用户工作状态，root权限，用于系统维护，禁止远程登陆，就像Windows下的安全模式登录。<br><strong>2</strong>：无网络连接的多用户命令行模式<br><strong>3</strong>：有网络连接的多用户命令行模式<br><strong>4</strong>：系统未使用状态，保留一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。<br><strong>5</strong>：带图形界面的多用户模式。<br><strong>6</strong>：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动。运行init 6机器就会重启。</p>\n<p>在目录/etc/init.d下有许多服务器脚本程序，一般称为服务(service)<br>在/etc/下有7个名为rc[N].d(N为0~6)的目录，对应系统的7个运行级别<br>rc[N].d目录下都是一些符号链接文件，这些链接文件都指向init.d目录下的service脚本文件，命名规则为K+nn+服务名或S+nn+服务名，其中nn为两位数字。<br>系统会根据指定的运行级别进入对应的rc[N].d目录，并按照文件名顺序检索目录下的链接文件：对于以K开头的文件，系统将终止对应的服务； 对于以S开头的文件，系统将启动对应的服务</p>\n<p>上面代码中第一行中的2345就是指运行级别。而之后的90代表Start的优先级，10代表Kill（Stop）的优先级。如果启动优先级配置的太小可能会启动不成功，因为可能它依赖的一些环境（比如网络环境）还没启动，从而导致启动失败。</p>\n<p>Chkconfig有五个很明确的功能：为管理增加一个新的功能、删除一个功能、列出当前服务的启动信息、改变一个服务的启动信息和检测特殊服务的启动状态。<br>对应的命令行;<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">chkconfig --add name</div><div class=\"line\">chkconfig --del name</div><div class=\"line\">chkconfig --list [name]</div><div class=\"line\">chkconfig [--level levels] name &lt;on|off|reset&gt;</div><div class=\"line\">chkconfig [--level levels] name</div></pre></td></tr></table></figure></p>\n<p>将需要自动启动的脚本/etc/init.d目录下，然后使用如下命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chkconfig --add filename</div></pre></td></tr></table></figure></p>\n<p>这样就可以使服务自动注册开机启动和关机关闭。实质就是在rc0.d-rc6.d目录下生成一些文件连接，这些连接连接到/etc/init.d目录下指定文件的shell脚本。</p>\n<p>所以如果我们想把上面写过的mail服务设置成开机自启，就需要先把它放到/etc/init.d目录下，然后赋予它可执行的权限：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x mailserver</div></pre></td></tr></table></figure></p>\n<p>然后执行<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chkconfig --add mailserver</div></pre></td></tr></table></figure></p>\n<p>命令，或者直接在rc0.d-rc6.d目录下分别创建文件连接:<br>ln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc2.d/S99mailserver<br>ln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc3.d/S99mailserver<br>ln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc5.d/S99mailserver<br>ln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc0.d/K01mailserver<br>ln -s /etc/rc.d/init.d/auto_run /etc/rc.d/rc6.d/K01mailserver<br>这样系统在启动的时候，就会运行auto_run 并加上start参数，等同于执行命令mailserver start。<br>在系统关闭的时候，就会运行auto_run，并加上stop参数，等同于运行命令mailserver stop。</p>\n"},{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">阻塞队列DealayQueue</font>","date":"2017-06-13T01:42:23.000Z","_content":"\n阻塞队列\n===========\n阻塞队列（BlockingQueue）是那些支持持阻塞的插入和移除的队列。\n1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。\n2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。\n\n阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。\n\n|方法/处理方式|抛出异常|返回特殊值|一直阻塞|超时退出|\n|:------------|--------|----------|--------|--------|\n|插入方法|add(e)|offer(e)|put(e)|ofer(e,time,unit)|\n|移除方法|remove()|poll()|take()|poll(time,unit)|\n|检查方法|element()|peek()|不可用|不可用|\n\n·抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（\"Queuefull\"）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。\n·返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。\n·一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。\n·超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。\n\n**注意:**如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true。\n\n**JDK 7中的阻塞队列：**\n\n- ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。\n- LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。\n- PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。\n- DelayQueue：一个使用优先级队列实现的无界阻塞队列。\n- SynchronousQueue：一个不存储元素的阻塞队列。\n- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。\n- LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。\n\nDelayQUeue\n===============\nDelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。DelayQueue非常有用，可以将DelayQueue运用在以下应用场景：\n\n- 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。\n- 定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。\n\nDelayed一种混合风格的接口，用来标记那些应该在给定延迟时间之后执行的对象。此接口的实现必须定义一个 compareTo方法，该方法提供与此接口的getDelay方法一致的排序。\n\n使用DelayQueue\n--------------\n\n**一、实现Delayed接口：**\nDelayQueue队列的元素必须实现Delayed接口。我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类的实现,首先，在对象创建的时候，初始化基本数据。使用time记录当前对象延迟到什么时候可以使用，使用sequenceNumber来标识元素在队列中的先后顺序。代码如下：\n```java\nprivate static final AtomicLong sequencer = new AtomicLong(0);\nScheduled FutureTask(Runnable r, V result, long ns, long period) {\nScheduled FutureTask(Runnable r, V result, long ns, long period) {\n            super(r, result);\n            this.time = ns;\n            this.period = period;\n            this.sequence Number = sequencer.getAndIncrement();\n}\n```\n第二步：实现getDelay方法，该方法返回当前元素还需要延时多长时间，单位是纳秒，代码如下。\n```java\npublic long getDelay(TimeUnit unit) {\n            return unit.convert(time - now(), Time Unit.NANOSECONDS);\n        }\n```\n通过构造函数可以看出延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为实现getDelay()方法时可以指定任意单位，一旦以秒或分作为单位，而延时时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。\n第三步：实现compareTo方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。实现代码如下:\n```java\npublic int compareTo(Delayed other) {\n            if (other == this)// compare zero ONLY if same object\n                return 0;\n            if (other instanceof Scheduled FutureTask) {\n                Scheduled FutureTask<> x = (Scheduled FutureTask<>)other;\n                long diff = time - x.time;\n                if (diff < 0)\n                    return -1;\n                else if (diff > 0)\n                    return 1;\n                else if (sequence Number < x.sequence Number)\n                    return -1;\n                else\n                    return 1;\n            }\n            long d = (getDelay(Time Unit.NANOSECONDS) -\n                        other.getDelay(Time Unit.NANOSECONDS));\n            return (d == 0)  0 : ((d < 0)  -1 : 1);\n        }\n```\n**二、实现延时阻塞队列**\n延时阻塞队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。\n```java\nlong delay = first.getDelay(Time Unit.NANOSECONDS);\nif (delay <= 0)\n    return q.poll();\nelse if (leader != null)\n        available.await();\nelse {\n    Thread thisThread = Thread.currentThread();\n    leader = thisThread;\n        try {\n                available.awaitNanos(delay);\n            } finally {\n                if (leader == thisThread)\n                leader = null;\n            }\n    }\n```\n代码中的变量leader是一个等待获取队列头部元素的线程。如果leader不等于空，表示已经有线程在等待获取队列的头元素。所以，使用await()方法让当前线程等待信号。如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。\n\n下面实现两种具体场景：\n--------------\n1、模拟一个考试的日子，考试时间为120分钟，30分钟后才可交卷，当时间到了，或学生都交完卷了考试结束。这个场景中几个点需要注意：\n\n- 考试时间为120分钟，30分钟后才可交卷，初始化考生完成试卷时间最小应为30分钟\n- 对于能够在120分钟内交卷的考生，如何实现这些考生交卷\n- 对于120分钟内没有完成考试的考生，在120分钟考试时间到后需要让他们强制交卷\n- 在所有的考生都交完卷后，需要将控制线程关闭\n\n实现思想：用DelayQueue存储考生（Student类），每一个考生都有自己的名字和完成试卷的时间，Teacher线程对DelayQueue进行监控，收取完成试卷小于120分钟的学生的试卷。当考试时间120分钟到时，先关闭Teacher线程，然后强制DelayQueue中还存在的考生交卷。每一个考生交卷都会进行一次countDownLatch.countDown()，当countDownLatch.await()不再阻塞说明所有考生都交完卷了，而后结束考试。\n\nStudent类实现Runnable和Delayed接口，之后就可以存入DelayQueue中去了：\n```java\nclass Student implements Runnable,Delayed{\n\n    private String name;\n    private long workTime;\n    private long submitTime;\n    private boolean isForce = false;\n    private CountDownLatch countDownLatch;\n    \n    public Student(){}\n    \n    public Student(String name,long workTime,CountDownLatch countDownLatch){\n        this.name = name;\n        this.workTime = workTime;\n        this.submitTime = TimeUnit.NANOSECONDS.convert(workTime, \n                                        TimeUnit.NANOSECONDS)+System.nanoTime();\n        this.countDownLatch = countDownLatch;\n    }\n    \n    @Override\n    public int compareTo(Delayed o) {\n        // TODO Auto-generated method stub\n        if(o == null || ! (o instanceof Student)) return 1;\n        if(o == this) return 0; \n        Student s = (Student)o;\n        if (this.workTime > s.workTime) {\n            return 1;\n        }else if (this.workTime == s.workTime) {\n            return 0;\n        }else {\n            return -1;\n        }\n    }\n\n    @Override\n    public long getDelay(TimeUnit unit) {\n        // TODO Auto-generated method stub\n        return unit.convert(submitTime - System.nanoTime(),  TimeUnit.NANOSECONDS);\n    }\n\n    @Override\n    public void run() {\n        // TODO Auto-generated method stub\n        if (isForce) {\n            System.out.println(name + \" 交卷, 希望用时\" + workTime + \"分钟\"+\" ,实际用时 120分钟\" );\n        }else {\n            System.out.println(name + \" 交卷, 希望用时\" + workTime + \n                                                \"分钟\"+\" ,实际用时 \"+workTime +\" 分钟\");  \n        }\n        countDownLatch.countDown();\n    }\n\n    public boolean isForce() {\n        return isForce;\n    }\n\n    public void setForce(boolean isForce) {\n        this.isForce = isForce;\n    }\n    \n}\n\n```\nTeacher类用来收取DelayQueue中时间到了的学生的试卷。也就是说一个学生如果用时大于30分钟小于120分钟，那么当时间到了的时候Teacheer类就会从QelayQueue中取出这个学生。\n```java\nclass Teacher implements Runnable{\n\n    private DelayQueue<Student> students;\n    public Teacher(DelayQueue<Student> students){\n        this.students = students;\n    }\n    \n    @Override\n    public void run() {\n        // TODO Auto-generated method stub\n        try {\n            System.out.println(\" test start\");\n            while(!Thread.interrupted()){\n                students.take().run();\n            }\n        } catch (Exception e) {\n            // TODO: handle exception\n            e.printStackTrace();\n        }\n    }\n    \n}\n```\nEndExam类是强制交卷类，当考生用时超过120分钟就会强制从DelayQueue中取出来。\n```java\nclass EndExam extends Student{\n\n    private DelayQueue<Student> students;\n    private CountDownLatch countDownLatch;\n    private Thread teacherThread;\n    \n    public EndExam(DelayQueue<Student> students, long workTime, \n                        CountDownLatch countDownLatch,Thread teacherThread) {\n        super(\"强制收卷\", workTime,countDownLatch);\n        this.students = students;\n        this.countDownLatch = countDownLatch;\n        this.teacherThread = teacherThread;\n    }\n    \n    @Override\n    public void run() {\n        // TODO Auto-generated method stub\n        \n        teacherThread.interrupt();\n        Student tmpStudent;\n        for (Iterator<Student> iterator2 = students.iterator(); iterator2.hasNext();) {\n            tmpStudent = iterator2.next();\n            tmpStudent.setForce(true);\n            tmpStudent.run();\n        }\n        countDownLatch.countDown();\n    }\n    \n}\n```\nExam是考试主类,包含一个main方法：\n```java\npublic class Exam {\n\n    public static void main(String[] args) throws InterruptedException {\n        // TODO Auto-generated method stub\n        int studentNumber = 20;\n        CountDownLatch countDownLatch = new CountDownLatch(studentNumber+1);\n        DelayQueue< Student> students = new DelayQueue<Student>();\n        Random random = new Random();\n        for (int i = 0; i < studentNumber; i++) {\n            students.put(new Student(\"student\"+(i+1), 30+random.nextInt(120),countDownLatch));\n        }\n        Thread teacherThread =new Thread(new Teacher(students)); \n        students.put(new EndExam(students, 120,countDownLatch,teacherThread));\n        teacherThread.start();\n        countDownLatch.await();\n        System.out.println(\" 考试时间到，全部交卷！\");  \n    }\n\n}\n```\n\n**2、具有过期时间的缓存**\n向缓存添加内容时，给每一个key设定过期时间，系统自动将超过过期时间的key清除。这个场景中几个点需要注意：\n\n- 当向缓存中添加key-value对时，如果这个key在缓存中存在并且还没有过期，需要用这个key对应的新过期时间。\n- 为了能够让DelayQueue将其已保存的key删除，需要重写实现Delayed接口可添加到DelayQueue的DelayedItem的hashCode函数和equals函数。\n- 当缓存关闭，监控程序也应关闭，因而监控线程应当用守护线程。\n\nCache主类：\n```java\npublic class Cache<K, V> {\n\n    public ConcurrentHashMap<K, V> map = new ConcurrentHashMap<K, V>();\n    public DelayQueue<DelayedItem<K>> queue = new DelayQueue<DelayedItem<K>>();\n    \n    public void put(K k,V v,long liveTime){\n        V v2 = map.put(k, v);\n        DelayedItem<K> tmpItem = new DelayedItem<K>(k, liveTime);\n        if (v2 != null) {\n            queue.remove(tmpItem);\n        }\n        queue.put(tmpItem);\n    }\n    \n    public Cache(){\n        Thread t = new Thread(){\n            @Override\n            public void run(){\n                dameonCheckOverdueKey();\n            }\n        };\n        t.setDaemon(true);\n        t.start();\n    }\n    \n    public void dameonCheckOverdueKey(){\n        while (true) {\n            DelayedItem<K> delayedItem = queue.poll();\n            if (delayedItem != null) {\n                map.remove(delayedItem.getT());\n                System.out.println(System.nanoTime()+\" remove \"+\n                                delayedItem.getT() +\" from cache\");\n            }\n            try {\n                Thread.sleep(300);\n            } catch (Exception e) {\n                // TODO: handle exception\n            }\n        }\n    }\n    \n    public static void main(String[] args) throws InterruptedException {\n        Random random = new Random();\n        int cacheNumber = 10;\n        int liveTime = 0;\n        Cache<String, Integer> cache = new Cache<String, Integer>();\n        \n        for (int i = 0; i < cacheNumber; i++) {\n            liveTime = random.nextInt(3000);\n            System.out.println(i+\"  \"+liveTime);\n            cache.put(i+\"\", i, random.nextInt(liveTime));\n            if (random.nextInt(cacheNumber) > 7) {\n                liveTime = random.nextInt(3000);\n                System.out.println(i+\"  \"+liveTime);\n                cache.put(i+\"\", i, random.nextInt(liveTime));\n            }\n        }\n\n        Thread.sleep(3000);\n        System.out.println();\n    }\n\n}\n```\nDelayedItem类：\n```java\nclass DelayedItem<T> implements Delayed{\n\n    private T t;\n    private long liveTime ;\n    private long removeTime;\n    \n    public DelayedItem(T t,long liveTime){\n        this.setT(t);\n        this.liveTime = liveTime;\n        this.removeTime = TimeUnit.NANOSECONDS.convert(liveTime, TimeUnit.NANOSECONDS) + \n                                        System.nanoTime();\n    }\n    \n    @Override\n    public int compareTo(Delayed o) {\n        if (o == null) return 1;\n        if (o == this) return  0;\n        if (o instanceof DelayedItem){\n            DelayedItem<T> tmpDelayedItem = (DelayedItem<T>)o;\n            if (liveTime > tmpDelayedItem.liveTime ) {\n                return 1;\n            }else if (liveTime == tmpDelayedItem.liveTime) {\n                return 0;\n            }else {\n                return -1;\n            }\n        }\n        long diff = getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS);\n        return diff > 0 ? 1:diff == 0? 0:-1;\n    }\n\n    @Override\n    public long getDelay(TimeUnit unit) {\n        return unit.convert(removeTime - System.nanoTime(), unit);\n    }\n\n    public T getT() {\n        return t;\n    }\n\n    public void setT(T t) {\n        this.t = t;\n    }\n    @Override\n    public int hashCode(){\n        return t.hashCode();\n    }\n    \n    @Override\n    public boolean equals(Object object){\n        if (object instanceof DelayedItem) {\n            return object.hashCode() == hashCode() ?true:false;\n        }\n        return false;\n    }\n    \n}\n```\n\n","source":"_posts/阻塞队列DealayQueue.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">阻塞队列DealayQueue</font>\ndate: 2017-06-13 09:42:23\ncategories: java多线程\ntags: [java,多线程,阻塞队列,DelayQUeue]\n---\n\n阻塞队列\n===========\n阻塞队列（BlockingQueue）是那些支持持阻塞的插入和移除的队列。\n1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。\n2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。\n\n阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。\n\n|方法/处理方式|抛出异常|返回特殊值|一直阻塞|超时退出|\n|:------------|--------|----------|--------|--------|\n|插入方法|add(e)|offer(e)|put(e)|ofer(e,time,unit)|\n|移除方法|remove()|poll()|take()|poll(time,unit)|\n|检查方法|element()|peek()|不可用|不可用|\n\n·抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（\"Queuefull\"）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。\n·返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。\n·一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。\n·超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。\n\n**注意:**如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true。\n\n**JDK 7中的阻塞队列：**\n\n- ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。\n- LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。\n- PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。\n- DelayQueue：一个使用优先级队列实现的无界阻塞队列。\n- SynchronousQueue：一个不存储元素的阻塞队列。\n- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。\n- LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。\n\nDelayQUeue\n===============\nDelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。DelayQueue非常有用，可以将DelayQueue运用在以下应用场景：\n\n- 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。\n- 定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。\n\nDelayed一种混合风格的接口，用来标记那些应该在给定延迟时间之后执行的对象。此接口的实现必须定义一个 compareTo方法，该方法提供与此接口的getDelay方法一致的排序。\n\n使用DelayQueue\n--------------\n\n**一、实现Delayed接口：**\nDelayQueue队列的元素必须实现Delayed接口。我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类的实现,首先，在对象创建的时候，初始化基本数据。使用time记录当前对象延迟到什么时候可以使用，使用sequenceNumber来标识元素在队列中的先后顺序。代码如下：\n```java\nprivate static final AtomicLong sequencer = new AtomicLong(0);\nScheduled FutureTask(Runnable r, V result, long ns, long period) {\nScheduled FutureTask(Runnable r, V result, long ns, long period) {\n            super(r, result);\n            this.time = ns;\n            this.period = period;\n            this.sequence Number = sequencer.getAndIncrement();\n}\n```\n第二步：实现getDelay方法，该方法返回当前元素还需要延时多长时间，单位是纳秒，代码如下。\n```java\npublic long getDelay(TimeUnit unit) {\n            return unit.convert(time - now(), Time Unit.NANOSECONDS);\n        }\n```\n通过构造函数可以看出延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为实现getDelay()方法时可以指定任意单位，一旦以秒或分作为单位，而延时时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。\n第三步：实现compareTo方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。实现代码如下:\n```java\npublic int compareTo(Delayed other) {\n            if (other == this)// compare zero ONLY if same object\n                return 0;\n            if (other instanceof Scheduled FutureTask) {\n                Scheduled FutureTask<> x = (Scheduled FutureTask<>)other;\n                long diff = time - x.time;\n                if (diff < 0)\n                    return -1;\n                else if (diff > 0)\n                    return 1;\n                else if (sequence Number < x.sequence Number)\n                    return -1;\n                else\n                    return 1;\n            }\n            long d = (getDelay(Time Unit.NANOSECONDS) -\n                        other.getDelay(Time Unit.NANOSECONDS));\n            return (d == 0)  0 : ((d < 0)  -1 : 1);\n        }\n```\n**二、实现延时阻塞队列**\n延时阻塞队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。\n```java\nlong delay = first.getDelay(Time Unit.NANOSECONDS);\nif (delay <= 0)\n    return q.poll();\nelse if (leader != null)\n        available.await();\nelse {\n    Thread thisThread = Thread.currentThread();\n    leader = thisThread;\n        try {\n                available.awaitNanos(delay);\n            } finally {\n                if (leader == thisThread)\n                leader = null;\n            }\n    }\n```\n代码中的变量leader是一个等待获取队列头部元素的线程。如果leader不等于空，表示已经有线程在等待获取队列的头元素。所以，使用await()方法让当前线程等待信号。如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。\n\n下面实现两种具体场景：\n--------------\n1、模拟一个考试的日子，考试时间为120分钟，30分钟后才可交卷，当时间到了，或学生都交完卷了考试结束。这个场景中几个点需要注意：\n\n- 考试时间为120分钟，30分钟后才可交卷，初始化考生完成试卷时间最小应为30分钟\n- 对于能够在120分钟内交卷的考生，如何实现这些考生交卷\n- 对于120分钟内没有完成考试的考生，在120分钟考试时间到后需要让他们强制交卷\n- 在所有的考生都交完卷后，需要将控制线程关闭\n\n实现思想：用DelayQueue存储考生（Student类），每一个考生都有自己的名字和完成试卷的时间，Teacher线程对DelayQueue进行监控，收取完成试卷小于120分钟的学生的试卷。当考试时间120分钟到时，先关闭Teacher线程，然后强制DelayQueue中还存在的考生交卷。每一个考生交卷都会进行一次countDownLatch.countDown()，当countDownLatch.await()不再阻塞说明所有考生都交完卷了，而后结束考试。\n\nStudent类实现Runnable和Delayed接口，之后就可以存入DelayQueue中去了：\n```java\nclass Student implements Runnable,Delayed{\n\n    private String name;\n    private long workTime;\n    private long submitTime;\n    private boolean isForce = false;\n    private CountDownLatch countDownLatch;\n    \n    public Student(){}\n    \n    public Student(String name,long workTime,CountDownLatch countDownLatch){\n        this.name = name;\n        this.workTime = workTime;\n        this.submitTime = TimeUnit.NANOSECONDS.convert(workTime, \n                                        TimeUnit.NANOSECONDS)+System.nanoTime();\n        this.countDownLatch = countDownLatch;\n    }\n    \n    @Override\n    public int compareTo(Delayed o) {\n        // TODO Auto-generated method stub\n        if(o == null || ! (o instanceof Student)) return 1;\n        if(o == this) return 0; \n        Student s = (Student)o;\n        if (this.workTime > s.workTime) {\n            return 1;\n        }else if (this.workTime == s.workTime) {\n            return 0;\n        }else {\n            return -1;\n        }\n    }\n\n    @Override\n    public long getDelay(TimeUnit unit) {\n        // TODO Auto-generated method stub\n        return unit.convert(submitTime - System.nanoTime(),  TimeUnit.NANOSECONDS);\n    }\n\n    @Override\n    public void run() {\n        // TODO Auto-generated method stub\n        if (isForce) {\n            System.out.println(name + \" 交卷, 希望用时\" + workTime + \"分钟\"+\" ,实际用时 120分钟\" );\n        }else {\n            System.out.println(name + \" 交卷, 希望用时\" + workTime + \n                                                \"分钟\"+\" ,实际用时 \"+workTime +\" 分钟\");  \n        }\n        countDownLatch.countDown();\n    }\n\n    public boolean isForce() {\n        return isForce;\n    }\n\n    public void setForce(boolean isForce) {\n        this.isForce = isForce;\n    }\n    \n}\n\n```\nTeacher类用来收取DelayQueue中时间到了的学生的试卷。也就是说一个学生如果用时大于30分钟小于120分钟，那么当时间到了的时候Teacheer类就会从QelayQueue中取出这个学生。\n```java\nclass Teacher implements Runnable{\n\n    private DelayQueue<Student> students;\n    public Teacher(DelayQueue<Student> students){\n        this.students = students;\n    }\n    \n    @Override\n    public void run() {\n        // TODO Auto-generated method stub\n        try {\n            System.out.println(\" test start\");\n            while(!Thread.interrupted()){\n                students.take().run();\n            }\n        } catch (Exception e) {\n            // TODO: handle exception\n            e.printStackTrace();\n        }\n    }\n    \n}\n```\nEndExam类是强制交卷类，当考生用时超过120分钟就会强制从DelayQueue中取出来。\n```java\nclass EndExam extends Student{\n\n    private DelayQueue<Student> students;\n    private CountDownLatch countDownLatch;\n    private Thread teacherThread;\n    \n    public EndExam(DelayQueue<Student> students, long workTime, \n                        CountDownLatch countDownLatch,Thread teacherThread) {\n        super(\"强制收卷\", workTime,countDownLatch);\n        this.students = students;\n        this.countDownLatch = countDownLatch;\n        this.teacherThread = teacherThread;\n    }\n    \n    @Override\n    public void run() {\n        // TODO Auto-generated method stub\n        \n        teacherThread.interrupt();\n        Student tmpStudent;\n        for (Iterator<Student> iterator2 = students.iterator(); iterator2.hasNext();) {\n            tmpStudent = iterator2.next();\n            tmpStudent.setForce(true);\n            tmpStudent.run();\n        }\n        countDownLatch.countDown();\n    }\n    \n}\n```\nExam是考试主类,包含一个main方法：\n```java\npublic class Exam {\n\n    public static void main(String[] args) throws InterruptedException {\n        // TODO Auto-generated method stub\n        int studentNumber = 20;\n        CountDownLatch countDownLatch = new CountDownLatch(studentNumber+1);\n        DelayQueue< Student> students = new DelayQueue<Student>();\n        Random random = new Random();\n        for (int i = 0; i < studentNumber; i++) {\n            students.put(new Student(\"student\"+(i+1), 30+random.nextInt(120),countDownLatch));\n        }\n        Thread teacherThread =new Thread(new Teacher(students)); \n        students.put(new EndExam(students, 120,countDownLatch,teacherThread));\n        teacherThread.start();\n        countDownLatch.await();\n        System.out.println(\" 考试时间到，全部交卷！\");  \n    }\n\n}\n```\n\n**2、具有过期时间的缓存**\n向缓存添加内容时，给每一个key设定过期时间，系统自动将超过过期时间的key清除。这个场景中几个点需要注意：\n\n- 当向缓存中添加key-value对时，如果这个key在缓存中存在并且还没有过期，需要用这个key对应的新过期时间。\n- 为了能够让DelayQueue将其已保存的key删除，需要重写实现Delayed接口可添加到DelayQueue的DelayedItem的hashCode函数和equals函数。\n- 当缓存关闭，监控程序也应关闭，因而监控线程应当用守护线程。\n\nCache主类：\n```java\npublic class Cache<K, V> {\n\n    public ConcurrentHashMap<K, V> map = new ConcurrentHashMap<K, V>();\n    public DelayQueue<DelayedItem<K>> queue = new DelayQueue<DelayedItem<K>>();\n    \n    public void put(K k,V v,long liveTime){\n        V v2 = map.put(k, v);\n        DelayedItem<K> tmpItem = new DelayedItem<K>(k, liveTime);\n        if (v2 != null) {\n            queue.remove(tmpItem);\n        }\n        queue.put(tmpItem);\n    }\n    \n    public Cache(){\n        Thread t = new Thread(){\n            @Override\n            public void run(){\n                dameonCheckOverdueKey();\n            }\n        };\n        t.setDaemon(true);\n        t.start();\n    }\n    \n    public void dameonCheckOverdueKey(){\n        while (true) {\n            DelayedItem<K> delayedItem = queue.poll();\n            if (delayedItem != null) {\n                map.remove(delayedItem.getT());\n                System.out.println(System.nanoTime()+\" remove \"+\n                                delayedItem.getT() +\" from cache\");\n            }\n            try {\n                Thread.sleep(300);\n            } catch (Exception e) {\n                // TODO: handle exception\n            }\n        }\n    }\n    \n    public static void main(String[] args) throws InterruptedException {\n        Random random = new Random();\n        int cacheNumber = 10;\n        int liveTime = 0;\n        Cache<String, Integer> cache = new Cache<String, Integer>();\n        \n        for (int i = 0; i < cacheNumber; i++) {\n            liveTime = random.nextInt(3000);\n            System.out.println(i+\"  \"+liveTime);\n            cache.put(i+\"\", i, random.nextInt(liveTime));\n            if (random.nextInt(cacheNumber) > 7) {\n                liveTime = random.nextInt(3000);\n                System.out.println(i+\"  \"+liveTime);\n                cache.put(i+\"\", i, random.nextInt(liveTime));\n            }\n        }\n\n        Thread.sleep(3000);\n        System.out.println();\n    }\n\n}\n```\nDelayedItem类：\n```java\nclass DelayedItem<T> implements Delayed{\n\n    private T t;\n    private long liveTime ;\n    private long removeTime;\n    \n    public DelayedItem(T t,long liveTime){\n        this.setT(t);\n        this.liveTime = liveTime;\n        this.removeTime = TimeUnit.NANOSECONDS.convert(liveTime, TimeUnit.NANOSECONDS) + \n                                        System.nanoTime();\n    }\n    \n    @Override\n    public int compareTo(Delayed o) {\n        if (o == null) return 1;\n        if (o == this) return  0;\n        if (o instanceof DelayedItem){\n            DelayedItem<T> tmpDelayedItem = (DelayedItem<T>)o;\n            if (liveTime > tmpDelayedItem.liveTime ) {\n                return 1;\n            }else if (liveTime == tmpDelayedItem.liveTime) {\n                return 0;\n            }else {\n                return -1;\n            }\n        }\n        long diff = getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS);\n        return diff > 0 ? 1:diff == 0? 0:-1;\n    }\n\n    @Override\n    public long getDelay(TimeUnit unit) {\n        return unit.convert(removeTime - System.nanoTime(), unit);\n    }\n\n    public T getT() {\n        return t;\n    }\n\n    public void setT(T t) {\n        this.t = t;\n    }\n    @Override\n    public int hashCode(){\n        return t.hashCode();\n    }\n    \n    @Override\n    public boolean equals(Object object){\n        if (object instanceof DelayedItem) {\n            return object.hashCode() == hashCode() ?true:false;\n        }\n        return false;\n    }\n    \n}\n```\n\n","slug":"阻塞队列DealayQueue","published":1,"updated":"2017-07-12T01:45:50.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hso0j000zasvlolc8cw39","content":"<h1 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h1><p>阻塞队列（BlockingQueue）是那些支持持阻塞的插入和移除的队列。<br>1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p>\n<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法/处理方式</th>\n<th>抛出异常</th>\n<th>返回特殊值</th>\n<th>一直阻塞</th>\n<th>超时退出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">插入方法</td>\n<td>add(e)</td>\n<td>offer(e)</td>\n<td>put(e)</td>\n<td>ofer(e,time,unit)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">移除方法</td>\n<td>remove()</td>\n<td>poll()</td>\n<td>take()</td>\n<td>poll(time,unit)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">检查方法</td>\n<td>element()</td>\n<td>peek()</td>\n<td>不可用</td>\n<td>不可用</td>\n</tr>\n</tbody>\n</table>\n<p>·抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。<br>·返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。<br>·一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。<br>·超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</p>\n<p><strong>注意:</strong>如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true。</p>\n<p><strong>JDK 7中的阻塞队列：</strong></p>\n<ul>\n<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>\n<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>\n<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>\n<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>\n<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>\n<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>\n<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>\n</ul>\n<h1 id=\"DelayQUeue\"><a href=\"#DelayQUeue\" class=\"headerlink\" title=\"DelayQUeue\"></a>DelayQUeue</h1><p>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。DelayQueue非常有用，可以将DelayQueue运用在以下应用场景：</p>\n<ul>\n<li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</li>\n<li>定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。</li>\n</ul>\n<p>Delayed一种混合风格的接口，用来标记那些应该在给定延迟时间之后执行的对象。此接口的实现必须定义一个 compareTo方法，该方法提供与此接口的getDelay方法一致的排序。</p>\n<h2 id=\"使用DelayQueue\"><a href=\"#使用DelayQueue\" class=\"headerlink\" title=\"使用DelayQueue\"></a>使用DelayQueue</h2><p><strong>一、实现Delayed接口：</strong><br>DelayQueue队列的元素必须实现Delayed接口。我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类的实现,首先，在对象创建的时候，初始化基本数据。使用time记录当前对象延迟到什么时候可以使用，使用sequenceNumber来标识元素在队列中的先后顺序。代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicLong sequencer = <span class=\"keyword\">new</span> AtomicLong(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"function\">Scheduled <span class=\"title\">FutureTask</span><span class=\"params\">(Runnable r, V result, <span class=\"keyword\">long</span> ns, <span class=\"keyword\">long</span> period)</span> </span>&#123;</div><div class=\"line\"><span class=\"function\">Scheduled <span class=\"title\">FutureTask</span><span class=\"params\">(Runnable r, V result, <span class=\"keyword\">long</span> ns, <span class=\"keyword\">long</span> period)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>(r, result);</div><div class=\"line\">            <span class=\"keyword\">this</span>.time = ns;</div><div class=\"line\">            <span class=\"keyword\">this</span>.period = period;</div><div class=\"line\">            <span class=\"keyword\">this</span>.sequence Number = sequencer.getAndIncrement();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第二步：实现getDelay方法，该方法返回当前元素还需要延时多长时间，单位是纳秒，代码如下。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getDelay</span><span class=\"params\">(TimeUnit unit)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> unit.convert(time - now(), Time Unit.NANOSECONDS);</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>通过构造函数可以看出延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为实现getDelay()方法时可以指定任意单位，一旦以秒或分作为单位，而延时时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。<br>第三步：实现compareTo方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。实现代码如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Delayed other)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (other == <span class=\"keyword\">this</span>)<span class=\"comment\">// compare zero ONLY if same object</span></div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (other <span class=\"keyword\">instanceof</span> Scheduled FutureTask) &#123;</div><div class=\"line\">                Scheduled FutureTask&lt;&gt; x = (Scheduled FutureTask&lt;&gt;)other;</div><div class=\"line\">                <span class=\"keyword\">long</span> diff = time - x.time;</div><div class=\"line\">                <span class=\"keyword\">if</span> (diff &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (diff &gt; <span class=\"number\">0</span>)</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sequence Number &lt; x.sequence Number)</div><div class=\"line\">                    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"keyword\">else</span></div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">long</span> d = (getDelay(Time Unit.NANOSECONDS) -</div><div class=\"line\">                        other.getDelay(Time Unit.NANOSECONDS));</div><div class=\"line\">            <span class=\"keyword\">return</span> (d == <span class=\"number\">0</span>)  <span class=\"number\">0</span> : ((d &lt; <span class=\"number\">0</span>)  -<span class=\"number\">1</span> : <span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p><strong>二、实现延时阻塞队列</strong><br>延时阻塞队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">long</span> delay = first.getDelay(Time Unit.NANOSECONDS);</div><div class=\"line\"><span class=\"keyword\">if</span> (delay &lt;= <span class=\"number\">0</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> q.poll();</div><div class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leader != <span class=\"keyword\">null</span>)</div><div class=\"line\">        available.await();</div><div class=\"line\"><span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Thread thisThread = Thread.currentThread();</div><div class=\"line\">    leader = thisThread;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                available.awaitNanos(delay);</div><div class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (leader == thisThread)</div><div class=\"line\">                leader = <span class=\"keyword\">null</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>代码中的变量leader是一个等待获取队列头部元素的线程。如果leader不等于空，表示已经有线程在等待获取队列的头元素。所以，使用await()方法让当前线程等待信号。如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。</p>\n<h2 id=\"下面实现两种具体场景：\"><a href=\"#下面实现两种具体场景：\" class=\"headerlink\" title=\"下面实现两种具体场景：\"></a>下面实现两种具体场景：</h2><p>1、模拟一个考试的日子，考试时间为120分钟，30分钟后才可交卷，当时间到了，或学生都交完卷了考试结束。这个场景中几个点需要注意：</p>\n<ul>\n<li>考试时间为120分钟，30分钟后才可交卷，初始化考生完成试卷时间最小应为30分钟</li>\n<li>对于能够在120分钟内交卷的考生，如何实现这些考生交卷</li>\n<li>对于120分钟内没有完成考试的考生，在120分钟考试时间到后需要让他们强制交卷</li>\n<li>在所有的考生都交完卷后，需要将控制线程关闭</li>\n</ul>\n<p>实现思想：用DelayQueue存储考生（Student类），每一个考生都有自己的名字和完成试卷的时间，Teacher线程对DelayQueue进行监控，收取完成试卷小于120分钟的学生的试卷。当考试时间120分钟到时，先关闭Teacher线程，然后强制DelayQueue中还存在的考生交卷。每一个考生交卷都会进行一次countDownLatch.countDown()，当countDownLatch.await()不再阻塞说明所有考生都交完卷了，而后结束考试。</p>\n<p>Student类实现Runnable和Delayed接口，之后就可以存入DelayQueue中去了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span>,<span class=\"title\">Delayed</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> workTime;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> submitTime;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isForce = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch countDownLatch;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(String name,<span class=\"keyword\">long</span> workTime,CountDownLatch countDownLatch)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.workTime = workTime;</div><div class=\"line\">        <span class=\"keyword\">this</span>.submitTime = TimeUnit.NANOSECONDS.convert(workTime, </div><div class=\"line\">                                        TimeUnit.NANOSECONDS)+System.nanoTime();</div><div class=\"line\">        <span class=\"keyword\">this</span>.countDownLatch = countDownLatch;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Delayed o)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(o == <span class=\"keyword\">null</span> || ! (o <span class=\"keyword\">instanceof</span> Student)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>(o == <span class=\"keyword\">this</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </div><div class=\"line\">        Student s = (Student)o;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.workTime &gt; s.workTime) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.workTime == s.workTime) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getDelay</span><span class=\"params\">(TimeUnit unit)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">        <span class=\"keyword\">return</span> unit.convert(submitTime - System.nanoTime(),  TimeUnit.NANOSECONDS);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (isForce) &#123;</div><div class=\"line\">            System.out.println(name + <span class=\"string\">\" 交卷, 希望用时\"</span> + workTime + <span class=\"string\">\"分钟\"</span>+<span class=\"string\">\" ,实际用时 120分钟\"</span> );</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            System.out.println(name + <span class=\"string\">\" 交卷, 希望用时\"</span> + workTime + </div><div class=\"line\">                                                <span class=\"string\">\"分钟\"</span>+<span class=\"string\">\" ,实际用时 \"</span>+workTime +<span class=\"string\">\" 分钟\"</span>);  </div><div class=\"line\">        &#125;</div><div class=\"line\">        countDownLatch.countDown();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isForce</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> isForce;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setForce</span><span class=\"params\">(<span class=\"keyword\">boolean</span> isForce)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.isForce = isForce;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Teacher类用来收取DelayQueue中时间到了的学生的试卷。也就是说一个学生如果用时大于30分钟小于120分钟，那么当时间到了的时候Teacheer类就会从QelayQueue中取出这个学生。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Teacher</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> DelayQueue&lt;Student&gt; students;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Teacher</span><span class=\"params\">(DelayQueue&lt;Student&gt; students)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.students = students;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\" test start\"</span>);</div><div class=\"line\">            <span class=\"keyword\">while</span>(!Thread.interrupted())&#123;</div><div class=\"line\">                students.take().run();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> handle exception</span></div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>EndExam类是强制交卷类，当考生用时超过120分钟就会强制从DelayQueue中取出来。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EndExam</span> <span class=\"keyword\">extends</span> <span class=\"title\">Student</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> DelayQueue&lt;Student&gt; students;</div><div class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch countDownLatch;</div><div class=\"line\">    <span class=\"keyword\">private</span> Thread teacherThread;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EndExam</span><span class=\"params\">(DelayQueue&lt;Student&gt; students, <span class=\"keyword\">long</span> workTime, </span></span></div><div class=\"line\">                        CountDownLatch countDownLatch,Thread teacherThread) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">\"强制收卷\"</span>, workTime,countDownLatch);</div><div class=\"line\">        <span class=\"keyword\">this</span>.students = students;</div><div class=\"line\">        <span class=\"keyword\">this</span>.countDownLatch = countDownLatch;</div><div class=\"line\">        <span class=\"keyword\">this</span>.teacherThread = teacherThread;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">        </div><div class=\"line\">        teacherThread.interrupt();</div><div class=\"line\">        Student tmpStudent;</div><div class=\"line\">        <span class=\"keyword\">for</span> (Iterator&lt;Student&gt; iterator2 = students.iterator(); iterator2.hasNext();) &#123;</div><div class=\"line\">            tmpStudent = iterator2.next();</div><div class=\"line\">            tmpStudent.setForce(<span class=\"keyword\">true</span>);</div><div class=\"line\">            tmpStudent.run();</div><div class=\"line\">        &#125;</div><div class=\"line\">        countDownLatch.countDown();</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Exam是考试主类,包含一个main方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Exam</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">        <span class=\"keyword\">int</span> studentNumber = <span class=\"number\">20</span>;</div><div class=\"line\">        CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(studentNumber+<span class=\"number\">1</span>);</div><div class=\"line\">        DelayQueue&lt; Student&gt; students = <span class=\"keyword\">new</span> DelayQueue&lt;Student&gt;();</div><div class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; studentNumber; i++) &#123;</div><div class=\"line\">            students.put(<span class=\"keyword\">new</span> Student(<span class=\"string\">\"student\"</span>+(i+<span class=\"number\">1</span>), <span class=\"number\">30</span>+random.nextInt(<span class=\"number\">120</span>),countDownLatch));</div><div class=\"line\">        &#125;</div><div class=\"line\">        Thread teacherThread =<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Teacher(students)); </div><div class=\"line\">        students.put(<span class=\"keyword\">new</span> EndExam(students, <span class=\"number\">120</span>,countDownLatch,teacherThread));</div><div class=\"line\">        teacherThread.start();</div><div class=\"line\">        countDownLatch.await();</div><div class=\"line\">        System.out.println(<span class=\"string\">\" 考试时间到，全部交卷！\"</span>);  </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>2、具有过期时间的缓存</strong><br>向缓存添加内容时，给每一个key设定过期时间，系统自动将超过过期时间的key清除。这个场景中几个点需要注意：</p>\n<ul>\n<li>当向缓存中添加key-value对时，如果这个key在缓存中存在并且还没有过期，需要用这个key对应的新过期时间。</li>\n<li>为了能够让DelayQueue将其已保存的key删除，需要重写实现Delayed接口可添加到DelayQueue的DelayedItem的hashCode函数和equals函数。</li>\n<li>当缓存关闭，监控程序也应关闭，因而监控线程应当用守护线程。</li>\n</ul>\n<p>Cache主类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cache</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> ConcurrentHashMap&lt;K, V&gt; map = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;K, V&gt;();</div><div class=\"line\">    <span class=\"keyword\">public</span> DelayQueue&lt;DelayedItem&lt;K&gt;&gt; queue = <span class=\"keyword\">new</span> DelayQueue&lt;DelayedItem&lt;K&gt;&gt;();</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(K k,V v,<span class=\"keyword\">long</span> liveTime)</span></span>&#123;</div><div class=\"line\">        V v2 = map.put(k, v);</div><div class=\"line\">        DelayedItem&lt;K&gt; tmpItem = <span class=\"keyword\">new</span> DelayedItem&lt;K&gt;(k, liveTime);</div><div class=\"line\">        <span class=\"keyword\">if</span> (v2 != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            queue.remove(tmpItem);</div><div class=\"line\">        &#125;</div><div class=\"line\">        queue.put(tmpItem);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cache</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread()&#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">                dameonCheckOverdueKey();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div><div class=\"line\">        t.setDaemon(<span class=\"keyword\">true</span>);</div><div class=\"line\">        t.start();</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dameonCheckOverdueKey</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">            DelayedItem&lt;K&gt; delayedItem = queue.poll();</div><div class=\"line\">            <span class=\"keyword\">if</span> (delayedItem != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                map.remove(delayedItem.getT());</div><div class=\"line\">                System.out.println(System.nanoTime()+<span class=\"string\">\" remove \"</span>+</div><div class=\"line\">                                delayedItem.getT() +<span class=\"string\">\" from cache\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">                <span class=\"comment\">// <span class=\"doctag\">TODO:</span> handle exception</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</div><div class=\"line\">        <span class=\"keyword\">int</span> cacheNumber = <span class=\"number\">10</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> liveTime = <span class=\"number\">0</span>;</div><div class=\"line\">        Cache&lt;String, Integer&gt; cache = <span class=\"keyword\">new</span> Cache&lt;String, Integer&gt;();</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cacheNumber; i++) &#123;</div><div class=\"line\">            liveTime = random.nextInt(<span class=\"number\">3000</span>);</div><div class=\"line\">            System.out.println(i+<span class=\"string\">\"  \"</span>+liveTime);</div><div class=\"line\">            cache.put(i+<span class=\"string\">\"\"</span>, i, random.nextInt(liveTime));</div><div class=\"line\">            <span class=\"keyword\">if</span> (random.nextInt(cacheNumber) &gt; <span class=\"number\">7</span>) &#123;</div><div class=\"line\">                liveTime = random.nextInt(<span class=\"number\">3000</span>);</div><div class=\"line\">                System.out.println(i+<span class=\"string\">\"  \"</span>+liveTime);</div><div class=\"line\">                cache.put(i+<span class=\"string\">\"\"</span>, i, random.nextInt(liveTime));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Thread.sleep(<span class=\"number\">3000</span>);</div><div class=\"line\">        System.out.println();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>DelayedItem类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayedItem</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Delayed</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> T t;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> liveTime ;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> removeTime;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DelayedItem</span><span class=\"params\">(T t,<span class=\"keyword\">long</span> liveTime)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.setT(t);</div><div class=\"line\">        <span class=\"keyword\">this</span>.liveTime = liveTime;</div><div class=\"line\">        <span class=\"keyword\">this</span>.removeTime = TimeUnit.NANOSECONDS.convert(liveTime, TimeUnit.NANOSECONDS) + </div><div class=\"line\">                                        System.nanoTime();</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Delayed o)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>) <span class=\"keyword\">return</span>  <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> DelayedItem)&#123;</div><div class=\"line\">            DelayedItem&lt;T&gt; tmpDelayedItem = (DelayedItem&lt;T&gt;)o;</div><div class=\"line\">            <span class=\"keyword\">if</span> (liveTime &gt; tmpDelayedItem.liveTime ) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (liveTime == tmpDelayedItem.liveTime) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> diff = getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS);</div><div class=\"line\">        <span class=\"keyword\">return</span> diff &gt; <span class=\"number\">0</span> ? <span class=\"number\">1</span>:diff == <span class=\"number\">0</span>? <span class=\"number\">0</span>:-<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getDelay</span><span class=\"params\">(TimeUnit unit)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> unit.convert(removeTime - System.nanoTime(), unit);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getT</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> t;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.t = t;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> t.hashCode();</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object object)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (object <span class=\"keyword\">instanceof</span> DelayedItem) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> object.hashCode() == hashCode() ?<span class=\"keyword\">true</span>:<span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h1><p>阻塞队列（BlockingQueue）是那些支持持阻塞的插入和移除的队列。<br>1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p>\n<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法/处理方式</th>\n<th>抛出异常</th>\n<th>返回特殊值</th>\n<th>一直阻塞</th>\n<th>超时退出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">插入方法</td>\n<td>add(e)</td>\n<td>offer(e)</td>\n<td>put(e)</td>\n<td>ofer(e,time,unit)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">移除方法</td>\n<td>remove()</td>\n<td>poll()</td>\n<td>take()</td>\n<td>poll(time,unit)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">检查方法</td>\n<td>element()</td>\n<td>peek()</td>\n<td>不可用</td>\n<td>不可用</td>\n</tr>\n</tbody>\n</table>\n<p>·抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。<br>·返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。<br>·一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。<br>·超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</p>\n<p><strong>注意:</strong>如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永远不会被阻塞，而且使用offer方法时，该方法永远返回true。</p>\n<p><strong>JDK 7中的阻塞队列：</strong></p>\n<ul>\n<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>\n<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>\n<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>\n<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>\n<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>\n<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>\n<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>\n</ul>\n<h1 id=\"DelayQUeue\"><a href=\"#DelayQUeue\" class=\"headerlink\" title=\"DelayQUeue\"></a>DelayQUeue</h1><p>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。DelayQueue非常有用，可以将DelayQueue运用在以下应用场景：</p>\n<ul>\n<li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</li>\n<li>定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。</li>\n</ul>\n<p>Delayed一种混合风格的接口，用来标记那些应该在给定延迟时间之后执行的对象。此接口的实现必须定义一个 compareTo方法，该方法提供与此接口的getDelay方法一致的排序。</p>\n<h2 id=\"使用DelayQueue\"><a href=\"#使用DelayQueue\" class=\"headerlink\" title=\"使用DelayQueue\"></a>使用DelayQueue</h2><p><strong>一、实现Delayed接口：</strong><br>DelayQueue队列的元素必须实现Delayed接口。我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类的实现,首先，在对象创建的时候，初始化基本数据。使用time记录当前对象延迟到什么时候可以使用，使用sequenceNumber来标识元素在队列中的先后顺序。代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicLong sequencer = <span class=\"keyword\">new</span> AtomicLong(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"function\">Scheduled <span class=\"title\">FutureTask</span><span class=\"params\">(Runnable r, V result, <span class=\"keyword\">long</span> ns, <span class=\"keyword\">long</span> period)</span> </span>&#123;</div><div class=\"line\"><span class=\"function\">Scheduled <span class=\"title\">FutureTask</span><span class=\"params\">(Runnable r, V result, <span class=\"keyword\">long</span> ns, <span class=\"keyword\">long</span> period)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>(r, result);</div><div class=\"line\">            <span class=\"keyword\">this</span>.time = ns;</div><div class=\"line\">            <span class=\"keyword\">this</span>.period = period;</div><div class=\"line\">            <span class=\"keyword\">this</span>.sequence Number = sequencer.getAndIncrement();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>第二步：实现getDelay方法，该方法返回当前元素还需要延时多长时间，单位是纳秒，代码如下。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getDelay</span><span class=\"params\">(TimeUnit unit)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> unit.convert(time - now(), Time Unit.NANOSECONDS);</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>通过构造函数可以看出延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为实现getDelay()方法时可以指定任意单位，一旦以秒或分作为单位，而延时时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。<br>第三步：实现compareTo方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。实现代码如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Delayed other)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (other == <span class=\"keyword\">this</span>)<span class=\"comment\">// compare zero ONLY if same object</span></div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span> (other <span class=\"keyword\">instanceof</span> Scheduled FutureTask) &#123;</div><div class=\"line\">                Scheduled FutureTask&lt;&gt; x = (Scheduled FutureTask&lt;&gt;)other;</div><div class=\"line\">                <span class=\"keyword\">long</span> diff = time - x.time;</div><div class=\"line\">                <span class=\"keyword\">if</span> (diff &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (diff &gt; <span class=\"number\">0</span>)</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sequence Number &lt; x.sequence Number)</div><div class=\"line\">                    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">                <span class=\"keyword\">else</span></div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">long</span> d = (getDelay(Time Unit.NANOSECONDS) -</div><div class=\"line\">                        other.getDelay(Time Unit.NANOSECONDS));</div><div class=\"line\">            <span class=\"keyword\">return</span> (d == <span class=\"number\">0</span>)  <span class=\"number\">0</span> : ((d &lt; <span class=\"number\">0</span>)  -<span class=\"number\">1</span> : <span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p><strong>二、实现延时阻塞队列</strong><br>延时阻塞队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">long</span> delay = first.getDelay(Time Unit.NANOSECONDS);</div><div class=\"line\"><span class=\"keyword\">if</span> (delay &lt;= <span class=\"number\">0</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> q.poll();</div><div class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (leader != <span class=\"keyword\">null</span>)</div><div class=\"line\">        available.await();</div><div class=\"line\"><span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    Thread thisThread = Thread.currentThread();</div><div class=\"line\">    leader = thisThread;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                available.awaitNanos(delay);</div><div class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (leader == thisThread)</div><div class=\"line\">                leader = <span class=\"keyword\">null</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>代码中的变量leader是一个等待获取队列头部元素的线程。如果leader不等于空，表示已经有线程在等待获取队列的头元素。所以，使用await()方法让当前线程等待信号。如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。</p>\n<h2 id=\"下面实现两种具体场景：\"><a href=\"#下面实现两种具体场景：\" class=\"headerlink\" title=\"下面实现两种具体场景：\"></a>下面实现两种具体场景：</h2><p>1、模拟一个考试的日子，考试时间为120分钟，30分钟后才可交卷，当时间到了，或学生都交完卷了考试结束。这个场景中几个点需要注意：</p>\n<ul>\n<li>考试时间为120分钟，30分钟后才可交卷，初始化考生完成试卷时间最小应为30分钟</li>\n<li>对于能够在120分钟内交卷的考生，如何实现这些考生交卷</li>\n<li>对于120分钟内没有完成考试的考生，在120分钟考试时间到后需要让他们强制交卷</li>\n<li>在所有的考生都交完卷后，需要将控制线程关闭</li>\n</ul>\n<p>实现思想：用DelayQueue存储考生（Student类），每一个考生都有自己的名字和完成试卷的时间，Teacher线程对DelayQueue进行监控，收取完成试卷小于120分钟的学生的试卷。当考试时间120分钟到时，先关闭Teacher线程，然后强制DelayQueue中还存在的考生交卷。每一个考生交卷都会进行一次countDownLatch.countDown()，当countDownLatch.await()不再阻塞说明所有考生都交完卷了，而后结束考试。</p>\n<p>Student类实现Runnable和Delayed接口，之后就可以存入DelayQueue中去了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span>,<span class=\"title\">Delayed</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> workTime;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> submitTime;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isForce = <span class=\"keyword\">false</span>;</div><div class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch countDownLatch;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">()</span></span>&#123;&#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(String name,<span class=\"keyword\">long</span> workTime,CountDownLatch countDownLatch)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.workTime = workTime;</div><div class=\"line\">        <span class=\"keyword\">this</span>.submitTime = TimeUnit.NANOSECONDS.convert(workTime, </div><div class=\"line\">                                        TimeUnit.NANOSECONDS)+System.nanoTime();</div><div class=\"line\">        <span class=\"keyword\">this</span>.countDownLatch = countDownLatch;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Delayed o)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(o == <span class=\"keyword\">null</span> || ! (o <span class=\"keyword\">instanceof</span> Student)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>(o == <span class=\"keyword\">this</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </div><div class=\"line\">        Student s = (Student)o;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.workTime &gt; s.workTime) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.workTime == s.workTime) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getDelay</span><span class=\"params\">(TimeUnit unit)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">        <span class=\"keyword\">return</span> unit.convert(submitTime - System.nanoTime(),  TimeUnit.NANOSECONDS);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (isForce) &#123;</div><div class=\"line\">            System.out.println(name + <span class=\"string\">\" 交卷, 希望用时\"</span> + workTime + <span class=\"string\">\"分钟\"</span>+<span class=\"string\">\" ,实际用时 120分钟\"</span> );</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            System.out.println(name + <span class=\"string\">\" 交卷, 希望用时\"</span> + workTime + </div><div class=\"line\">                                                <span class=\"string\">\"分钟\"</span>+<span class=\"string\">\" ,实际用时 \"</span>+workTime +<span class=\"string\">\" 分钟\"</span>);  </div><div class=\"line\">        &#125;</div><div class=\"line\">        countDownLatch.countDown();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isForce</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> isForce;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setForce</span><span class=\"params\">(<span class=\"keyword\">boolean</span> isForce)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.isForce = isForce;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Teacher类用来收取DelayQueue中时间到了的学生的试卷。也就是说一个学生如果用时大于30分钟小于120分钟，那么当时间到了的时候Teacheer类就会从QelayQueue中取出这个学生。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Teacher</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> DelayQueue&lt;Student&gt; students;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Teacher</span><span class=\"params\">(DelayQueue&lt;Student&gt; students)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.students = students;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\" test start\"</span>);</div><div class=\"line\">            <span class=\"keyword\">while</span>(!Thread.interrupted())&#123;</div><div class=\"line\">                students.take().run();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> handle exception</span></div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>EndExam类是强制交卷类，当考生用时超过120分钟就会强制从DelayQueue中取出来。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EndExam</span> <span class=\"keyword\">extends</span> <span class=\"title\">Student</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> DelayQueue&lt;Student&gt; students;</div><div class=\"line\">    <span class=\"keyword\">private</span> CountDownLatch countDownLatch;</div><div class=\"line\">    <span class=\"keyword\">private</span> Thread teacherThread;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EndExam</span><span class=\"params\">(DelayQueue&lt;Student&gt; students, <span class=\"keyword\">long</span> workTime, </span></span></div><div class=\"line\">                        CountDownLatch countDownLatch,Thread teacherThread) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">\"强制收卷\"</span>, workTime,countDownLatch);</div><div class=\"line\">        <span class=\"keyword\">this</span>.students = students;</div><div class=\"line\">        <span class=\"keyword\">this</span>.countDownLatch = countDownLatch;</div><div class=\"line\">        <span class=\"keyword\">this</span>.teacherThread = teacherThread;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">        </div><div class=\"line\">        teacherThread.interrupt();</div><div class=\"line\">        Student tmpStudent;</div><div class=\"line\">        <span class=\"keyword\">for</span> (Iterator&lt;Student&gt; iterator2 = students.iterator(); iterator2.hasNext();) &#123;</div><div class=\"line\">            tmpStudent = iterator2.next();</div><div class=\"line\">            tmpStudent.setForce(<span class=\"keyword\">true</span>);</div><div class=\"line\">            tmpStudent.run();</div><div class=\"line\">        &#125;</div><div class=\"line\">        countDownLatch.countDown();</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Exam是考试主类,包含一个main方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Exam</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></div><div class=\"line\">        <span class=\"keyword\">int</span> studentNumber = <span class=\"number\">20</span>;</div><div class=\"line\">        CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(studentNumber+<span class=\"number\">1</span>);</div><div class=\"line\">        DelayQueue&lt; Student&gt; students = <span class=\"keyword\">new</span> DelayQueue&lt;Student&gt;();</div><div class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; studentNumber; i++) &#123;</div><div class=\"line\">            students.put(<span class=\"keyword\">new</span> Student(<span class=\"string\">\"student\"</span>+(i+<span class=\"number\">1</span>), <span class=\"number\">30</span>+random.nextInt(<span class=\"number\">120</span>),countDownLatch));</div><div class=\"line\">        &#125;</div><div class=\"line\">        Thread teacherThread =<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Teacher(students)); </div><div class=\"line\">        students.put(<span class=\"keyword\">new</span> EndExam(students, <span class=\"number\">120</span>,countDownLatch,teacherThread));</div><div class=\"line\">        teacherThread.start();</div><div class=\"line\">        countDownLatch.await();</div><div class=\"line\">        System.out.println(<span class=\"string\">\" 考试时间到，全部交卷！\"</span>);  </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>2、具有过期时间的缓存</strong><br>向缓存添加内容时，给每一个key设定过期时间，系统自动将超过过期时间的key清除。这个场景中几个点需要注意：</p>\n<ul>\n<li>当向缓存中添加key-value对时，如果这个key在缓存中存在并且还没有过期，需要用这个key对应的新过期时间。</li>\n<li>为了能够让DelayQueue将其已保存的key删除，需要重写实现Delayed接口可添加到DelayQueue的DelayedItem的hashCode函数和equals函数。</li>\n<li>当缓存关闭，监控程序也应关闭，因而监控线程应当用守护线程。</li>\n</ul>\n<p>Cache主类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cache</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">public</span> ConcurrentHashMap&lt;K, V&gt; map = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;K, V&gt;();</div><div class=\"line\">    <span class=\"keyword\">public</span> DelayQueue&lt;DelayedItem&lt;K&gt;&gt; queue = <span class=\"keyword\">new</span> DelayQueue&lt;DelayedItem&lt;K&gt;&gt;();</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(K k,V v,<span class=\"keyword\">long</span> liveTime)</span></span>&#123;</div><div class=\"line\">        V v2 = map.put(k, v);</div><div class=\"line\">        DelayedItem&lt;K&gt; tmpItem = <span class=\"keyword\">new</span> DelayedItem&lt;K&gt;(k, liveTime);</div><div class=\"line\">        <span class=\"keyword\">if</span> (v2 != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            queue.remove(tmpItem);</div><div class=\"line\">        &#125;</div><div class=\"line\">        queue.put(tmpItem);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cache</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread()&#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">                dameonCheckOverdueKey();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div><div class=\"line\">        t.setDaemon(<span class=\"keyword\">true</span>);</div><div class=\"line\">        t.start();</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dameonCheckOverdueKey</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">            DelayedItem&lt;K&gt; delayedItem = queue.poll();</div><div class=\"line\">            <span class=\"keyword\">if</span> (delayedItem != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                map.remove(delayedItem.getT());</div><div class=\"line\">                System.out.println(System.nanoTime()+<span class=\"string\">\" remove \"</span>+</div><div class=\"line\">                                delayedItem.getT() +<span class=\"string\">\" from cache\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                Thread.sleep(<span class=\"number\">300</span>);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">                <span class=\"comment\">// <span class=\"doctag\">TODO:</span> handle exception</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</div><div class=\"line\">        <span class=\"keyword\">int</span> cacheNumber = <span class=\"number\">10</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> liveTime = <span class=\"number\">0</span>;</div><div class=\"line\">        Cache&lt;String, Integer&gt; cache = <span class=\"keyword\">new</span> Cache&lt;String, Integer&gt;();</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cacheNumber; i++) &#123;</div><div class=\"line\">            liveTime = random.nextInt(<span class=\"number\">3000</span>);</div><div class=\"line\">            System.out.println(i+<span class=\"string\">\"  \"</span>+liveTime);</div><div class=\"line\">            cache.put(i+<span class=\"string\">\"\"</span>, i, random.nextInt(liveTime));</div><div class=\"line\">            <span class=\"keyword\">if</span> (random.nextInt(cacheNumber) &gt; <span class=\"number\">7</span>) &#123;</div><div class=\"line\">                liveTime = random.nextInt(<span class=\"number\">3000</span>);</div><div class=\"line\">                System.out.println(i+<span class=\"string\">\"  \"</span>+liveTime);</div><div class=\"line\">                cache.put(i+<span class=\"string\">\"\"</span>, i, random.nextInt(liveTime));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        Thread.sleep(<span class=\"number\">3000</span>);</div><div class=\"line\">        System.out.println();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>DelayedItem类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayedItem</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Delayed</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> T t;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> liveTime ;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> removeTime;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DelayedItem</span><span class=\"params\">(T t,<span class=\"keyword\">long</span> liveTime)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.setT(t);</div><div class=\"line\">        <span class=\"keyword\">this</span>.liveTime = liveTime;</div><div class=\"line\">        <span class=\"keyword\">this</span>.removeTime = TimeUnit.NANOSECONDS.convert(liveTime, TimeUnit.NANOSECONDS) + </div><div class=\"line\">                                        System.nanoTime();</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Delayed o)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>) <span class=\"keyword\">return</span>  <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> DelayedItem)&#123;</div><div class=\"line\">            DelayedItem&lt;T&gt; tmpDelayedItem = (DelayedItem&lt;T&gt;)o;</div><div class=\"line\">            <span class=\"keyword\">if</span> (liveTime &gt; tmpDelayedItem.liveTime ) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (liveTime == tmpDelayedItem.liveTime) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> diff = getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS);</div><div class=\"line\">        <span class=\"keyword\">return</span> diff &gt; <span class=\"number\">0</span> ? <span class=\"number\">1</span>:diff == <span class=\"number\">0</span>? <span class=\"number\">0</span>:-<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getDelay</span><span class=\"params\">(TimeUnit unit)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> unit.convert(removeTime - System.nanoTime(), unit);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getT</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> t;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setT</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.t = t;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> t.hashCode();</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object object)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (object <span class=\"keyword\">instanceof</span> DelayedItem) &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> object.hashCode() == hashCode() ?<span class=\"keyword\">true</span>:<span class=\"keyword\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"<font color=#0099ff size=6 face=\"微软雅黑\">阻塞队列 PriorityBlockingQueue</font>","date":"2017-06-14T01:37:23.000Z","_content":"\nPriorityBlockingQueue是一个基于优先级堆的无界的并发安全的优先级队列（FIFO），队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的Comparator进行排序，具体取决于所使用的构造方法。PriorityBlockingQueue里面存储的对象必须是实现Comparable接口。队列通过这个接口的compare方法确定对象的priority。\n\nPriorityBlockingQueue通过使用堆这种数据结构实现将队列中的元素按照某种排序规则进行排序，从而改变先进先出的队列顺序，提供开发者改变队列中元素的顺序的能力。队列中的元素必须是可比较的，即实现Comparable接口，或者在构建函数时提供可对队列元素进行比较的Comparator对象。\n\nPriorityBlockingQueue通过内部组合PriorityQueue的方式实现优先级队列（private final PriorityQueue q;），另外在外层通过ReentrantLock实现线程安全，同时通过Condition实现阻塞唤醒。\n\n具体实现请去看JDK源码。这里给出一篇源码分析的博客：[优先级对列PriorityBlockingQueue][1]\n\n要说明的一点是：\n**PriorityBlockingQueue中若多个元素的优先级相同，则其顺序是不固定的，可以采用二级比较方法来进一步排序。**\n\n有没有人在使用PriorityBlockingQueue时，发现将添加在PriorityBlockingQueue的一系列元素打印出来，队列的元素其实并不是全部按优先级排序的，但是队列头的优先级肯定是最高的？\n回复：这就是因为PriorityBlockingQueue使用了堆来进行排序。只保证头元素是优先级最高的。\n\n利用PriorityBlockingQueue实现基于优先级的Executor类：\n==========\n使用Executor框架，只需要实现任务并将他们传递到执行器中，然后执行器将负责创建执行任务的线程，并执行这些线程。执行器内部使用一个阻塞队列存放等待执行的任务，并按任务到达执行器时的顺序进行存放。但是如果使用优先级队列存放任务，就可以使高优先级的任务先到达执行器，它会先被执行。\n\n具体实现例子：\n创建一个MyPriorityTask类，实现Runnable和Comparable类。\n```java\nimport org.jetbrains.annotations.NotNull;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Created by Catyee on 2017/6/12.\n */\npublic class MyPriorityTask implements Runnable, Comparable<MyPriorityTask>{\n\n    private int priority;\n    private String name;\n\n    public MyPriorityTask(int priority, String name) {\n        this.priority = priority;\n        this.name = name;\n    }\n\n    public int getPriority() {\n        return priority;\n    }\n\n    @Override\n    public int compareTo(@NotNull MyPriorityTask o) {\n        if(this.getPriority() < o.getPriority()){\n            return 1;\n        }\n        if(this.getPriority() > o.getPriority()){\n            return -1;\n        }\n        return 0;\n    }\n\n    @Override\n    public void run() {\n        System.out.printf(\"MyPriorityTask: %s Priority : %d\\n\", name, priority);\n        try{\n            TimeUnit.SECONDS.sleep(2);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n这个类中重写了Comparable接口中的compareTo()方法，它接收一个MyPriorityTask对象作为参数，然后比较当前和参数对象的优先级值。让高优先级的任务先于低优先级的任务执行。同时重写了Runnable接口中的Run()方法，打印出信息并休眠2s。\n\n创建一个Main主类，在里面声明TreadPoolExecutor，去执行任务：\n```java\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.PriorityBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Created by Catyee on 2017/6/12.\n */\npublic class Main {\n    public static void main(String[] args){\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(2,2,1, TimeUnit.SECONDS, new PriorityBlockingQueue<Runnable>());\n        for(int i = 0; i < 4; i++){\n            MyPriorityTask task = new MyPriorityTask(i, \"Task \"+i);\n            executor.execute(task);\n        }\n        try{\n            TimeUnit.SECONDS.sleep(1);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n        for(int i = 4; i < 8; i++){\n            MyPriorityTask task = new MyPriorityTask(i, \"Task \"+i);\n            executor.execute(task);\n        }\n        executor.shutdown();\n        try{\n            executor.awaitTermination(1, TimeUnit.DAYS);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n        System.out.printf(\"Main: end of the program.\\n\");\n    }\n}\n```\n这里创建TreadPollExecutor对象的时候，要传入带Runnable泛型参数的PriorityBlockingQueue。先后创建了八个任务并赋予了不同的优先级，可以看到低优先级的先传入进线程池，但是会后于高优先级的任务执行。\n执行结果：\n```java\nMyPriorityTask: Task 0 Priority : 0\nMyPriorityTask: Task 1 Priority : 1\nMyPriorityTask: Task 7 Priority : 7\nMyPriorityTask: Task 6 Priority : 6\nMyPriorityTask: Task 5 Priority : 5\nMyPriorityTask: Task 4 Priority : 4\nMyPriorityTask: Task 3 Priority : 3\nMyPriorityTask: Task 2 Priority : 2\nMain: end of the program.\n\nProcess finished with exit code 0\n```\n这里我们只创建了两个线程池执行器，当执行器空闲并等待任务时，第一批任务到达，它们将立即被执行。接下来，剩余任务基于他们优先级被依次执行。\n\n  [1]: http://blog.sina.com.cn/s/blog_6145ed8101010q1y.html","source":"_posts/阻塞队列 PriorityBlockingQueue.md","raw":"---\ntitle: <font color=#0099ff size=6 face=\"微软雅黑\">阻塞队列 PriorityBlockingQueue</font>\ndate: 2017-06-14 09:37:23\ncategories: java多线程\ntags: [java,多线程,阻塞队列,PriorityBlockingQueue]\n---\n\nPriorityBlockingQueue是一个基于优先级堆的无界的并发安全的优先级队列（FIFO），队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的Comparator进行排序，具体取决于所使用的构造方法。PriorityBlockingQueue里面存储的对象必须是实现Comparable接口。队列通过这个接口的compare方法确定对象的priority。\n\nPriorityBlockingQueue通过使用堆这种数据结构实现将队列中的元素按照某种排序规则进行排序，从而改变先进先出的队列顺序，提供开发者改变队列中元素的顺序的能力。队列中的元素必须是可比较的，即实现Comparable接口，或者在构建函数时提供可对队列元素进行比较的Comparator对象。\n\nPriorityBlockingQueue通过内部组合PriorityQueue的方式实现优先级队列（private final PriorityQueue q;），另外在外层通过ReentrantLock实现线程安全，同时通过Condition实现阻塞唤醒。\n\n具体实现请去看JDK源码。这里给出一篇源码分析的博客：[优先级对列PriorityBlockingQueue][1]\n\n要说明的一点是：\n**PriorityBlockingQueue中若多个元素的优先级相同，则其顺序是不固定的，可以采用二级比较方法来进一步排序。**\n\n有没有人在使用PriorityBlockingQueue时，发现将添加在PriorityBlockingQueue的一系列元素打印出来，队列的元素其实并不是全部按优先级排序的，但是队列头的优先级肯定是最高的？\n回复：这就是因为PriorityBlockingQueue使用了堆来进行排序。只保证头元素是优先级最高的。\n\n利用PriorityBlockingQueue实现基于优先级的Executor类：\n==========\n使用Executor框架，只需要实现任务并将他们传递到执行器中，然后执行器将负责创建执行任务的线程，并执行这些线程。执行器内部使用一个阻塞队列存放等待执行的任务，并按任务到达执行器时的顺序进行存放。但是如果使用优先级队列存放任务，就可以使高优先级的任务先到达执行器，它会先被执行。\n\n具体实现例子：\n创建一个MyPriorityTask类，实现Runnable和Comparable类。\n```java\nimport org.jetbrains.annotations.NotNull;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Created by Catyee on 2017/6/12.\n */\npublic class MyPriorityTask implements Runnable, Comparable<MyPriorityTask>{\n\n    private int priority;\n    private String name;\n\n    public MyPriorityTask(int priority, String name) {\n        this.priority = priority;\n        this.name = name;\n    }\n\n    public int getPriority() {\n        return priority;\n    }\n\n    @Override\n    public int compareTo(@NotNull MyPriorityTask o) {\n        if(this.getPriority() < o.getPriority()){\n            return 1;\n        }\n        if(this.getPriority() > o.getPriority()){\n            return -1;\n        }\n        return 0;\n    }\n\n    @Override\n    public void run() {\n        System.out.printf(\"MyPriorityTask: %s Priority : %d\\n\", name, priority);\n        try{\n            TimeUnit.SECONDS.sleep(2);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n这个类中重写了Comparable接口中的compareTo()方法，它接收一个MyPriorityTask对象作为参数，然后比较当前和参数对象的优先级值。让高优先级的任务先于低优先级的任务执行。同时重写了Runnable接口中的Run()方法，打印出信息并休眠2s。\n\n创建一个Main主类，在里面声明TreadPoolExecutor，去执行任务：\n```java\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.PriorityBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Created by Catyee on 2017/6/12.\n */\npublic class Main {\n    public static void main(String[] args){\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(2,2,1, TimeUnit.SECONDS, new PriorityBlockingQueue<Runnable>());\n        for(int i = 0; i < 4; i++){\n            MyPriorityTask task = new MyPriorityTask(i, \"Task \"+i);\n            executor.execute(task);\n        }\n        try{\n            TimeUnit.SECONDS.sleep(1);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n        for(int i = 4; i < 8; i++){\n            MyPriorityTask task = new MyPriorityTask(i, \"Task \"+i);\n            executor.execute(task);\n        }\n        executor.shutdown();\n        try{\n            executor.awaitTermination(1, TimeUnit.DAYS);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n        System.out.printf(\"Main: end of the program.\\n\");\n    }\n}\n```\n这里创建TreadPollExecutor对象的时候，要传入带Runnable泛型参数的PriorityBlockingQueue。先后创建了八个任务并赋予了不同的优先级，可以看到低优先级的先传入进线程池，但是会后于高优先级的任务执行。\n执行结果：\n```java\nMyPriorityTask: Task 0 Priority : 0\nMyPriorityTask: Task 1 Priority : 1\nMyPriorityTask: Task 7 Priority : 7\nMyPriorityTask: Task 6 Priority : 6\nMyPriorityTask: Task 5 Priority : 5\nMyPriorityTask: Task 4 Priority : 4\nMyPriorityTask: Task 3 Priority : 3\nMyPriorityTask: Task 2 Priority : 2\nMain: end of the program.\n\nProcess finished with exit code 0\n```\n这里我们只创建了两个线程池执行器，当执行器空闲并等待任务时，第一批任务到达，它们将立即被执行。接下来，剩余任务基于他们优先级被依次执行。\n\n  [1]: http://blog.sina.com.cn/s/blog_6145ed8101010q1y.html","slug":"阻塞队列 PriorityBlockingQueue","published":1,"updated":"2017-07-12T01:46:30.394Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj57hso0k0013asvlpvw83k8g","content":"<p>PriorityBlockingQueue是一个基于优先级堆的无界的并发安全的优先级队列（FIFO），队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的Comparator进行排序，具体取决于所使用的构造方法。PriorityBlockingQueue里面存储的对象必须是实现Comparable接口。队列通过这个接口的compare方法确定对象的priority。</p>\n<p>PriorityBlockingQueue通过使用堆这种数据结构实现将队列中的元素按照某种排序规则进行排序，从而改变先进先出的队列顺序，提供开发者改变队列中元素的顺序的能力。队列中的元素必须是可比较的，即实现Comparable接口，或者在构建函数时提供可对队列元素进行比较的Comparator对象。</p>\n<p>PriorityBlockingQueue通过内部组合PriorityQueue的方式实现优先级队列（private final PriorityQueue q;），另外在外层通过ReentrantLock实现线程安全，同时通过Condition实现阻塞唤醒。</p>\n<p>具体实现请去看JDK源码。这里给出一篇源码分析的博客：<a href=\"http://blog.sina.com.cn/s/blog_6145ed8101010q1y.html\">优先级对列PriorityBlockingQueue</a></p>\n<p>要说明的一点是：<br><strong>PriorityBlockingQueue中若多个元素的优先级相同，则其顺序是不固定的，可以采用二级比较方法来进一步排序。</strong></p>\n<p>有没有人在使用PriorityBlockingQueue时，发现将添加在PriorityBlockingQueue的一系列元素打印出来，队列的元素其实并不是全部按优先级排序的，但是队列头的优先级肯定是最高的？<br>回复：这就是因为PriorityBlockingQueue使用了堆来进行排序。只保证头元素是优先级最高的。</p>\n<h1 id=\"利用PriorityBlockingQueue实现基于优先级的Executor类：\"><a href=\"#利用PriorityBlockingQueue实现基于优先级的Executor类：\" class=\"headerlink\" title=\"利用PriorityBlockingQueue实现基于优先级的Executor类：\"></a>利用PriorityBlockingQueue实现基于优先级的Executor类：</h1><p>使用Executor框架，只需要实现任务并将他们传递到执行器中，然后执行器将负责创建执行任务的线程，并执行这些线程。执行器内部使用一个阻塞队列存放等待执行的任务，并按任务到达执行器时的顺序进行存放。但是如果使用优先级队列存放任务，就可以使高优先级的任务先到达执行器，它会先被执行。</p>\n<p>具体实现例子：<br>创建一个MyPriorityTask类，实现Runnable和Comparable类。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> org.jetbrains.annotations.NotNull;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Created by Catyee on 2017/6/12.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPriorityTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span>, <span class=\"title\">Comparable</span>&lt;<span class=\"title\">MyPriorityTask</span>&gt;</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> priority;</div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyPriorityTask</span><span class=\"params\">(<span class=\"keyword\">int</span> priority, String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.priority = priority;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getPriority</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> priority;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(@NotNull MyPriorityTask o)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.getPriority() &lt; o.getPriority())&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.getPriority() &gt; o.getPriority())&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.printf(<span class=\"string\">\"MyPriorityTask: %s Priority : %d\\n\"</span>, name, priority);</div><div class=\"line\">        <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个类中重写了Comparable接口中的compareTo()方法，它接收一个MyPriorityTask对象作为参数，然后比较当前和参数对象的优先级值。让高优先级的任务先于低优先级的任务执行。同时重写了Runnable接口中的Run()方法，打印出信息并休眠2s。</p>\n<p>创建一个Main主类，在里面声明TreadPoolExecutor，去执行任务：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CountDownLatch;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.PriorityBlockingQueue;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ThreadPoolExecutor;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Created by Catyee on 2017/6/12.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</div><div class=\"line\">        ThreadPoolExecutor executor = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>, TimeUnit.SECONDS, <span class=\"keyword\">new</span> PriorityBlockingQueue&lt;Runnable&gt;());</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</div><div class=\"line\">            MyPriorityTask task = <span class=\"keyword\">new</span> MyPriorityTask(i, <span class=\"string\">\"Task \"</span>+i);</div><div class=\"line\">            executor.execute(task);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">4</span>; i &lt; <span class=\"number\">8</span>; i++)&#123;</div><div class=\"line\">            MyPriorityTask task = <span class=\"keyword\">new</span> MyPriorityTask(i, <span class=\"string\">\"Task \"</span>+i);</div><div class=\"line\">            executor.execute(task);</div><div class=\"line\">        &#125;</div><div class=\"line\">        executor.shutdown();</div><div class=\"line\">        <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">            executor.awaitTermination(<span class=\"number\">1</span>, TimeUnit.DAYS);</div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        System.out.printf(<span class=\"string\">\"Main: end of the program.\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里创建TreadPollExecutor对象的时候，要传入带Runnable泛型参数的PriorityBlockingQueue。先后创建了八个任务并赋予了不同的优先级，可以看到低优先级的先传入进线程池，但是会后于高优先级的任务执行。<br>执行结果：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyPriorityTask: Task <span class=\"number\">0</span> Priority : <span class=\"number\">0</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">1</span> Priority : <span class=\"number\">1</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">7</span> Priority : <span class=\"number\">7</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">6</span> Priority : <span class=\"number\">6</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">5</span> Priority : <span class=\"number\">5</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">4</span> Priority : <span class=\"number\">4</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">3</span> Priority : <span class=\"number\">3</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">2</span> Priority : <span class=\"number\">2</span></div><div class=\"line\">Main: end of the program.</div><div class=\"line\"></div><div class=\"line\">Process finished with exit code <span class=\"number\">0</span></div></pre></td></tr></table></figure></p>\n<p>这里我们只创建了两个线程池执行器，当执行器空闲并等待任务时，第一批任务到达，它们将立即被执行。接下来，剩余任务基于他们优先级被依次执行。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>PriorityBlockingQueue是一个基于优先级堆的无界的并发安全的优先级队列（FIFO），队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的Comparator进行排序，具体取决于所使用的构造方法。PriorityBlockingQueue里面存储的对象必须是实现Comparable接口。队列通过这个接口的compare方法确定对象的priority。</p>\n<p>PriorityBlockingQueue通过使用堆这种数据结构实现将队列中的元素按照某种排序规则进行排序，从而改变先进先出的队列顺序，提供开发者改变队列中元素的顺序的能力。队列中的元素必须是可比较的，即实现Comparable接口，或者在构建函数时提供可对队列元素进行比较的Comparator对象。</p>\n<p>PriorityBlockingQueue通过内部组合PriorityQueue的方式实现优先级队列（private final PriorityQueue q;），另外在外层通过ReentrantLock实现线程安全，同时通过Condition实现阻塞唤醒。</p>\n<p>具体实现请去看JDK源码。这里给出一篇源码分析的博客：<a href=\"http://blog.sina.com.cn/s/blog_6145ed8101010q1y.html\">优先级对列PriorityBlockingQueue</a></p>\n<p>要说明的一点是：<br><strong>PriorityBlockingQueue中若多个元素的优先级相同，则其顺序是不固定的，可以采用二级比较方法来进一步排序。</strong></p>\n<p>有没有人在使用PriorityBlockingQueue时，发现将添加在PriorityBlockingQueue的一系列元素打印出来，队列的元素其实并不是全部按优先级排序的，但是队列头的优先级肯定是最高的？<br>回复：这就是因为PriorityBlockingQueue使用了堆来进行排序。只保证头元素是优先级最高的。</p>\n<h1 id=\"利用PriorityBlockingQueue实现基于优先级的Executor类：\"><a href=\"#利用PriorityBlockingQueue实现基于优先级的Executor类：\" class=\"headerlink\" title=\"利用PriorityBlockingQueue实现基于优先级的Executor类：\"></a>利用PriorityBlockingQueue实现基于优先级的Executor类：</h1><p>使用Executor框架，只需要实现任务并将他们传递到执行器中，然后执行器将负责创建执行任务的线程，并执行这些线程。执行器内部使用一个阻塞队列存放等待执行的任务，并按任务到达执行器时的顺序进行存放。但是如果使用优先级队列存放任务，就可以使高优先级的任务先到达执行器，它会先被执行。</p>\n<p>具体实现例子：<br>创建一个MyPriorityTask类，实现Runnable和Comparable类。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> org.jetbrains.annotations.NotNull;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Created by Catyee on 2017/6/12.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPriorityTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span>, <span class=\"title\">Comparable</span>&lt;<span class=\"title\">MyPriorityTask</span>&gt;</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> priority;</div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyPriorityTask</span><span class=\"params\">(<span class=\"keyword\">int</span> priority, String name)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.priority = priority;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getPriority</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> priority;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(@NotNull MyPriorityTask o)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.getPriority() &lt; o.getPriority())&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.getPriority() &gt; o.getPriority())&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.printf(<span class=\"string\">\"MyPriorityTask: %s Priority : %d\\n\"</span>, name, priority);</div><div class=\"line\">        <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">2</span>);</div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个类中重写了Comparable接口中的compareTo()方法，它接收一个MyPriorityTask对象作为参数，然后比较当前和参数对象的优先级值。让高优先级的任务先于低优先级的任务执行。同时重写了Runnable接口中的Run()方法，打印出信息并休眠2s。</p>\n<p>创建一个Main主类，在里面声明TreadPoolExecutor，去执行任务：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CountDownLatch;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.PriorityBlockingQueue;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ThreadPoolExecutor;</div><div class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Created by Catyee on 2017/6/12.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</div><div class=\"line\">        ThreadPoolExecutor executor = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>, TimeUnit.SECONDS, <span class=\"keyword\">new</span> PriorityBlockingQueue&lt;Runnable&gt;());</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</div><div class=\"line\">            MyPriorityTask task = <span class=\"keyword\">new</span> MyPriorityTask(i, <span class=\"string\">\"Task \"</span>+i);</div><div class=\"line\">            executor.execute(task);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">4</span>; i &lt; <span class=\"number\">8</span>; i++)&#123;</div><div class=\"line\">            MyPriorityTask task = <span class=\"keyword\">new</span> MyPriorityTask(i, <span class=\"string\">\"Task \"</span>+i);</div><div class=\"line\">            executor.execute(task);</div><div class=\"line\">        &#125;</div><div class=\"line\">        executor.shutdown();</div><div class=\"line\">        <span class=\"keyword\">try</span>&#123;</div><div class=\"line\">            executor.awaitTermination(<span class=\"number\">1</span>, TimeUnit.DAYS);</div><div class=\"line\">        &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125;</div><div class=\"line\">        System.out.printf(<span class=\"string\">\"Main: end of the program.\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里创建TreadPollExecutor对象的时候，要传入带Runnable泛型参数的PriorityBlockingQueue。先后创建了八个任务并赋予了不同的优先级，可以看到低优先级的先传入进线程池，但是会后于高优先级的任务执行。<br>执行结果：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyPriorityTask: Task <span class=\"number\">0</span> Priority : <span class=\"number\">0</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">1</span> Priority : <span class=\"number\">1</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">7</span> Priority : <span class=\"number\">7</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">6</span> Priority : <span class=\"number\">6</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">5</span> Priority : <span class=\"number\">5</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">4</span> Priority : <span class=\"number\">4</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">3</span> Priority : <span class=\"number\">3</span></div><div class=\"line\">MyPriorityTask: Task <span class=\"number\">2</span> Priority : <span class=\"number\">2</span></div><div class=\"line\">Main: end of the program.</div><div class=\"line\"></div><div class=\"line\">Process finished with exit code <span class=\"number\">0</span></div></pre></td></tr></table></figure></p>\n<p>这里我们只创建了两个线程池执行器，当执行器空闲并等待任务时，第一批任务到达，它们将立即被执行。接下来，剩余任务基于他们优先级被依次执行。</p>\n"}],"PostAsset":[{"_id":"source/_posts/Spring实战（二）上下文和Bean的生命周期/spring1.png","slug":"spring1.png","post":"cj57hso0b000kasvlen6emvdp","modified":1,"renderable":0},{"_id":"source/_posts/Spring实战（二）上下文和Bean的生命周期/spring2.png","slug":"spring2.png","post":"cj57hso0b000kasvlen6emvdp","modified":1,"renderable":0},{"_id":"source/_posts/Java线程池/a.jpg","post":"cj57hsnzz0009asvlx098scwt","slug":"a.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Java线程池/b.jpg","post":"cj57hsnzz0009asvlx098scwt","slug":"b.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Java线程池/c.jpg","post":"cj57hsnzz0009asvlx098scwt","slug":"c.jpg","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cj57hsnzz0008asvlt9rpe2ys","category_id":"cj57hsnzp0004asvl1knsm9q5","_id":"cj57hso04000dasvlffobkkww"},{"post_id":"cj57hsnzh0001asvlgfgf62zp","category_id":"cj57hsnzp0004asvl1knsm9q5","_id":"cj57hso07000hasvl9z1lno2t"},{"post_id":"cj57hsnzm0003asvlzeorap7l","category_id":"cj57hsnzp0004asvl1knsm9q5","_id":"cj57hso0b000jasvlh24bi5o1"},{"post_id":"cj57hso05000easvllvndz8mm","category_id":"cj57hsnzp0004asvl1knsm9q5","_id":"cj57hso0d000nasvl0wbbtklu"},{"post_id":"cj57hso08000iasvlm3tb7jaw","category_id":"cj57hsnzp0004asvl1knsm9q5","_id":"cj57hso0f000qasvluixxm8o9"},{"post_id":"cj57hsnzt0007asvl0k3onrvu","category_id":"cj57hso06000fasvl6cft5ai3","_id":"cj57hso0h000vasvlcrebzjtm"},{"post_id":"cj57hso0b000kasvlen6emvdp","category_id":"cj57hsnzp0004asvl1knsm9q5","_id":"cj57hso0j000yasvlo0kzr52x"},{"post_id":"cj57hso0e000oasvl5b5rfdpx","category_id":"cj57hsnzp0004asvl1knsm9q5","_id":"cj57hso0k0012asvl5jqt12gs"},{"post_id":"cj57hsnzz0009asvlx098scwt","category_id":"cj57hso0d000lasvla4vji5zi","_id":"cj57hso0l0014asvlaybfaziq"},{"post_id":"cj57hso0f000rasvlxsdqnrew","category_id":"cj57hsnzp0004asvl1knsm9q5","_id":"cj57hso0m0016asvl0jqkfxal"},{"post_id":"cj57hso03000casvld41mti5h","category_id":"cj57hso0h000tasvl7gua4qqb","_id":"cj57hso0m0017asvl6bswphww"},{"post_id":"cj57hso0j000zasvlolc8cw39","category_id":"cj57hso0d000lasvla4vji5zi","_id":"cj57hso0o0018asvl6cghxvnv"},{"post_id":"cj57hso0k0013asvlpvw83k8g","category_id":"cj57hso0d000lasvla4vji5zi","_id":"cj57hso0o001basvl5x7lapk3"},{"post_id":"cj57hso0h000wasvlahjz9snw","category_id":"cj57hso0j0011asvl2xngqm1t","_id":"cj57hso0r001dasvlmeplllun"}],"PostTag":[{"post_id":"cj57hsnzh0001asvlgfgf62zp","tag_id":"cj57hsnzr0005asvl688gons2","_id":"cj57hso0f000pasvl88m8luht"},{"post_id":"cj57hsnzh0001asvlgfgf62zp","tag_id":"cj57hso00000basvl0iqfuibv","_id":"cj57hso0g000sasvlmo672nq9"},{"post_id":"cj57hsnzh0001asvlgfgf62zp","tag_id":"cj57hso06000gasvlmlnpxpnr","_id":"cj57hso0i000xasvlukuehgj5"},{"post_id":"cj57hsnzm0003asvlzeorap7l","tag_id":"cj57hsnzr0005asvl688gons2","_id":"cj57hso0o001aasvlx8474ohy"},{"post_id":"cj57hsnzm0003asvlzeorap7l","tag_id":"cj57hso00000basvl0iqfuibv","_id":"cj57hso0q001casvlfa50nk27"},{"post_id":"cj57hsnzm0003asvlzeorap7l","tag_id":"cj57hso06000gasvlmlnpxpnr","_id":"cj57hso0t001fasvl9ka7zbga"},{"post_id":"cj57hsnzm0003asvlzeorap7l","tag_id":"cj57hso0m0015asvll78sij59","_id":"cj57hso0t001gasvl5njnz8xz"},{"post_id":"cj57hsnzt0007asvl0k3onrvu","tag_id":"cj57hso0o0019asvl15jc1214","_id":"cj57hso0w001jasvl82b826bl"},{"post_id":"cj57hsnzt0007asvl0k3onrvu","tag_id":"cj57hso0s001easvl1i2bqo6t","_id":"cj57hso0w001kasvljcn3t4uh"},{"post_id":"cj57hsnzt0007asvl0k3onrvu","tag_id":"cj57hso0t001hasvlm02a7e4h","_id":"cj57hso0y001masvlr843z4ii"},{"post_id":"cj57hsnzz0008asvlt9rpe2ys","tag_id":"cj57hsnzr0005asvl688gons2","_id":"cj57hso0z001qasvlpibwi2tq"},{"post_id":"cj57hsnzz0008asvlt9rpe2ys","tag_id":"cj57hso00000basvl0iqfuibv","_id":"cj57hso0z001rasvl9e9wd2vv"},{"post_id":"cj57hsnzz0008asvlt9rpe2ys","tag_id":"cj57hso06000gasvlmlnpxpnr","_id":"cj57hso0z001tasvlriwqefx4"},{"post_id":"cj57hsnzz0008asvlt9rpe2ys","tag_id":"cj57hso0y001nasvls9yqbmlv","_id":"cj57hso10001uasvldmp2s54c"},{"post_id":"cj57hsnzz0008asvlt9rpe2ys","tag_id":"cj57hso0y001oasvlweawsboh","_id":"cj57hso10001wasvlfde4l9y1"},{"post_id":"cj57hsnzz0009asvlx098scwt","tag_id":"cj57hso0o0019asvl15jc1214","_id":"cj57hso120020asvlu2tye991"},{"post_id":"cj57hsnzz0009asvlx098scwt","tag_id":"cj57hso0z001sasvlbtd358ye","_id":"cj57hso120021asvlkdth19je"},{"post_id":"cj57hsnzz0009asvlx098scwt","tag_id":"cj57hso10001vasvl235131i3","_id":"cj57hso130023asvlb8swvl3v"},{"post_id":"cj57hsnzz0009asvlx098scwt","tag_id":"cj57hso11001xasvl0gf48x8g","_id":"cj57hso130024asvlh8la74g6"},{"post_id":"cj57hsnzz0009asvlx098scwt","tag_id":"cj57hso11001yasvl5meu5jib","_id":"cj57hso130026asvlem5kiy48"},{"post_id":"cj57hso03000casvld41mti5h","tag_id":"cj57hso12001zasvlxdu28g5q","_id":"cj57hso130027asvlv904zh4x"},{"post_id":"cj57hso03000casvld41mti5h","tag_id":"cj57hso120022asvlbiwh0m5g","_id":"cj57hso140029asvl85e8mh16"},{"post_id":"cj57hso05000easvllvndz8mm","tag_id":"cj57hso0o0019asvl15jc1214","_id":"cj57hso19002fasvlampqi021"},{"post_id":"cj57hso05000easvllvndz8mm","tag_id":"cj57hso140028asvltbjj6pkn","_id":"cj57hso19002gasvlocnpcwl6"},{"post_id":"cj57hso05000easvllvndz8mm","tag_id":"cj57hso14002aasvlihsoaln7","_id":"cj57hso1a002iasvltp5i3y5c"},{"post_id":"cj57hso05000easvllvndz8mm","tag_id":"cj57hso15002basvlan9j2n9f","_id":"cj57hso1a002jasvl7w5sw7ak"},{"post_id":"cj57hso05000easvllvndz8mm","tag_id":"cj57hso16002casvlg94nsnzc","_id":"cj57hso1a002lasvlok8e3y5b"},{"post_id":"cj57hso05000easvllvndz8mm","tag_id":"cj57hso17002dasvllw4w794f","_id":"cj57hso1a002masvl8iki0h0s"},{"post_id":"cj57hso08000iasvlm3tb7jaw","tag_id":"cj57hso0o0019asvl15jc1214","_id":"cj57hso1b002pasvlphm78j7x"},{"post_id":"cj57hso08000iasvlm3tb7jaw","tag_id":"cj57hso140028asvltbjj6pkn","_id":"cj57hso1c002qasvl6atu8bfv"},{"post_id":"cj57hso08000iasvlm3tb7jaw","tag_id":"cj57hso1a002kasvltt4rncmf","_id":"cj57hso1c002sasvlq009nls2"},{"post_id":"cj57hso08000iasvlm3tb7jaw","tag_id":"cj57hso1b002nasvla78h8pp6","_id":"cj57hso1c002tasvlj19egas6"},{"post_id":"cj57hso0b000kasvlen6emvdp","tag_id":"cj57hso0o0019asvl15jc1214","_id":"cj57hso1j002zasvlc9lxrfs6"},{"post_id":"cj57hso0b000kasvlen6emvdp","tag_id":"cj57hso140028asvltbjj6pkn","_id":"cj57hso1k0030asvl2f2cooc3"},{"post_id":"cj57hso0b000kasvlen6emvdp","tag_id":"cj57hso1a002kasvltt4rncmf","_id":"cj57hso1l0032asvl5g7076op"},{"post_id":"cj57hso0b000kasvlen6emvdp","tag_id":"cj57hso1h002vasvltq9uclb9","_id":"cj57hso1l0033asvlng54doto"},{"post_id":"cj57hso0b000kasvlen6emvdp","tag_id":"cj57hso1h002wasvlz9t00d2x","_id":"cj57hso1l0035asvl4loizf4f"},{"post_id":"cj57hso0b000kasvlen6emvdp","tag_id":"cj57hso1i002xasvlrf05mly0","_id":"cj57hso1m0036asvlcf5h9je1"},{"post_id":"cj57hso0e000oasvl5b5rfdpx","tag_id":"cj57hso0o0019asvl15jc1214","_id":"cj57hso1n0039asvlrt06mzos"},{"post_id":"cj57hso0e000oasvl5b5rfdpx","tag_id":"cj57hso140028asvltbjj6pkn","_id":"cj57hso1o003aasvl3e4bbu3i"},{"post_id":"cj57hso0e000oasvl5b5rfdpx","tag_id":"cj57hso1a002kasvltt4rncmf","_id":"cj57hso1o003casvl09edhxlx"},{"post_id":"cj57hso0e000oasvl5b5rfdpx","tag_id":"cj57hso1m0037asvlvi6g21dm","_id":"cj57hso1o003dasvl6c09f20h"},{"post_id":"cj57hso0f000rasvlxsdqnrew","tag_id":"cj57hso0o0019asvl15jc1214","_id":"cj57hso1p003gasvljfktx6by"},{"post_id":"cj57hso0f000rasvlxsdqnrew","tag_id":"cj57hso1o003basvl0q7h0tid","_id":"cj57hso1p003hasvll2foxgxw"},{"post_id":"cj57hso0f000rasvlxsdqnrew","tag_id":"cj57hso1o003easvlkfuqu2hu","_id":"cj57hso1p003jasvlmrx6glxf"},{"post_id":"cj57hso0h000wasvlahjz9snw","tag_id":"cj57hso1p003fasvluzjxoflf","_id":"cj57hso1r003nasvlvvjylq2a"},{"post_id":"cj57hso0h000wasvlahjz9snw","tag_id":"cj57hso1p003iasvlpadmykl7","_id":"cj57hso1r003oasvlkqq53pnv"},{"post_id":"cj57hso0h000wasvlahjz9snw","tag_id":"cj57hso1p003kasvlzjd73mbx","_id":"cj57hso1s003qasvlhlxcojl6"},{"post_id":"cj57hso0h000wasvlahjz9snw","tag_id":"cj57hso1q003lasvleox4v2sx","_id":"cj57hso1s003rasvlh5t1eig9"},{"post_id":"cj57hso0j000zasvlolc8cw39","tag_id":"cj57hso0o0019asvl15jc1214","_id":"cj57hso1t003vasvltbgoygjv"},{"post_id":"cj57hso0j000zasvlolc8cw39","tag_id":"cj57hso0z001sasvlbtd358ye","_id":"cj57hso1t003wasvlvh9sjd7d"},{"post_id":"cj57hso0j000zasvlolc8cw39","tag_id":"cj57hso1s003sasvlv87aa6ix","_id":"cj57hso1t003yasvln5bqy55p"},{"post_id":"cj57hso0j000zasvlolc8cw39","tag_id":"cj57hso1s003tasvlntlyjygt","_id":"cj57hso1u003zasvl1avhy254"},{"post_id":"cj57hso0k0013asvlpvw83k8g","tag_id":"cj57hso0o0019asvl15jc1214","_id":"cj57hso1v0042asvldjcfr0km"},{"post_id":"cj57hso0k0013asvlpvw83k8g","tag_id":"cj57hso0z001sasvlbtd358ye","_id":"cj57hso1v0043asvly1f774cm"},{"post_id":"cj57hso0k0013asvlpvw83k8g","tag_id":"cj57hso1s003sasvlv87aa6ix","_id":"cj57hso1v0044asvl4rxvknmx"},{"post_id":"cj57hso0k0013asvlpvw83k8g","tag_id":"cj57hso1v0041asvlzroao1wi","_id":"cj57hso1w0045asvllppjqlso"}],"Tag":[{"name":"Java","_id":"cj57hsnzr0005asvl688gons2"},{"name":"经验之谈","_id":"cj57hso00000basvl0iqfuibv"},{"name":"高效开发","_id":"cj57hso06000gasvlmlnpxpnr"},{"name":"Builder","_id":"cj57hso0m0015asvll78sij59"},{"name":"java","_id":"cj57hso0o0019asvl15jc1214"},{"name":"FreeMaker","_id":"cj57hso0s001easvl1i2bqo6t"},{"name":"模板引擎","_id":"cj57hso0t001hasvlm02a7e4h"},{"name":"Singleton","_id":"cj57hso0y001nasvls9yqbmlv"},{"name":"单例模式","_id":"cj57hso0y001oasvlweawsboh"},{"name":"多线程","_id":"cj57hso0z001sasvlbtd358ye"},{"name":"Executor","_id":"cj57hso10001vasvl235131i3"},{"name":"TreadPoolExecutor","_id":"cj57hso11001xasvl0gf48x8g"},{"name":"ExecutorService","_id":"cj57hso11001yasvl5meu5jib"},{"name":"Rest","_id":"cj57hso12001zasvlxdu28g5q"},{"name":"微服务","_id":"cj57hso120022asvlbiwh0m5g"},{"name":"Spring","_id":"cj57hso140028asvltbjj6pkn"},{"name":"依赖注入","_id":"cj57hso14002aasvlihsoaln7"},{"name":"面向切面编程","_id":"cj57hso15002basvlan9j2n9f"},{"name":"IoC","_id":"cj57hso16002casvlg94nsnzc"},{"name":"AOP","_id":"cj57hso17002dasvllw4w794f"},{"name":"Bean","_id":"cj57hso1a002kasvltt4rncmf"},{"name":"Java装配","_id":"cj57hso1b002nasvla78h8pp6"},{"name":"Context","_id":"cj57hso1h002vasvltq9uclb9"},{"name":"Spring模块","_id":"cj57hso1h002wasvlz9t00d2x"},{"name":"SpringBoot","_id":"cj57hso1i002xasvlrf05mly0"},{"name":"自动装配","_id":"cj57hso1m0037asvlvi6g21dm"},{"name":"设计模式","_id":"cj57hso1o003basvl0q7h0tid"},{"name":"策略模式","_id":"cj57hso1o003easvlkfuqu2hu"},{"name":"Linux","_id":"cj57hso1p003fasvluzjxoflf"},{"name":"Service","_id":"cj57hso1p003iasvlpadmykl7"},{"name":"后台服务","_id":"cj57hso1p003kasvlzjd73mbx"},{"name":"Chkconfig","_id":"cj57hso1q003lasvleox4v2sx"},{"name":"阻塞队列","_id":"cj57hso1s003sasvlv87aa6ix"},{"name":"DelayQUeue","_id":"cj57hso1s003tasvlntlyjygt"},{"name":"PriorityBlockingQueue","_id":"cj57hso1v0041asvlzroao1wi"}]}}